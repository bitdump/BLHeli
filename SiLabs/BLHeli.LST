MACRO ASSEMBLER BLHELI                                      06/18/13 19:58:16 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.12.11.280
OBJECT MODULE PLACED IN OUTPUT\PLATINUM_PRO_30A_MULTI_REV10_4.OBJ
ASSEMBLER INVOKED BY: SET(BESC=138) OBJECT(OUTPUT\PLATINUM_PRO_30A_MULTI_REV10_4.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copters/planes in general
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) at rates up to several hundred Hz.
                        35     ; The code adapts itself to the various input modes/frequencies
                        36     ; The code ESC can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESC EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ; - Rev8.0  Added a 2 second delay after power up, to wait for receiver initialization
                       119     ;           Added a programming option for disabling low voltage limit, and made it default for MULTI
                       120     ;           Added programable demag compensation, using the concept of SimonK
                       121     ;           Improved robustness against noisy input signal
                       122     ;           Refined direct startup
                       123     ;           Removed voltage compensation
                       124     ;           Miscellaneous other changes
                       125     ; - Rev9.0  Increased programming range for startup power, and made it's default ESC dependent
                       126     ;           Made default startup method ESC dependent
                       127     ;           Even more smooth and gentle spoolup for MAIN, to suit larger helis
                       128     ;           Improved transition from stepped startup to run
                       129     ;           Refined direct startup
                       130     ; - Rev9.1  Fixed bug that changed FW revision after throttle calibration or TX programming
                       131     ; - Rev9.2  Altered timing of throttle calibration in order to work with MultiWii calibration firmware
                       132     ;           Reduced main spoolup time to around 5 seconds
                       133     ;           Changed default beacon delay to 3 minutes
                       134     ; - Rev9.3  Fixed bug in Plush 60/80A temperature reading, that caused failure in operation above 4S
                       135     ;           Corrected temperature limit for HiModel cool 22/33/41A, RCTimer 6A, Skywalker 20/40A, Turnigy AE45A, Plush 40/60/80A. Limit was previously set too high
                       136     ; - Rev9.4  Improved timing for increased maximum rpm limit
                       137     ; - Rev10.0 Added closed loop mode for multi
                       138     ;           Added high/low BEC voltage option (for the ESCs where HW supports it)
                       139     ;           Added method of resetting all programmed parameter values to defaults by TX programming
                       140     ;           Added Turnigy K-force 40A and Turnigy K-force 120A HV ESCs
                       141     ;           Enabled fully damped mode for several ESCs
                       142     ;           Extended startup power range downwards to enable very smooth start for large heli main motors
                       143     ;           Extended damping force with a highest setting
                       144     ;           Corrected temperature limits for F310 chips (Plush 40A and AE 45A)
                       145     ;           Implemented temperature reading average in order to avoid problems with ADC noise on Skywalkers
                       146     ;           Increased switching delays for XP 7A fast, in order to avoid cross conduction of N and P fets
                       147     ;           Miscellaneous other changes
                       148     ; - Rev10.1 Relaxed RC signal jitter requirement during frequency measurement
                       149     ;           Corrected bug that prevented using governor low
                       150     ;           Enabled vdd monitor always, in order to reduce likelihood of accidental overwriting of adjustments
                       151     ;           Fixed bug that caused stop for PPM input above 2048us, and moved upper accepted limit to 2160us
                       152     ; - Rev10.2 Corrected temperature limit for AE20-30/XP7-25, where limit was too high
                       153     ;           Corrected temperature limit for 120HV, where limit was too low
                       154     ;           Fixed bug that caused AE20/25/30A not to run in reverse
                       155     ; - Rev10.3 Removed vdd monitor for 1S capable ESCs, in order to avoid brownouts/resets
                       156     ;           Made auto bailout spoolup for main more smooth
                       157     ; - Rev10.4 Ensured that main spoolup and governor activation will always be smooth, regardless of throttle input
                       158     ;           Added capability to operate on 12kHz input signal too
                       159     ;
                       160     ;
                       161     ;**** **** **** **** ****
                       162     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       163     ; 768 Bytes Internal SRAM
                       164     ;
                       165     ;**** **** **** **** ****
                       166     ; Master clock is internal 24MHz oscillator
                       167     ; Timer 0 (167/500ns counts) always counts up and is used for
                       168     ; - PWM generation
                       169     ; Timer 1 (167/500ns counts) always counts up and is not used
                       170     ; - Time from pwm on/off event
                       171     ; Timer 2 (500ns counts) always counts up and is used for
                       172     ; - RC pulse timeout/skip counts and commutation times
                       173     ; Timer 3 (500ns counts) always counts up and is used for
                       174     ; - Commutation timeouts
                       175     ; PCA0 (500ns counts) always counts up and is used for
                       176     ; - RC pulse measurement
                       177     ;
                       178     ;**** **** **** **** ****
                       179     ; Interrupt handling
                       180     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                       181     ; Also some interrupt flags need to be cleared by software
                       182     ; The code disables interrupts in interrupt routines, in order to avoid nested interrupts
                       183     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       184     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       185     ;
                       186     ;**** **** **** **** ****
                       187     ; Motor control:
                       188     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       189     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       190     ; - Timing advance in this implementation is set to 15deg nominally
                       191     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       192     ; Motor sequence starting from zero crossing:
                       193     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       194     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       195     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       196     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       197     ;
                       198     ; Motor startup in stepper mode:
                       199     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                       200     ; In this stepper motor mode comparator information is not used.
                       201     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                       202     ; Stepper phase comes next, where there is a step length decrease sequence.
                       203     ; Direct startup is the last phase, for synchronization before normal bemf commutation run begins.
                       204     ; Motor startup in direct mode:
                       205     ; Direct startup is the only phase, before normal bemf commutation run begins.
                       206     ;
                       207     ;**** **** **** **** ****
                       208     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 209     XP_3A_MAIN 				EQU 1
  0002                 210     XP_3A_TAIL 				EQU 2
  0003                 211     XP_3A_MULTI 				EQU 3
  0004                 212     XP_7A_MAIN 				EQU 4
  0005                 213     XP_7A_TAIL 				EQU 5
  0006                 214     XP_7A_MULTI 				EQU 6
  0007                 215     XP_7A_FAST_MAIN 			EQU 7
  0008                 216     XP_7A_FAST_TAIL 			EQU 8
  0009                 217     XP_7A_FAST_MULTI 			EQU 9
  000A                 218     XP_12A_MAIN 				EQU 10
  000B                 219     XP_12A_TAIL 				EQU 11
  000C                 220     XP_12A_MULTI 				EQU 12
  000D                 221     XP_18A_MAIN 				EQU 13
  000E                 222     XP_18A_TAIL 				EQU 14
  000F                 223     XP_18A_MULTI 				EQU 15
  0010                 224     XP_25A_MAIN 				EQU 16
  0011                 225     XP_25A_TAIL 				EQU 17
  0012                 226     XP_25A_MULTI 				EQU 18
  0013                 227     DP_3A_MAIN 				EQU 19
  0014                 228     DP_3A_TAIL  				EQU 20
  0015                 229     DP_3A_MULTI  				EQU 21
  0016                 230     SUPERMICRO_3P5A_MAIN 		EQU 22
  0017                 231     SUPERMICRO_3P5A_TAIL 		EQU 23   
  0018                 232     SUPERMICRO_3P5A_MULTI 		EQU 24   
  0019                 233     TURNIGY_PLUSH_6A_MAIN 		EQU 25
  001A                 234     TURNIGY_PLUSH_6A_TAIL 		EQU 26   
  001B                 235     TURNIGY_PLUSH_6A_MULTI 		EQU 27   
  001C                 236     TURNIGY_PLUSH_10A_MAIN 		EQU 28
  001D                 237     TURNIGY_PLUSH_10A_TAIL 		EQU 29   
  001E                 238     TURNIGY_PLUSH_10A_MULTI 		EQU 30   
  001F                 239     TURNIGY_PLUSH_12A_MAIN 		EQU 31
  0020                 240     TURNIGY_PLUSH_12A_TAIL 		EQU 32   
  0021                 241     TURNIGY_PLUSH_12A_MULTI 		EQU 33   
  0022                 242     TURNIGY_PLUSH_18A_MAIN 		EQU 34
  0023                 243     TURNIGY_PLUSH_18A_TAIL 		EQU 35   
  0024                 244     TURNIGY_PLUSH_18A_MULTI 		EQU 36   
  0025                 245     TURNIGY_PLUSH_25A_MAIN 		EQU 37
  0026                 246     TURNIGY_PLUSH_25A_TAIL 		EQU 38   
  0027                 247     TURNIGY_PLUSH_25A_MULTI 		EQU 39   
  0028                 248     TURNIGY_PLUSH_30A_MAIN 		EQU 40
  0029                 249     TURNIGY_PLUSH_30A_TAIL 		EQU 41   
  002A                 250     TURNIGY_PLUSH_30A_MULTI 		EQU 42   
  002B                 251     TURNIGY_PLUSH_40A_MAIN 		EQU 43
  002C                 252     TURNIGY_PLUSH_40A_TAIL 		EQU 44   
  002D                 253     TURNIGY_PLUSH_40A_MULTI 		EQU 45   
  002E                 254     TURNIGY_PLUSH_60A_MAIN 		EQU 46
  002F                 255     TURNIGY_PLUSH_60A_TAIL 		EQU 47   
  0030                 256     TURNIGY_PLUSH_60A_MULTI 		EQU 48   
  0031                 257     TURNIGY_PLUSH_80A_MAIN 		EQU 49
  0032                 258     TURNIGY_PLUSH_80A_TAIL 		EQU 50   
  0033                 259     TURNIGY_PLUSH_80A_MULTI 		EQU 51   
  0034                 260     TURNIGY_AE_20A_MAIN 		EQU 52
  0035                 261     TURNIGY_AE_20A_TAIL 		EQU 53   
  0036                 262     TURNIGY_AE_20A_MULTI 		EQU 54   
  0037                 263     TURNIGY_AE_25A_MAIN 		EQU 55
  0038                 264     TURNIGY_AE_25A_TAIL 		EQU 56   
  0039                 265     TURNIGY_AE_25A_MULTI 		EQU 57   
  003A                 266     TURNIGY_AE_30A_MAIN 		EQU 58
  003B                 267     TURNIGY_AE_30A_TAIL 		EQU 59   
  003C                 268     TURNIGY_AE_30A_MULTI 		EQU 60   
  003D                 269     TURNIGY_AE_45A_MAIN 		EQU 61
  003E                 270     TURNIGY_AE_45A_TAIL 		EQU 62   
  003F                 271     TURNIGY_AE_45A_MULTI 		EQU 63   
  0040                 272     TURNIGY_KFORCE_40A_MAIN 		EQU 64   
  0041                 273     TURNIGY_KFORCE_40A_TAIL 		EQU 65   
  0042                 274     TURNIGY_KFORCE_40A_MULTI 	EQU 66   
  0043                 275     TURNIGY_KFORCE_120A_HV_MAIN 	EQU 67   
  0044                 276     TURNIGY_KFORCE_120A_HV_TAIL 	EQU 68   
  0045                 277     TURNIGY_KFORCE_120A_HV_MULTI 	EQU 69   
  0046                 278     SKYWALKER_20A_MAIN 			EQU 70
  0047                 279     SKYWALKER_20A_TAIL 			EQU 71   
  0048                 280     SKYWALKER_20A_MULTI 		EQU 72   
  0049                 281     SKYWALKER_40A_MAIN 			EQU 73
  004A                 282     SKYWALKER_40A_TAIL 			EQU 74   
  004B                 283     SKYWALKER_40A_MULTI 		EQU 75   
  004C                 284     HIMODEL_COOL_22A_MAIN 		EQU 76
  004D                 285     HIMODEL_COOL_22A_TAIL 		EQU 77   
  004E                 286     HIMODEL_COOL_22A_MULTI 		EQU 78   
  004F                 287     HIMODEL_COOL_33A_MAIN 		EQU 79
  0050                 288     HIMODEL_COOL_33A_TAIL 		EQU 80   
  0051                 289     HIMODEL_COOL_33A_MULTI 		EQU 81   
  0052                 290     HIMODEL_COOL_41A_MAIN 		EQU 82
  0053                 291     HIMODEL_COOL_41A_TAIL 		EQU 83   
  0054                 292     HIMODEL_COOL_41A_MULTI 		EQU 84   
  0055                 293     RCTIMER_6A_MAIN 			EQU 85   
  0056                 294     RCTIMER_6A_TAIL 			EQU 86   
  0057                 295     RCTIMER_6A_MULTI 			EQU 87   
  0058                 296     ALIGN_RCE_BL15X_MAIN		EQU 88   
  0059                 297     ALIGN_RCE_BL15X_TAIL 		EQU 89   
  005A                 298     ALIGN_RCE_BL15X_MULTI 		EQU 90   
  005B                 299     ALIGN_RCE_BL15P_MAIN		EQU 91   
  005C                 300     ALIGN_RCE_BL15P_TAIL 		EQU 92   
  005D                 301     ALIGN_RCE_BL15P_MULTI 		EQU 93   
  005E                 302     ALIGN_RCE_BL35X_MAIN		EQU 94   
  005F                 303     ALIGN_RCE_BL35X_TAIL 		EQU 95   
  0060                 304     ALIGN_RCE_BL35X_MULTI 		EQU 96   
  0061                 305     ALIGN_RCE_BL35P_MAIN		EQU 97   
  0062                 306     ALIGN_RCE_BL35P_TAIL 		EQU 98   
  0063                 307     ALIGN_RCE_BL35P_MULTI 		EQU 99   
  0064                 308     GAUI_GE_183_18A_MAIN		EQU 100   
  0065                 309     GAUI_GE_183_18A_TAIL 		EQU 101  
  0066                 310     GAUI_GE_183_18A_MULTI 		EQU 102  
  0067                 311     H_KING_10A_MAIN			EQU 103   
  0068                 312     H_KING_10A_TAIL 			EQU 104  
  0069                 313     H_KING_10A_MULTI 			EQU 105  
  006A                 314     H_KING_20A_MAIN			EQU 106   
  006B                 315     H_KING_20A_TAIL 			EQU 107  
  006C                 316     H_KING_20A_MULTI 			EQU 108  
  006D                 317     H_KING_35A_MAIN			EQU 109   
  006E                 318     H_KING_35A_TAIL 			EQU 110 
  006F                 319     H_KING_35A_MULTI 			EQU 111  
  0070                 320     H_KING_50A_MAIN			EQU 112   
  0071                 321     H_KING_50A_TAIL 			EQU 113  
  0072                 322     H_KING_50A_MULTI 			EQU 114  
  0073                 323     POLARIS_THUNDER_12A_MAIN		EQU 115   
  0074                 324     POLARIS_THUNDER_12A_TAIL 	EQU 116  
  0075                 325     POLARIS_THUNDER_12A_MULTI 	EQU 117  
  0076                 326     POLARIS_THUNDER_20A_MAIN		EQU 118   
  0077                 327     POLARIS_THUNDER_20A_TAIL 	EQU 119  
  0078                 328     POLARIS_THUNDER_20A_MULTI 	EQU 120  
  0079                 329     POLARIS_THUNDER_30A_MAIN		EQU 121   
  007A                 330     POLARIS_THUNDER_30A_TAIL 	EQU 122  
  007B                 331     POLARIS_THUNDER_30A_MULTI 	EQU 123  
  007C                 332     POLARIS_THUNDER_40A_MAIN		EQU 124   
  007D                 333     POLARIS_THUNDER_40A_TAIL 	EQU 125  
  007E                 334     POLARIS_THUNDER_40A_MULTI 	EQU 126  
  007F                 335     POLARIS_THUNDER_60A_MAIN		EQU 127   
  0080                 336     POLARIS_THUNDER_60A_TAIL 	EQU 128  
  0081                 337     POLARIS_THUNDER_60A_MULTI 	EQU 129  
  0082                 338     POLARIS_THUNDER_80A_MAIN		EQU 130   
  0083                 339     POLARIS_THUNDER_80A_TAIL 	EQU 131  
  0084                 340     POLARIS_THUNDER_80A_MULTI 	EQU 132  
  0085                 341     POLARIS_THUNDER_100A_MAIN	EQU 133   
  0086                 342     POLARIS_THUNDER_100A_TAIL 	EQU 134  
  0087                 343     POLARIS_THUNDER_100A_MULTI 	EQU 135  
  0088                 344     PLATINUM_PRO_30A_MAIN		EQU 136   
  0089                 345     PLATINUM_PRO_30A_TAIL 		EQU 137  
  008A                 346     PLATINUM_PRO_30A_MULTI 		EQU 138  
                       347     
                       348     ;**** **** **** **** ****
                       349     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       350     ;BESC EQU XP_3A_Main
                       351     ;BESC EQU XP_3A_Tail
                       352     ;BESC EQU XP_3A_Multi
                       353     ;BESC EQU XP_7A_Main
                       354     ;BESC EQU XP_7A_Tail
                       355     ;BESC EQU XP_7A_Multi 
                       356     ;BESC EQU XP_7A_Fast_Main
                       357     ;BESC EQU XP_7A_Fast_Tail
                       358     ;BESC EQU XP_7A_Fast_Multi
                       359     ;BESC EQU XP_12A_Main 
                       360     ;BESC EQU XP_12A_Tail 
                       361     ;BESC EQU XP_12A_Multi
                       362     ;BESC EQU XP_18A_Main 
                       363     ;BESC EQU XP_18A_Tail 
                       364     ;BESC EQU XP_18A_Multi
                       365     ;BESC EQU XP_25A_Main 
                       366     ;BESC EQU XP_25A_Tail 
                       367     ;BESC EQU XP_25A_Multi
                       368     ;BESC EQU DP_3A_Main 						
                       369     ;BESC EQU DP_3A_Tail
                       370     ;BESC EQU DP_3A_Multi
                       371     ;BESC EQU Supermicro_3p5A_Main
                       372     ;BESC EQU Supermicro_3p5A_Tail
                       373     ;BESC EQU Supermicro_3p5A_Multi
                       374     ;BESC EQU Turnigy_Plush_6A_Main 
                       375     ;BESC EQU Turnigy_Plush_6A_Tail 
                       376     ;BESC EQU Turnigy_Plush_6A_Multi
                       377     ;BESC EQU Turnigy_Plush_10A_Main 
                       378     ;BESC EQU Turnigy_Plush_10A_Tail 
                       379     ;BESC EQU Turnigy_Plush_10A_Multi
                       380     ;BESC EQU Turnigy_Plush_12A_Main 
                       381     ;BESC EQU Turnigy_Plush_12A_Tail 
                       382     ;BESC EQU Turnigy_Plush_12A_Multi
                       383     ;BESC EQU Turnigy_Plush_18A_Main 
                       384     ;BESC EQU Turnigy_Plush_18A_Tail 
                       385     ;BESC EQU Turnigy_Plush_18A_Multi
                       386     ;BESC EQU Turnigy_Plush_25A_Main 
                       387     ;BESC EQU Turnigy_Plush_25A_Tail 
                       388     ;BESC EQU Turnigy_Plush_25A_Multi
                       389     ;BESC EQU Turnigy_Plush_30A_Main 
                       390     ;BESC EQU Turnigy_Plush_30A_Tail 
                       391     ;BESC EQU Turnigy_Plush_30A_Multi
                       392     ;BESC EQU Turnigy_Plush_40A_Main
                       393     ;BESC EQU Turnigy_Plush_40A_Tail 
                       394     ;BESC EQU Turnigy_Plush_40A_Multi
                       395     ;BESC EQU Turnigy_Plush_60A_Main
                       396     ;BESC EQU Turnigy_Plush_60A_Tail 
                       397     ;BESC EQU Turnigy_Plush_60A_Multi
                       398     ;BESC EQU Turnigy_Plush_80A_Main
                       399     ;BESC EQU Turnigy_Plush_80A_Tail 
                       400     ;BESC EQU Turnigy_Plush_80A_Multi
                       401     ;BESC EQU Turnigy_AE_20A_Main 
                       402     ;BESC EQU Turnigy_AE_20A_Tail 
                       403     ;BESC EQU Turnigy_AE_20A_Multi
                       404     ;BESC EQU Turnigy_AE_25A_Main 
                       405     ;BESC EQU Turnigy_AE_25A_Tail 
                       406     ;BESC EQU Turnigy_AE_25A_Multi
                       407     ;BESC EQU Turnigy_AE_30A_Main 
                       408     ;BESC EQU Turnigy_AE_30A_Tail 
                       409     ;BESC EQU Turnigy_AE_30A_Multi
                       410     ;BESC EQU Turnigy_AE_45A_Main
                       411     ;BESC EQU Turnigy_AE_45A_Tail 
                       412     ;BESC EQU Turnigy_AE_45A_Multi
                       413     ;BESC EQU Turnigy_KForce_40A_Main
                       414     ;BESC EQU Turnigy_KForce_40A_Tail 
                       415     ;BESC EQU Turnigy_KForce_40A_Multi
                       416     ;BESC EQU Turnigy_KForce_120A_HV_Main
                       417     ;BESC EQU Turnigy_KForce_120A_HV_Tail 
                       418     ;BESC EQU Turnigy_KForce_120A_HV_Multi
                       419     ;BESC EQU Skywalker_20A_Main
                       420     ;BESC EQU Skywalker_20A_Tail 
                       421     ;BESC EQU Skywalker_20A_Multi
                       422     ;BESC EQU Skywalker_40A_Main 
                       423     ;BESC EQU Skywalker_40A_Tail 
                       424     ;BESC EQU Skywalker_40A_Multi
                       425     ;BESC EQU HiModel_Cool_22A_Main
                       426     ;BESC EQU HiModel_Cool_22A_Tail
                       427     ;BESC EQU HiModel_Cool_22A_Multi
                       428     ;BESC EQU HiModel_Cool_33A_Main
                       429     ;BESC EQU HiModel_Cool_33A_Tail
                       430     ;BESC EQU HiModel_Cool_33A_Multi
                       431     ;BESC EQU HiModel_Cool_41A_Main
                       432     ;BESC EQU HiModel_Cool_41A_Tail
                       433     ;BESC EQU HiModel_Cool_41A_Multi
                       434     ;BESC EQU RCTimer_6A_Main
                       435     ;BESC EQU RCTimer_6A_Tail
                       436     ;BESC EQU RCTimer_6A_Multi
                       437     ;BESC EQU Align_RCE_BL15X_Main 
                       438     ;BESC EQU Align_RCE_BL15X_Tail
                       439     ;BESC EQU Align_RCE_BL15X_Multi
                       440     ;BESC EQU Align_RCE_BL15P_Main
                       441     ;BESC EQU Align_RCE_BL15P_Tail
                       442     ;BESC EQU Align_RCE_BL15P_Multi
                       443     ;BESC EQU Align_RCE_BL35X_Main 
                       444     ;BESC EQU Align_RCE_BL35X_Tail
                       445     ;BESC EQU Align_RCE_BL35X_Multi
                       446     ;BESC EQU Align_RCE_BL35P_Main
                       447     ;BESC EQU Align_RCE_BL35P_Tail
                       448     ;BESC EQU Align_RCE_BL35P_Multi
                       449     ;BESC EQU Gaui_GE_183_18A_Main
                       450     ;BESC EQU Gaui_GE_183_18A_Tail
                       451     ;BESC EQU Gaui_GE_183_18A_Multi
                       452     ;BESC EQU H_King_10A_Main
                       453     ;BESC EQU H_King_10A_Tail
                       454     ;BESC EQU H_King_10A_Multi
                       455     ;BESC EQU H_King_20A_Main
                       456     ;BESC EQU H_King_20A_Tail
                       457     ;BESC EQU H_King_20A_Multi
                       458     ;BESC EQU H_King_35A_Main
                       459     ;BESC EQU H_King_35A_Tail
                       460     ;BESC EQU H_King_35A_Multi
                       461     ;BESC EQU H_King_50A_Main
                       462     ;BESC EQU H_King_50A_Tail
                       463     ;BESC EQU H_King_50A_Multi
                       464     ;BESC EQU Polaris_Thunder_12A_Main
                       465     ;BESC EQU Polaris_Thunder_12A_Tail
                       466     ;BESC EQU Polaris_Thunder_12A_Multi
                       467     ;BESC EQU Polaris_Thunder_20A_Main
                       468     ;BESC EQU Polaris_Thunder_20A_Tail
                       469     ;BESC EQU Polaris_Thunder_20A_Multi
                       470     ;BESC EQU Polaris_Thunder_30A_Main
                       471     ;BESC EQU Polaris_Thunder_30A_Tail
                       472     ;BESC EQU Polaris_Thunder_30A_Multi
                       473     ;BESC EQU Polaris_Thunder_40A_Main
                       474     ;BESC EQU Polaris_Thunder_40A_Tail
                       475     ;BESC EQU Polaris_Thunder_40A_Multi
                       476     ;BESC EQU Polaris_Thunder_60A_Main
                       477     ;BESC EQU Polaris_Thunder_60A_Tail
                       478     ;BESC EQU Polaris_Thunder_60A_Multi
                       479     ;BESC EQU Polaris_Thunder_80A_Main
                       480     ;BESC EQU Polaris_Thunder_80A_Tail
                       481     ;BESC EQU Polaris_Thunder_80A_Multi
                       482     ;BESC EQU Polaris_Thunder_100A_Main
                       483     ;BESC EQU Polaris_Thunder_100A_Tail
                       484     ;BESC EQU Polaris_Thunder_100A_Multi
                       485     ;BESC EQU Platinum_Pro_30A_Main
                       486     ;BESC EQU Platinum_Pro_30A_Tail
                       487     ;BESC EQU Platinum_Pro_30A_Multi
                       488     
                       489     
                       490     ;**** **** **** **** ****
                       491     ; ESC selection statements
                       492     IF BESC == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       496     
                       497     IF BESC == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       501     
                       502     IF BESC == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       506     
                       507     IF BESC == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       511     
                       512     IF BESC == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       516     
                       517     IF BESC == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       521     
                       522     IF BESC == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       526     
                       527     IF BESC == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       531     
                       532     IF BESC == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       536     
                       537     IF BESC == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       541     
                       542     IF BESC == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       546     
                       547     IF BESC == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       551     
                       552     IF BESC == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       556     
                       557     IF BESC == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       561     
                       562     IF BESC == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       566     
                       567     IF BESC == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       571     
                       572     IF BESC == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       576     
                       577     IF BESC == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       581     
                       582     IF BESC == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       586     
                       587     IF BESC == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       591     
                       592     IF BESC == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       596     
                       597     IF BESC == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       601     
                       602     IF BESC == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       606     
                       607     IF BESC == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       611     
                       612     IF BESC == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       616     
                       617     IF BESC == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       621     
                       622     IF BESC == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       626     
                       627     IF BESC == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       631     
                       632     IF BESC == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       636     
                       637     IF BESC == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       641     
                       642     IF BESC == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       646     
                       647     IF BESC == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       651     
                       652     IF BESC == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       656     
                       657     IF BESC == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       661     
                       662     IF BESC == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       666     
                       667     IF BESC == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       671     
                       672     IF BESC == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       676     
                       677     IF BESC == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       681     
                       682     IF BESC == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       686     
                       687     IF BESC == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       691     
                       692     IF BESC == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       696     
                       697     IF BESC == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       701     
                       702     IF BESC == TURNIGY_PLUSH_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       706     
                       707     IF BESC == TURNIGY_PLUSH_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       711     
                       712     IF BESC == TURNIGY_PLUSH_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_40A.INC)	; Select Turnigy Plush 40A pinout
                               ENDIF
                       716     
                       717     IF BESC == TURNIGY_PLUSH_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       721     
                       722     IF BESC == TURNIGY_PLUSH_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       726     
                       727     IF BESC == TURNIGY_PLUSH_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_60A.INC)	; Select Turnigy Plush 60A pinout
                               ENDIF
                       731     
                       732     IF BESC == TURNIGY_PLUSH_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       736     
                       737     IF BESC == TURNIGY_PLUSH_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       741     
                       742     IF BESC == TURNIGY_PLUSH_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_80A.INC)	; Select Turnigy Plush 80A pinout
                               ENDIF
                       746     
                       747     IF BESC == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                       751     
                       752     IF BESC == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                       756     
                       757     IF BESC == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                       761     
                       762     IF BESC == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                       766     
                       767     IF BESC == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                       771     
                       772     IF BESC == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                       776     
                       777     IF BESC == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                       781     
                       782     IF BESC == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                       786     
                       787     IF BESC == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                       791     
                       792     IF BESC == TURNIGY_AE_45A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                       796     
                       797     IF BESC == TURNIGY_AE_45A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                       801     
                       802     IF BESC == TURNIGY_AE_45A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_45A.INC)		; Select Turnigy AE-45A pinout
                               ENDIF
                       806     
                       807     IF BESC == TURNIGY_KFORCE_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       811     
                       812     IF BESC == TURNIGY_KFORCE_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       816     
                       817     IF BESC == TURNIGY_KFORCE_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_40A.INC)	; Select Turnigy KForce 40A pinout
                               ENDIF
                       821     
                       822     IF BESC == TURNIGY_KFORCE_120A_HV_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                       826     
                       827     IF BESC == TURNIGY_KFORCE_120A_HV_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                       831     
                       832     IF BESC == TURNIGY_KFORCE_120A_HV_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_KFORCE_120A_HV.INC)	; Select Turnigy KForce 120A HV pinout
                               ENDIF
                       836     
                       837     IF BESC == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       841     
                       842     IF BESC == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       846     
                       847     IF BESC == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       851     
                       852     IF BESC == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       856     
                       857     IF BESC == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       861     
                       862     IF BESC == SKYWALKER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       866     
                       867     IF BESC == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                       871     
                       872     IF BESC == HIMODEL_COOL_22A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                       876     
                       877     IF BESC == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                       881     
                       882     IF BESC == HIMODEL_COOL_33A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                       886     
                       887     IF BESC == HIMODEL_COOL_33A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                       891     
                       892     IF BESC == HIMODEL_COOL_33A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_33A.INC)	; Select HiModel Cool 33A pinout
                               ENDIF
                       896     
                       897     IF BESC == HIMODEL_COOL_41A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                       901     
                       902     IF BESC == HIMODEL_COOL_41A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                       906     
                       907     IF BESC == HIMODEL_COOL_41A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_41A.INC)	; Select HiModel Cool 41A pinout
                               ENDIF
                       911     
                       912     IF BESC == RCTIMER_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                       916     
                       917     IF BESC == RCTIMER_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                       921     
                       922     IF BESC == RCTIMER_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (RCTIMER_6A.INC)		; Select RC Timer 6A pinout
                               ENDIF
                       926     
                       927     IF BESC == ALIGN_RCE_BL15X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                       931     
                       932     IF BESC == ALIGN_RCE_BL15X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                       936     
                       937     IF BESC == ALIGN_RCE_BL15X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15X.INC)	; Select Align RCE-BL15X pinout
                               ENDIF
                       941     
                       942     IF BESC == ALIGN_RCE_BL15P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                       946     
                       947     IF BESC == ALIGN_RCE_BL15P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                       951     
                       952     IF BESC == ALIGN_RCE_BL15P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL15P.INC)	; Select Align RCE-BL15P pinout
                               ENDIF
                       956     
                       957     IF BESC == ALIGN_RCE_BL35X_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                       961     
                       962     IF BESC == ALIGN_RCE_BL35X_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                       966     
                       967     IF BESC == ALIGN_RCE_BL35X_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35X.INC)	; Select Align RCE-BL35X pinout
                               ENDIF
                       971     
                       972     IF BESC == ALIGN_RCE_BL35P_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                       976     
                       977     IF BESC == ALIGN_RCE_BL35P_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                       981     
                       982     IF BESC == ALIGN_RCE_BL35P_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (ALIGN_RCE_BL35P.INC)	; Select Align RCE-BL35P pinout
                               ENDIF
                       986     
                       987     IF BESC == GAUI_GE_183_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                       991     
                       992     IF BESC == GAUI_GE_183_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                       996     
                       997     IF BESC == GAUI_GE_183_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (GAUI_GE_183_18A.INC)	; Select Gaui GE-183 18A pinout
                               ENDIF
                      1001     
                      1002     IF BESC == H_KING_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1006     
                      1007     IF BESC == H_KING_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1011     
                      1012     IF BESC == H_KING_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_10A.INC)		; Select H-King 10A pinout
                               ENDIF
                      1016     
                      1017     IF BESC == H_KING_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1021     
                      1022     IF BESC == H_KING_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1026     
                      1027     IF BESC == H_KING_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_20A.INC)		; Select H-King 20A pinout
                               ENDIF
                      1031     
                      1032     IF BESC == H_KING_35A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1036     
                      1037     IF BESC == H_KING_35A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1041     
                      1042     IF BESC == H_KING_35A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_35A.INC)		; Select H-King 35A pinout
                               ENDIF
                      1046     
                      1047     IF BESC == H_KING_50A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1051     
                      1052     IF BESC == H_KING_50A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1056     
                      1057     IF BESC == H_KING_50A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (H_KING_50A.INC)		; Select H-King 50A pinout
                               ENDIF
                      1061     
                      1062     IF BESC == POLARIS_THUNDER_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1066     
                      1067     IF BESC == POLARIS_THUNDER_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1071     
                      1072     IF BESC == POLARIS_THUNDER_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_12A.INC)	; Select Polaris Thunder 12A pinout
                               ENDIF
                      1076     
                      1077     IF BESC == POLARIS_THUNDER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1081     
                      1082     IF BESC == POLARIS_THUNDER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1086     
                      1087     IF BESC == POLARIS_THUNDER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_20A.INC)	; Select Polaris Thunder 20A pinout
                               ENDIF
                      1091     
                      1092     IF BESC == POLARIS_THUNDER_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1096     
                      1097     IF BESC == POLARIS_THUNDER_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1101     
                      1102     IF BESC == POLARIS_THUNDER_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_30A.INC)	; Select Polaris Thunder 30A pinout
                               ENDIF
                      1106     
                      1107     IF BESC == POLARIS_THUNDER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1111     
                      1112     IF BESC == POLARIS_THUNDER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1116     
                      1117     IF BESC == POLARIS_THUNDER_40A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_40A.INC)	; Select Polaris Thunder 40A pinout
                               ENDIF
                      1121     
                      1122     IF BESC == POLARIS_THUNDER_60A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1126     
                      1127     IF BESC == POLARIS_THUNDER_60A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1131     
                      1132     IF BESC == POLARIS_THUNDER_60A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_60A.INC)	; Select Polaris Thunder 60A pinout
                               ENDIF
                      1136     
                      1137     IF BESC == POLARIS_THUNDER_80A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1141     
                      1142     IF BESC == POLARIS_THUNDER_80A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1146     
                      1147     IF BESC == POLARIS_THUNDER_80A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_80A.INC)	; Select Polaris Thunder 80A pinout
                               ENDIF
                      1151     
                      1152     IF BESC == POLARIS_THUNDER_100A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1156     
                      1157     IF BESC == POLARIS_THUNDER_100A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1161     
                      1162     IF BESC == POLARIS_THUNDER_100A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (POLARIS_THUNDER_100A.INC); Select Polaris Thunder 100A pinout
                               ENDIF
                      1166     
                      1167     IF BESC == PLATINUM_PRO_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1171     
                      1172     IF BESC == PLATINUM_PRO_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                               ENDIF
                      1176     
                      1177     IF BESC == PLATINUM_PRO_30A_MULTI
  0002                1178     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                      1179     $INCLUDE (PLATINUM_PRO_30A.INC)	; Select Platinum Pro 30A pinout
                      1786     ENDIF
                      1787     
                      1788     ;**** **** **** **** ****
                      1789     ; TX programming defaults
                      1790     ;
                      1791     ; Parameter dependencies:
                      1792     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      1793     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop mode is on for multi)
                      1794     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                      1795     ; - Damping force is only used if DampedLight or Damped is selected
                      1796     ;
                      1797     ; Main
  0007                1798     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                1799     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                1800     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 	; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                1801     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 	; 1=High		2=Low
  0004                1802     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 4 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0003                1803     DEFAULT_PGM_MAIN_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0001                1804     DEFAULT_PGM_MAIN_STARTUP_ACCEL	EQU 1 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                1805     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                1806     DEFAULT_PGM_MAIN_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0001                1807     DEFAULT_PGM_MAIN_DAMPING_FORCE	EQU 1 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
  0002                1808     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 	; 1=High 		2=Low		3=DampedLight
  0001                1809     DEFAULT_PGM_MAIN_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=15/0		3=15/7.5		4=7.5/7.5  	5=7.5/15  (degrees blind advance / power off)
  0001                1810     DEFAULT_PGM_MAIN_DIRECTION_REV	EQU 1 	; 1=Normal 	2=Reversed
  0001                1811     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00B4                1812     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                1813     DEFAULT_PGM_MAIN_REARM_START		EQU 0 	; 1=Enabled 	0=Disabled
  0078                1814     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                1815     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0004                1816     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 4 	; 1=30s		2=1m			3=2m			4=3m			5=Infinite
                      1817     ; Tail
  0003                1818     DEFAULT_PGM_TAIL_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                1819     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                1820     DEFAULT_PGM_TAIL_STARTUP_RPM		EQU 3 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                1821     DEFAULT_PGM_TAIL_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                1822     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                1823     DEFAULT_PGM_TAIL_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0005                1824     DEFAULT_PGM_TAIL_DAMPING_FORCE	EQU 5 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                      1825     IF DAMPED_MODE_ENABLE == 1
  0004                1826     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 4 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                      1827     ELSE
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0001                1830     DEFAULT_PGM_TAIL_DEMAG_COMP 		EQU 1 	; 1=Disabled	2=15/0		3=15/7.5		4=7.5/7.5  	5=7.5/15  (degrees blind advance / power off)
  0001                1831     DEFAULT_PGM_TAIL_DIRECTION_REV	EQU 1 	; 1=Normal 	2=Reversed
  0001                1832     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 	; 1=Positive 	2=Negative
  00FA                1833     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                1834     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0004                1835     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 4 	; 1=30s		2=1m			3=2m			4=3m			5=Infinite
                      1836     ; Multi
  0009                1837     DEFAULT_PGM_MULTI_P_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0009                1838     DEFAULT_PGM_MULTI_I_GAIN 		EQU 9 	; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004                1839     DEFAULT_PGM_MULTI_GOVERNOR_MODE 	EQU 4 	; 1=HiRange	2=MidRange	3=LoRange		4=Off
  0003                1840     DEFAULT_PGM_MULTI_GAIN 			EQU 3 	; 1=0.75 		2=0.88 		3=1.00 		4=1.12 		5=1.25
  0001                1841     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 1 	; 1=Off		2=3.0V/c		3=3.1V/c		4=3.2V/c		5=3.3V/c	6=3.4V/c
  0001                1842     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 	; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                1843     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 	; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0003                1844     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 	; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                1845     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 13	; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0006                1846     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 6 	; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High	6=Highest
                      1847     IF DAMPED_MODE_ENABLE == 1
  0001                1848     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low 		3=DampedLight  4=Damped 	
                      1849     ELSE
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 	; 1=High 		2=Low		3=DampedLight
                               ENDIF
  0002                1852     DEFAULT_PGM_MULTI_DEMAG_COMP 		EQU 2 	; 1=Disabled	2=15/0		3=15/7.5		4=7.5/7.5  	5=7.5/15  (degrees blind advance / power off)
  0001                1853     DEFAULT_PGM_MULTI_DIRECTION_REV	EQU 1 	; 1=Normal 	2=Reversed
  0001                1854     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 	; 1=Positive 	2=Negative
  0028                1855     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0050                1856     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0004                1857     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 4 	; 1=30s		2=1m			3=2m			4=3m			5=Infinite
                      1858     ; Common
  0001                1859     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 1 	; 1=Enabled 	0=Disabled
  0025                1860     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 37	; 4*37+1000=1148
  00D0                1861     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 208	; 4*208+1000=1832
  0000                1862     DEFAULT_PGM_BEC_VOLTAGE_HIGH		EQU 0	; 0=Low		1= High
                      1863     
                      1864     ;**** **** **** **** ****
                      1865     ; Constant definitions for main
                      1866     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	80 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      1888     ; Constant definitions for tail
                      1889     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                               
                               COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                               
                               TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      1910     ; Constant definitions for multi
                      1911     IF MODE == 2
                      1912     
  0001                1913     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                      1914     
  000A                1915     RCP_TIMEOUT_PPM	EQU	10	; Number of timer2H overflows (about 32ms) before considering rc pulse lost
  0018                1916     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                1917     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                1918     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                1919     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                1920     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                1921     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                1922     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      1923     
  0032                1924     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                1925     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                      1926     
  0008                1927     COMM_TIME_RED		EQU 	8	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0001                1928     COMM_TIME_MIN		EQU 	1	; Minimum time (in us) for commutation wait
                      1929     
  0008                1930     TEMP_CHECK_RATE	EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      1931     
                      1932     ENDIF
                      1933     
                      1934     ;**** **** **** **** ****
                      1935     ; Temporary register definitions
  REG                 1936     TEMP1		EQU	R0
  REG                 1937     TEMP2		EQU	R1
  REG                 1938     TEMP3		EQU	R2
  REG                 1939     TEMP4		EQU	R3
  REG                 1940     TEMP5		EQU	R4
  REG                 1941     TEMP6		EQU	R5
  REG                 1942     TEMP7		EQU	R6
  REG                 1943     TEMP8		EQU	R7
                      1944     
                      1945     ;**** **** **** **** ****
                      1946     ; Register definitions
------                1947     DSEG AT 20H					; Variables segment 
                      1948     
0020                  1949     BIT_ACCESS: 				DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                  1950     BIT_ACCESS_INT: 			DS	1		; Variable at bit accessible address (for interrupts)
                      1951     
0022                  1952     REQUESTED_PWM: 				DS	1		; Requested pwm (from RC pulse value)
0023                  1953     GOVERNOR_REQ_PWM: 			DS	1		; Governor requested pwm (sets governor target)
0024                  1954     CURRENT_PWM: 				DS	1		; Current pwm
0025                  1955     CURRENT_PWM_LIMITED: 		DS	1		; Current pwm that is limited (applied to the motor output)
0026                  1956     RCP_PREV_EDGE_L: 			DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0027                  1957     RCP_PREV_EDGE_H: 			DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0028                  1958     RCP_TIMEOUT_CNT: 			DS	1		; RC pulse timeout counter (decrementing) 
0029                  1959     RCP_SKIP_CNT: 				DS	1		; RC pulse skip counter (decrementing) 
002A                  1960     RCP_EDGE_CNT: 				DS	1		; RC pulse edge counter 
                      1961     
002B                  1962     FLAGS0: 					DS	1    	; State flags. Reset upon init_start
  0000                1963     T3_PENDING				EQU 	0		; Timer3 pending flag
  0001                1964     RCP_MEAS_PWM_FREQ			EQU	1		; Measure RC pulse pwm frequency
  0002                1965     PWM_ON					EQU	2		; Set in on part of pwm cycle
  0003                1966     DEMAG_DETECTED				EQU 	3		; Set when excessive demag time is detected
  0004                1967     DEMAG_CUT_POWER			EQU 	4		; Set when demag compensation cuts power
                      1968     ;						EQU 	5
                      1969     ;						EQU 	6
                      1970     ;						EQU 	7
                      1971     
002C                  1972     FLAGS1: 					DS	1    	; State flags. Reset upon init_start 
  0000                1973     MOTOR_SPINNING				EQU	0		; Set when in motor is spinning
  0001                1974     SETTLE_PHASE				EQU 	1		; Set when in motor start settling phase
  0002                1975     STEPPER_PHASE				EQU	2		; Set when in motor start stepper motor phase
  0003                1976     DIRECT_STARTUP_PHASE		EQU 	3		; Set when in direct startup phase
  0004                1977     INITIAL_RUN_PHASE			EQU	4		; Set when in initial run phase, before synchronized run is achieved
                      1978     ;						EQU 	5	
                      1979     ;						EQU 	6	
                      1980     ;						EQU 	7
                      1981     
002D                  1982     FLAGS2: 					DS	1		; State flags. NOT reset upon init_start
  0000                1983     RCP_UPDATED				EQU 	0		; New RC pulse length value available
  0001                1984     RCP_EDGE_NO				EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                1985     PGM_PWMOFF_DAMPED			EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                1986     PGM_PWMOFF_DAMPED_FULL		EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                1987     PGM_PWMOFF_DAMPED_LIGHT		EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                1988     PGM_PWM_HIGH_FREQ			EQU	5		; Progremmed pwm high frequency
  0006                1989     CURR_PWMOFF_DAMPED			EQU	6		; Currently running pwm off cycle is damped
  0007                1990     CURR_PWMOFF_COMP_ABLE		EQU	7		; Currently running pwm off cycle is usable for comparator
                      1991     
002E                  1992     FLAGS3: 					DS	1		; State flags. NOT reset upon init_start
  0000                1993     RCP_PWM_FREQ_1KHZ			EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                1994     RCP_PWM_FREQ_2KHZ			EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                1995     RCP_PWM_FREQ_4KHZ			EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                1996     RCP_PWM_FREQ_8KHZ			EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                1997     RCP_PWM_FREQ_12KHZ			EQU 	4		; RC pulse pwm frequency is 12kHz
  0005                1998     PGM_DIR_REV				EQU 	5		; Programmed direction. 0=normal, 1=reversed
  0006                1999     PGM_RCP_PWM_POL			EQU	6		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0007                2000     FULL_THROTTLE_RANGE			EQU 	7		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      2001     
                      2002     ;**** **** **** **** ****
                      2003     ; RAM definitions
------                2004     DSEG AT 30H						; Ram data segment, direct addressing
                      2005     
0030                  2006     INITIAL_ARM: 				DS	1		; Variable that is set during the first arm sequence after power on
                      2007     
0031                  2008     POWER_ON_WAIT_CNT_L:  		DS	1		; Power on wait counter (lo byte)
0032                  2009     POWER_ON_WAIT_CNT_H:  		DS	1		; Power on wait counter (hi byte)
                      2010     
0033                  2011     STEPPER_STEP_BEG_L: 			DS	1		; Stepper phase step time at the beginning (lo byte)
0034                  2012     STEPPER_STEP_BEG_H: 			DS	1		; Stepper phase step time at the beginning (hi byte)
0035                  2013     STEPPER_STEP_END_L: 			DS	1		; Stepper phase step time at the end (lo byte)
0036                  2014     STEPPER_STEP_END_H: 			DS	1		; Stepper phase step time at the end (hi byte)
0037                  2015     STARTUP_ROT_CNT: 			DS	1		; Startup phase rotations counter
0038                  2016     DIRECT_STARTUP_OK_CNT: 		DS	1		; Direct startup phase ok comparator waits counter (incrementing)
                      2017     
0039                  2018     PREV_COMM_L: 				DS	1		; Previous commutation timer3 timestamp (lo byte)
003A                  2019     PREV_COMM_H: 				DS	1		; Previous commutation timer3 timestamp (hi byte)
003B                  2020     COMM_PERIOD4X_L: 			DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003C                  2021     COMM_PERIOD4X_H: 			DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003D                  2022     COMM_PHASE: 				DS	1		; Current commutation phase
003E                  2023     COMP_WAIT_READS:  			DS	1		; Comparator wait comparator reads
                      2024     
003F                  2025     GOV_TARGET_L: 				DS	1		; Governor target (lo byte)
0040                  2026     GOV_TARGET_H: 				DS	1		; Governor target (hi byte)
0041                  2027     GOV_INTEGRAL_L: 			DS	1		; Governor integral error (lo byte)
0042                  2028     GOV_INTEGRAL_H: 			DS	1		; Governor integral error (hi byte)
0043                  2029     GOV_INTEGRAL_X: 			DS	1		; Governor integral error (ex byte)
0044                  2030     GOV_PROPORTIONAL_L: 			DS	1		; Governor proportional error (lo byte)
0045                  2031     GOV_PROPORTIONAL_H: 			DS	1		; Governor proportional error (hi byte)
0046                  2032     GOV_PROP_PWM: 				DS	1		; Governor calculated new pwm based upon proportional error
0047                  2033     GOV_ARM_TARGET: 			DS	1		; Governor arm target value
0048                  2034     GOV_ACTIVE: 				DS	1		; Governor active (enabled when speed is above minimum)
                      2035     
0049                  2036     WT_ADVANCE_L: 				DS	1		; Timer3 counts for commutation advance timing (lo byte)
004A                  2037     WT_ADVANCE_H: 				DS	1		; Timer3 counts for commutation advance timing (hi byte)
004B                  2038     WT_ZC_SCAN_L: 				DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004C                  2039     WT_ZC_SCAN_H: 				DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004D                  2040     WT_COMM_L: 				DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004E                  2041     WT_COMM_H: 				DS	1		; Timer3 counts from zero cross to commutation (hi byte)
004F                  2042     WT_STEPPER_STEP_L: 			DS	1		; Timer3 counts for stepper step (lo byte)
0050                  2043     WT_STEPPER_STEP_H: 			DS	1		; Timer3 counts for stepper step (hi byte)
                      2044     
0051                  2045     RCP_PREPREV_EDGE_L: 			DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0052                  2046     RCP_PREPREV_EDGE_H: 			DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0053                  2047     RCP_EDGE_L: 				DS	1		; RC pulse edge pca timestamp (lo byte)
0054                  2048     RCP_EDGE_H: 				DS	1		; RC pulse edge pca timestamp (hi byte)
0055                  2049     RCP_PREV_PERIOD_L: 			DS	1		; RC pulse previous period (lo byte)
0056                  2050     RCP_PREV_PERIOD_H: 			DS	1		; RC pulse previous period (hi byte)
0057                  2051     RCP_PERIOD_DIFF_ACCEPTED: 	DS	1		; RC pulse period difference acceptable
0058                  2052     NEW_RCP: 					DS	1		; New RC pulse value in pca counts
0059                  2053     PREV_RCP_PWM_FREQ: 			DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005A                  2054     CURR_RCP_PWM_FREQ: 			DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005B                  2055     RCP_STOP_CNT: 				DS	1		; Counter for RC pulses below stop value 
                      2056     
005C                  2057     PWM_LIMIT: 				DS	1		; Maximum allowed pwm 
005D                  2058     PWM_LIMIT_SPOOLUP: 			DS	1		; Maximum allowed pwm during spoolup of main
005E                  2059     PWM_SPOOLUP_BEG: 			DS	1		; Pwm to begin main spoolup with
005F                  2060     PWM_MOTOR_IDLE: 			DS	1		; Motor idle speed pwm
0060                  2061     PWM_ON_CNT: 				DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0061                  2062     PWM_OFF_CNT: 				DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                      2063     
0062                  2064     SPOOLUP_LIMIT_CNT: 			DS	1		; Interrupt count for spoolup limit
0063                  2065     SPOOLUP_LIMIT_SKIP: 			DS	1		; Interrupt skips for spoolup limit increment (1=no skips, 2=skip one etc)
                      2066     
0064                  2067     DAMPING_PERIOD: 			DS	1		; Damping on/off period
0065                  2068     DAMPING_ON: 				DS	1		; Damping on part of damping period
                      2069     
0066                  2070     LIPO_ADC_REFERENCE_L: 		DS	1		; Voltage reference adc value (lo byte)
0067                  2071     LIPO_ADC_REFERENCE_H: 		DS	1		; Voltage reference adc value (hi byte)
0068                  2072     LIPO_ADC_LIMIT_L: 			DS	1		; Low voltage limit adc value (lo byte)
0069                  2073     LIPO_ADC_LIMIT_H: 			DS	1		; Low voltage limit adc value (hi byte)
006A                  2074     ADC_CONVERSION_CNT: 			DS	1		; Adc conversion counter
                      2075     
006B                  2076     CURRENT_AVERAGE_TEMP: 		DS	1		; Current average temperature (lo byte ADC reading, assuming hi byte is 1)
                      2077     
006C                  2078     PPM_THROTTLE_GAIN: 			DS	1		; Gain to be applied to RCP value for PPM input
006D                  2079     BEEP_STRENGTH: 				DS	1		; Strength of beeps
                      2080     
006E                  2081     TX_PGM_FUNC_NO: 			DS	1		; Function number when doing programming by tx
006F                  2082     TX_PGM_PARAVAL_NO: 			DS	1		; Parameter value number when doing programming by tx
0070                  2083     TX_PGM_BEEP_NO: 			DS	1		; Beep number when doing programming by tx
                      2084     
                      2085     ; Indirect addressing data segment
------                2086     ISEG AT 080H					
0080                  2087     PGM_GOV_P_GAIN: 			DS	1		; Programmed governor P gain
0081                  2088     PGM_GOV_I_GAIN: 			DS	1		; Programmed governor I gain
0082                  2089     PGM_GOV_MODE: 				DS	1		; Programmed governor mode
                      2090     
0083                  2091     PGM_LOW_VOLTAGE_LIM: 		DS	1		; Programmed low voltage limit
0084                  2092     PGM_MOTOR_GAIN: 			DS	1		; Programmed motor gain
0085                  2093     PGM_MOTOR_IDLE: 			DS	1		; Programmed motor idle speed
0086                  2094     PGM_STARTUP_PWR: 			DS	1		; Programmed startup power
0087                  2095     PGM_PWM_FREQ: 				DS	1		; Programmed pwm frequency
0088                  2096     PGM_DIRECTION_REV: 			DS	1		; Programmed rotation direction
0089                  2097     PGM_INPUT_POL: 				DS	1		; Programmed input pwm polarity
008A                  2098     INITIALIZED_L_DUMMY: 		DS	1		; Place holder
008B                  2099     INITIALIZED_H_DUMMY: 		DS	1		; Place holder
008C                  2100     PGM_ENABLE_TX_PROGRAM: 		DS 	1		; Programmed enable/disable value for TX programming
008D                  2101     PGM_MAIN_REARM_START: 		DS 	1		; Programmed enable/disable re-arming main every start 
008E                  2102     PGM_GOV_SETUP_TARGET: 		DS 	1		; Programmed main governor setup target
008F                  2103     PGM_STARTUP_RPM: 			DS	1		; Programmed startup rpm
0090                  2104     PGM_STARTUP_ACCEL: 			DS	1		; Programmed startup acceleration
0091                  2105     PGM_VOLT_COMP_DUMMY: 		DS	1		; Place holder
0092                  2106     PGM_COMM_TIMING: 			DS	1		; Programmed commutation timing
0093                  2107     PGM_DAMPING_FORCE: 			DS	1		; Programmed damping force
0094                  2108     PGM_GOV_RANGE: 				DS	1		; Programmed governor range
0095                  2109     PGM_STARTUP_METHOD: 			DS	1		; Programmed startup method
0096                  2110     PGM_PPM_MIN_THROTTLE: 		DS	1		; Programmed throttle minimum
0097                  2111     PGM_PPM_MAX_THROTTLE: 		DS	1		; Programmed throttle maximum
0098                  2112     PGM_BEEP_STRENGTH: 			DS	1		; Programmed beep strength
0099                  2113     PGM_BEACON_STRENGTH: 		DS	1		; Programmed beacon strength
009A                  2114     PGM_BEACON_DELAY: 			DS	1		; Programmed beacon delay
009B                  2115     PGM_THROTTLE_RATE: 			DS	1		; Programmed throttle rate
009C                  2116     PGM_DEMAG_COMP: 			DS	1		; Programmed demag compensation
009D                  2117     PGM_BEC_VOLTAGE_HIGH: 		DS	1		; Programmed BEC voltage
                      2118     
009E                  2119     PGM_GOV_P_GAIN_DECODED: 		DS	1		; Programmed governor decoded P gain
009F                  2120     PGM_GOV_I_GAIN_DECODED: 		DS	1		; Programmed governor decoded I gain
00A0                  2121     PGM_THROTTLE_RATE_DECODED: 	DS	1		; Programmed throttle rate decoded
00A1                  2122     PGM_STARTUP_PWR_DECODED: 		DS	1		; Programmed startup power decoded
00A2                  2123     PGM_DEMAG_COMP_WAIT_DECODED: 	DS	1		; Programmed demag compensation wait decoded
00A3                  2124     PGM_DEMAG_COMP_POWER_DECODED: 	DS	1		; Programmed demag compensation power cut decoded
                      2125     
                      2126     
                      2127     ; Indirect addressing data segment
------                2128     ISEG AT 0D0H					
00D0                  2129     TAG_TEMPORARY_STORAGE: 		DS	48		; Temporary storage for tags when updating "Eeprom"
                      2130     
                      2131     
                      2132     ;**** **** **** **** ****
------                2133     CSEG AT 1A00H            ; "Eeprom" segment
  000A                2134     EEPROM_FW_MAIN_REVISION		EQU	10		; Main revision of the firmware
  0004                2135     EEPROM_FW_SUB_REVISION		EQU	4		; Sub revision of the firmware
  0010                2136     EEPROM_LAYOUT_REVISION		EQU	16		; Revision of the EEPROM layout
                      2137     
1A00    0A            2138     EEP_FW_MAIN_REVISION:  DB 10 
1A01    04            2139     EEP_FW_SUB_REVISION:  DB 4 
1A02    10            2140     EEP_LAYOUT_REVISION:  DB 16 
                      2141     
                      2142     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:			DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:			DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               
                               EEP_PGM_LOW_VOLTAGE_LIM:		DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:		DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:		DB	0FFH							
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION_REV:		DB	DEFAULT_PGM_MAIN_DIRECTION_REV	; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:		DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:	DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:			DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_MAIN_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               ENDIF
                      2175     
                      2176     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:		DB	0FFH							
                               _EEP_PGM_GOV_MODE:			DB 	0FFH							
                               
                               _EEP_PGM_LOW_VOLTAGE_LIM:	DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:			DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:			DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:		DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:			DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION_REV:		DB	DEFAULT_PGM_TAIL_DIRECTION_REV	; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:			DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:			DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:			DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:		DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:		DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:	DB	0FFH							
                               EEP_PGM_STARTUP_RPM:		DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:		DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               _EEP_PGM_VOLT_COMP:			DB	0FFH	
                               EEP_PGM_COMM_TIMING:		DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:		DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:			DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:		DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:	DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:	DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:		DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:		DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:		DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               EEP_PGM_DEMAG_COMP:			DB	DEFAULT_PGM_TAIL_DEMAG_COMP		; EEPROM copy of programmed demag compensation
                               EEP_PGM_BEC_VOLTAGE_HIGH:	DB	DEFAULT_PGM_BEC_VOLTAGE_HIGH		; EEPROM copy of programmed BEC voltage
                               ENDIF
                      2209     
                      2210     IF MODE == 2
1A03    09            2211     EEP_PGM_GOV_P_GAIN:  DB 9 
1A04    09            2212     EEP_PGM_GOV_I_GAIN:  DB 9 
1A05    04            2213     EEP_PGM_GOV_MODE:  DB 4 
                      2214     
1A06    01            2215     EEP_PGM_LOW_VOLTAGE_LIM:  DB 1 
1A07    03            2216     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            2217     _EEP_PGM_MOTOR_IDLE: 		DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    09            2218     EEP_PGM_STARTUP_PWR:  DB 9 
1A0A    01            2219     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            2220     EEP_PGM_DIRECTION_REV:  DB 1 
1A0C    01            2221     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            2222     EEP_INITIALIZED_L: 			DB	055H							; EEPROM initialized signature low byte
1A0E    AA            2223     EEP_INITIALIZED_H: 			DB	0AAH							; EEPROM initialized signature high byte
1A0F    01            2224     EEP_ENABLE_TX_PROGRAM:  DB 1 
1A10    FF            2225     _EEP_MAIN_REARM_START: 		DB	0FFH							
1A11    FF            2226     _EEP_PGM_GOV_SETUP_TARGET: 	DB	0FFH							
1A12    01            2227     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            2228     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    FF            2229     _EEP_PGM_VOLT_COMP: 			DB	0FFH	
1A15    03            2230     EEP_PGM_COMM_TIMING:  DB 3 
1A16    06            2231     EEP_PGM_DAMPING_FORCE:  DB 6 
1A17    FF            2232     _EEP_PGM_GOV_RANGE: 			DB	0FFH	
1A18    02            2233     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    25            2234     EEP_PGM_PPM_MIN_THROTTLE:  DB 37 
1A1A    D0            2235     EEP_PGM_PPM_MAX_THROTTLE:  DB 208 
1A1B    28            2236     EEP_PGM_BEEP_STRENGTH:  DB 40 
1A1C    50            2237     EEP_PGM_BEACON_STRENGTH:  DB 80 
1A1D    04            2238     EEP_PGM_BEACON_DELAY:  DB 4 
1A1E    0D            2239     EEP_PGM_THROTTLE_RATE:  DB 13 
1A1F    02            2240     EEP_PGM_DEMAG_COMP:  DB 2 
1A20    00            2241     EEP_PGM_BEC_VOLTAGE_HIGH:  DB 0 
                      2242     ENDIF
                      2243     
                      2244     
1A21    FF            2245     EEP_DUMMY: 				DB	0FFH							; EEPROM address for safety reason
                      2246     
------                2247     CSEG AT 1A60H
1A60    20202020      2248     EEP_NAME: 					DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      2249     
                      2250     ;**** **** **** **** ****
                      2251            		INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                2251+1   CSEG AT 0  ; CODE SEGMENT START
0000    0211FB        2251+1   JMP RESET 
------                2251+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    0200C1        2251+1   JMP T0_INT 
------                2251+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    0203EB        2251+1   JMP T2_INT 
------                2251+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    02053D        2251+1   JMP PCA_INT 
------                2251+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    020533        2251+1   JMP T3_INT 
------                2252     CSEG AT 80H			; Code segment after interrupt vectors 
                      2253     
                      2254     ;**** **** **** **** ****
                      2255     
                      2256     ; Table definitions
0080    02030406      2257     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      2258     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
009A    0406080C      2259     STARTUP_POWER_TABLE:   	DB 	04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H, 0A0H, 0C0H
009E    10182030
00A2    406080A0
00A6    C0
00A7    00000001      2260     DEMAG_WAIT_TABLE:   		DB 	0, 0, 0, 1, 1
00AB    01
00AC    00030202      2261     DEMAG_POWER_TABLE:   	DB 	0, 3, 2, 2, 1
00B0    01
                      2262     IF MODE == 0
                               TX_PGM_PARAMS_MAIN:  	DB 	13, 13, 4, 2, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                               ENDIF
                      2265     IF MODE == 1
                                 IF DAMPED_MODE_ENABLE == 1
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 4, 5, 2, 2
                                 ENDIF
                                 IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_TAIL:  	DB 	5, 5, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                                 ENDIF
                               ENDIF
                      2273     IF MODE == 2
                      2274       IF DAMPED_MODE_ENABLE == 1
00B1    0D0D0405      2275     TX_PGM_PARAMS_MULTI:   	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 4, 5, 2, 2
00B5    06020D05
00B9    05050D06
00BD    04050202
                      2276       ENDIF
                      2277       IF DAMPED_MODE_ENABLE == 0
                               TX_PGM_PARAMS_MULTI:  	DB 	13, 13, 4, 5, 6, 2, 13, 5, 5, 5, 13, 6, 3, 5, 2, 2
                                 ENDIF
                      2280     ENDIF
                      2281     
                      2282     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2283     ;
                      2284     ; Timer0 interrupt routine
                      2285     ;
                      2286     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      2287     ; Requirements: Temp variables can NOT be used since PWSW.3 is not set
                      2288     ;
                      2289     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2290     T0_INT: 	; Used for pwm control
00C1    C2AF          2291     	CLR 	EA			; Disable all interrupts
00C3    C0D0          2292     	PUSH	PSW			; Preserve registers through interrupt
00C5    C0E0          2293     	PUSH	ACC		
                      2294     	; Check if pwm is on
00C7    205A0D        2295     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      2296     
                      2297     	; Pwm on cycle. 
00CA    302F02        2298     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      2299     
                      2300     T0_INT_PWM_ON_EXECUTE: 
00CD    E4            2301     	CLR	A					
00CE    73            2302     	JMP	@A+DPTR					; No - jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      2303     
                      2304     T0_INT_PWM_ON_LOW_PWM: 
                      2305     	; Do not execute pwm when stopped
00CF    306002        2306     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      2307     
                      2308     IF MODE == 0 OR MODE == 2	; Main or multi
00D2    80F9          2309     	JMP	T0_INT_PWM_ON_EXECUTE
                      2310     ENDIF
                      2311     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      2328     
                      2329     T0_INT_PWM_ON_STOPPED: 
00D4    0203D7        2330     	JMP	T0_INT_PWM_ON_EXIT
                      2331     
                      2332     
                      2333     T0_INT_PWM_OFF: 
00D7    306306        2334     JNB FLAGS1 . 3 , T0_INT_PWM_OFF_START_CHECKED 
                      2335     	ALL_NFETS_OFF 					; Switch off all nfets early during direct start, for a smooth start
00DA    C292          2335+1   CLR P1 . 2 
00DC    C296          2335+1   CLR P1 . 6 
00DE    C295          2335+1   CLR P1 . 5 
                      2336     T0_INT_PWM_OFF_START_CHECKED: 
                      2337     	; Pwm off cycle
00E0    85258A        2338     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      2339     	; Clear pwm on flag
00E3    C25A          2340     CLR FLAGS0 . 2 
                      2341     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00E5    E525          2342     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00E7    F4            2343     	CPL	A						; Full pwm?
00E8    7002          2344     	JNZ	($+4)					; No - branch
00EA    21CA          2345     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      2346     
00EC    0561          2347     	INC	PWM_OFF_CNT				; Increment event counter
                      2348     	; Do not execute pwm when stopped
00EE    306013        2349     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      2350     
                      2351     	; If damped operation, set pFETs on in pwm_off
00F1    206A19        2352     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      2353     
                      2354     	; Separate exit commands here for minimum delay
00F4    758B00        2355     	MOV	TL1, #0		; Reset timer1	
00F7    D0E0          2356     	POP	ACC			; Restore preserved registers
00F9    D0D0          2357     	POP	PSW
                      2358     	ALL_NFETS_OFF 		; Switch off all nfets
00FB    C292          2358+1   CLR P1 . 2 
00FD    C296          2358+1   CLR P1 . 6 
00FF    C295          2358+1   CLR P1 . 5 
0101    D2AF          2359     	SETB	EA			; Enable all interrupts
0103    32            2360     	RETI
                      2361     
                      2362     T0_INT_PWM_OFF_STOPPED: 
                      2363     	ALL_NFETS_OFF 					; Switch off all nfets
0104    C292          2363+1   CLR P1 . 2 
0106    C296          2363+1   CLR P1 . 6 
0108    C295          2363+1   CLR P1 . 5 
010A    0201BA        2364     	JMP	T0_INT_PWM_OFF_EXIT
                      2365     
                      2366     T0_INT_PWM_OFF_DAMPED: 
010D    D26E          2367     SETB FLAGS2 . 6 
010F    C26F          2368     CLR FLAGS2 . 7 
0111    E565          2369     	MOV	A, DAMPING_ON
0113    601C          2370     	JZ	T0_INT_PWM_OFF_DO_DAMPED		; Highest damping - apply damping always
                      2371     
0115    C3            2372     	CLR	C
0116    E561          2373     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
0118    14            2374     	DEC	A
0119    9565          2375     	SUBB	A, DAMPING_ON
011B    4014          2376     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      2377     
011D    C26E          2378     CLR FLAGS2 . 6 
011F    D26F          2379     SETB FLAGS2 . 7 
0121    C3            2380     	CLR	C
0122    E561          2381     	MOV	A, PWM_OFF_CNT					
0124    9564          2382     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
0126    5003          2383     	JNC	T0_INT_PWM_OFF_CLR_CNT		; Yes - Proceed
                      2384     
0128    0201BA        2385     	JMP	T0_INT_PWM_OFF_EXIT			; No - Branch
                      2386     
                      2387     T0_INT_PWM_OFF_CLR_CNT: 
012B    756100        2388     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
012E    0201BA        2389     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      2390     
                      2391     T0_INT_PWM_OFF_DO_DAMPED: 
                      2392     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
0131    206C14        2393     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      2394     
                      2395     	ALL_NFETS_OFF 					; Switch off all nfets
0134    C292          2395+1   CLR P1 . 2 
0136    C296          2395+1   CLR P1 . 6 
0138    C295          2395+1   CLR P1 . 5 
013A    7406          2396     MOV A , # 6 
013C    D5E0FD        2397     	DJNZ	ACC, $	
                      2398     	ALL_PFETS_ON 					; Switch on all pfets
013F    D293          2398+1   SETB P1 . 3 
0141    D297          2398+1   SETB P1 . 7 
0143    D294          2398+1   SETB P1 . 4 
0145    0201BA        2399     	JMP	T0_INT_PWM_OFF_EXIT
                      2400     
                      2401     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      2402     IF DAMPED_MODE_ENABLE == 1
0148    D26F          2403     SETB FLAGS2 . 7 
                      2404     ENDIF
                      2405     	ALL_NFETS_OFF 					; Switch off all nfets
014A    C292          2405+1   CLR P1 . 2 
014C    C296          2405+1   CLR P1 . 6 
014E    C295          2405+1   CLR P1 . 5 
0150    E53D          2406     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
0152    20E234        2407     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
0155    20E112        2408     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      2409     
                      2410     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 1 - turn on A
                               ELSE
0158    7406          2413     MOV A , # 6 
015A    D5E0FD        2414     	DJNZ	ACC, $	
                      2415     	CPFET_ON			; Comm phase 1 - turn on C
015D    207502        2415+1   JB FLAGS3 . 5 , ( $+5 ) 
0160    D297          2415+1   SETB P1 . 7 
0162    307502        2415+1   JNB FLAGS3 . 5 , ( $+5 ) 
0165    D293          2415+1   SETB P1 . 3 
                      2416     ENDIF
0167    0201BA        2417     	JMP	T0_INT_PWM_OFF_EXIT
                      2418     
                      2419     T0_INT_PWM_OFF_COMM_2_3: 
016A    20E012        2420     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      2421     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 2 - turn on B
                               ELSE
016D    7406          2424     MOV A , # 6 
016F    D5E0FD        2425     	DJNZ	ACC, $	
                      2426     	CPFET_ON			; Comm phase 2 - turn on C
0172    207502        2426+1   JB FLAGS3 . 5 , ( $+5 ) 
0175    D297          2426+1   SETB P1 . 7 
0177    307502        2426+1   JNB FLAGS3 . 5 , ( $+5 ) 
017A    D293          2426+1   SETB P1 . 3 
                      2427     ENDIF
017C    0201BA        2428     	JMP	T0_INT_PWM_OFF_EXIT
                      2429     
                      2430     T0_INT_PWM_OFF_COMM_3: 
                      2431     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 3 - turn on C
                               ELSE
017F    7406          2434     MOV A , # 6 
0181    D5E0FD        2435     	DJNZ	ACC, $	
                      2436     	BPFET_ON			; Comm phase 3 - turn on B
0184    D294          2436+1   SETB P1 . 4 
                      2437     ENDIF
0186    0201BA        2438     	JMP	T0_INT_PWM_OFF_EXIT
                      2439     
                      2440     T0_INT_PWM_OFF_COMM_4_5_6: 
0189    20E11F        2441     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
018C    20E00A        2442     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      2443     
                      2444     IF DAMPED_MODE_ENABLE == 0
                               	APFET_ON			; Comm phase 4 - turn on A
                               ELSE
018F    7406          2447     MOV A , # 6 
0191    D5E0FD        2448     	DJNZ	ACC, $	
                      2449     	BPFET_ON			; Comm phase 4 - turn on B
0194    D294          2449+1   SETB P1 . 4 
                      2450     ENDIF
0196    0201BA        2451     	JMP	T0_INT_PWM_OFF_EXIT
                      2452     
                      2453     T0_INT_PWM_OFF_COMM_5: 
                      2454     IF DAMPED_MODE_ENABLE == 0
                               	BPFET_ON			; Comm phase 5 - turn on B
                               ELSE
0199    7406          2457     MOV A , # 6 
019B    D5E0FD        2458     	DJNZ	ACC, $	
                      2459     	APFET_ON			; Comm phase 5 - turn on A
019E    207502        2459+1   JB FLAGS3 . 5 , ( $+5 ) 
01A1    D293          2459+1   SETB P1 . 3 
01A3    307502        2459+1   JNB FLAGS3 . 5 , ( $+5 ) 
01A6    D297          2459+1   SETB P1 . 7 
                      2460     ENDIF
01A8    0201BA        2461     	JMP	T0_INT_PWM_OFF_EXIT
                      2462     
                      2463     T0_INT_PWM_OFF_COMM_6: 
                      2464     IF DAMPED_MODE_ENABLE == 0
                               	CPFET_ON			; Comm phase 6 - turn on C
                               ELSE
01AB    7406          2467     MOV A , # 6 
01AD    D5E0FD        2468     	DJNZ	ACC, $	
                      2469     	APFET_ON			; Comm phase 6 - turn on A
01B0    207502        2469+1   JB FLAGS3 . 5 , ( $+5 ) 
01B3    D293          2469+1   SETB P1 . 3 
01B5    307502        2469+1   JNB FLAGS3 . 5 , ( $+5 ) 
01B8    D297          2469+1   SETB P1 . 7 
                      2470     ENDIF
                      2471     
                      2472     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
01BA    758B00        2473     	MOV	TL1, #0		; Reset timer1	
01BD    D0E0          2474     	POP	ACC			; Restore preserved registers
01BF    D0D0          2475     	POP	PSW
                      2476     	ALL_NFETS_OFF 		; Switch off all nfets
01C1    C292          2476+1   CLR P1 . 2 
01C3    C296          2476+1   CLR P1 . 6 
01C5    C295          2476+1   CLR P1 . 5 
01C7    D2AF          2477     	SETB	EA			; Enable all interrupts
01C9    32            2478     	RETI
                      2479     
                      2480     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
01CA    D0E0          2481     	POP	ACC			; Restore preserved registers
01CC    D0D0          2482     	POP	PSW
01CE    D2AF          2483     	SETB	EA			; Enable all interrupts
01D0    32            2484     	RETI
                      2485     
                      2486     
                      2487     
                      2488     PWM_NOFET_ON: 	; Dummy pwm on cycle
01D1    61D7          2489     	AJMP	T0_INT_PWM_ON_EXIT
                      2490     
                      2491     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      2492     	ANFET_ON	
01D3    E525          2492+1   MOV A , CURRENT_PWM_LIMITED 
01D5    600A          2492+1   JZ ( $+12 ) 
01D7    207502        2492+1   JB FLAGS3 . 5 , ( $+5 ) 
01DA    D292          2492+1   SETB P1 . 2 
01DC    307502        2492+1   JNB FLAGS3 . 5 , ( $+5 ) 
01DF    D296          2492+1   SETB P1 . 6 
                      2493     	BNFET_OFF
01E1    C295          2493+1   CLR P1 . 5 
01E3    61D7          2494     	AJMP	T0_INT_PWM_ON_EXIT
                      2495     
                      2496     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      2497     	BNFET_ON
01E5    E525          2497+1   MOV A , CURRENT_PWM_LIMITED 
01E7    6002          2497+1   JZ ( $+4 ) 
01E9    D295          2497+1   SETB P1 . 5 
                      2498     	CNFET_OFF
01EB    207502        2498+1   JB FLAGS3 . 5 , ( $+5 ) 
01EE    C296          2498+1   CLR P1 . 6 
01F0    307502        2498+1   JNB FLAGS3 . 5 , ( $+5 ) 
01F3    C292          2498+1   CLR P1 . 2 
01F5    61D7          2499     	AJMP	T0_INT_PWM_ON_EXIT
                      2500     
                      2501     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      2502     	CNFET_ON
01F7    E525          2502+1   MOV A , CURRENT_PWM_LIMITED 
01F9    600A          2502+1   JZ ( $+12 ) 
01FB    207502        2502+1   JB FLAGS3 . 5 , ( $+5 ) 
01FE    D296          2502+1   SETB P1 . 6 
0200    307502        2502+1   JNB FLAGS3 . 5 , ( $+5 ) 
0203    D292          2502+1   SETB P1 . 2 
                      2503     	ANFET_OFF
0205    207502        2503+1   JB FLAGS3 . 5 , ( $+5 ) 
0208    C292          2503+1   CLR P1 . 2 
020A    307502        2503+1   JNB FLAGS3 . 5 , ( $+5 ) 
020D    C296          2503+1   CLR P1 . 6 
020F    61D7          2504     	AJMP	T0_INT_PWM_ON_EXIT
                      2505     
                      2506     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      2507     	APFET_OFF
0211    207502        2507+1   JB FLAGS3 . 5 , ( $+5 ) 
0214    C293          2507+1   CLR P1 . 3 
0216    307502        2507+1   JNB FLAGS3 . 5 , ( $+5 ) 
0219    C297          2507+1   CLR P1 . 7 
                      2508     	ANFET_ON								; Switch nFETs
021B    E525          2508+1   MOV A , CURRENT_PWM_LIMITED 
021D    600A          2508+1   JZ ( $+12 ) 
021F    207502        2508+1   JB FLAGS3 . 5 , ( $+5 ) 
0222    D292          2508+1   SETB P1 . 2 
0224    307502        2508+1   JNB FLAGS3 . 5 , ( $+5 ) 
0227    D296          2508+1   SETB P1 . 6 
                      2509     	CPFET_OFF
0229    207502        2509+1   JB FLAGS3 . 5 , ( $+5 ) 
022C    C297          2509+1   CLR P1 . 7 
022E    307502        2509+1   JNB FLAGS3 . 5 , ( $+5 ) 
0231    C293          2509+1   CLR P1 . 3 
                      2510     	BNFET_OFF 							
0233    C295          2510+1   CLR P1 . 5 
0235    61D7          2511     	AJMP	T0_INT_PWM_ON_EXIT
                      2512     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      2513     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2514     	APFET_OFF
0237    207502        2514+1   JB FLAGS3 . 5 , ( $+5 ) 
023A    C293          2514+1   CLR P1 . 3 
023C    307502        2514+1   JNB FLAGS3 . 5 , ( $+5 ) 
023F    C297          2514+1   CLR P1 . 7 
                      2515     	CPFET_OFF
0241    207502        2515+1   JB FLAGS3 . 5 , ( $+5 ) 
0244    C297          2515+1   CLR P1 . 7 
0246    307502        2515+1   JNB FLAGS3 . 5 , ( $+5 ) 
0249    C293          2515+1   CLR P1 . 3 
024B    7406          2516     MOV A , # 6 
024D    D5E0FD        2517     	DJNZ ACC,	$
                      2518     	ANFET_ON								; Switch nFETs
0250    E525          2518+1   MOV A , CURRENT_PWM_LIMITED 
0252    600A          2518+1   JZ ( $+12 ) 
0254    207502        2518+1   JB FLAGS3 . 5 , ( $+5 ) 
0257    D292          2518+1   SETB P1 . 2 
0259    307502        2518+1   JNB FLAGS3 . 5 , ( $+5 ) 
025C    D296          2518+1   SETB P1 . 6 
                      2519     	BNFET_OFF 							
025E    C295          2519+1   CLR P1 . 5 
0260    61D7          2520     	AJMP	T0_INT_PWM_ON_EXIT
                      2521     
                      2522     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      2523     	APFET_OFF
0262    207502        2523+1   JB FLAGS3 . 5 , ( $+5 ) 
0265    C293          2523+1   CLR P1 . 3 
0267    307502        2523+1   JNB FLAGS3 . 5 , ( $+5 ) 
026A    C297          2523+1   CLR P1 . 7 
                      2524     	ANFET_ON								; Switch nFETs
026C    E525          2524+1   MOV A , CURRENT_PWM_LIMITED 
026E    600A          2524+1   JZ ( $+12 ) 
0270    207502        2524+1   JB FLAGS3 . 5 , ( $+5 ) 
0273    D292          2524+1   SETB P1 . 2 
0275    307502        2524+1   JNB FLAGS3 . 5 , ( $+5 ) 
0278    D296          2524+1   SETB P1 . 6 
                      2525     	BPFET_OFF
027A    C294          2525+1   CLR P1 . 4 
                      2526     	BNFET_OFF								
027C    C295          2526+1   CLR P1 . 5 
027E    61D7          2527     	AJMP	T0_INT_PWM_ON_EXIT
                      2528     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      2529     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2530     	APFET_OFF
0280    207502        2530+1   JB FLAGS3 . 5 , ( $+5 ) 
0283    C293          2530+1   CLR P1 . 3 
0285    307502        2530+1   JNB FLAGS3 . 5 , ( $+5 ) 
0288    C297          2530+1   CLR P1 . 7 
                      2531     	BPFET_OFF
028A    C294          2531+1   CLR P1 . 4 
028C    7406          2532     MOV A , # 6 
028E    D5E0FD        2533     	DJNZ ACC,	$
                      2534     	ANFET_ON								; Switch nFETs
0291    E525          2534+1   MOV A , CURRENT_PWM_LIMITED 
0293    600A          2534+1   JZ ( $+12 ) 
0295    207502        2534+1   JB FLAGS3 . 5 , ( $+5 ) 
0298    D292          2534+1   SETB P1 . 2 
029A    307502        2534+1   JNB FLAGS3 . 5 , ( $+5 ) 
029D    D296          2534+1   SETB P1 . 6 
                      2535     	BNFET_OFF								
029F    C295          2535+1   CLR P1 . 5 
02A1    61D7          2536     	AJMP	T0_INT_PWM_ON_EXIT
                      2537     
                      2538     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      2539     	BPFET_OFF
02A3    C294          2539+1   CLR P1 . 4 
                      2540     	BNFET_ON								; Switch nFETs
02A5    E525          2540+1   MOV A , CURRENT_PWM_LIMITED 
02A7    6002          2540+1   JZ ( $+4 ) 
02A9    D295          2540+1   SETB P1 . 5 
                      2541     	APFET_OFF
02AB    207502        2541+1   JB FLAGS3 . 5 , ( $+5 ) 
02AE    C293          2541+1   CLR P1 . 3 
02B0    307502        2541+1   JNB FLAGS3 . 5 , ( $+5 ) 
02B3    C297          2541+1   CLR P1 . 7 
                      2542     	CNFET_OFF								
02B5    207502        2542+1   JB FLAGS3 . 5 , ( $+5 ) 
02B8    C296          2542+1   CLR P1 . 6 
02BA    307502        2542+1   JNB FLAGS3 . 5 , ( $+5 ) 
02BD    C292          2542+1   CLR P1 . 2 
02BF    61D7          2543     	AJMP	T0_INT_PWM_ON_EXIT
                      2544     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      2545     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2546     	BPFET_OFF
02C1    C294          2546+1   CLR P1 . 4 
                      2547     	APFET_OFF
02C3    207502        2547+1   JB FLAGS3 . 5 , ( $+5 ) 
02C6    C293          2547+1   CLR P1 . 3 
02C8    307502        2547+1   JNB FLAGS3 . 5 , ( $+5 ) 
02CB    C297          2547+1   CLR P1 . 7 
02CD    7406          2548     MOV A , # 6 
02CF    D5E0FD        2549     	DJNZ ACC,	$
                      2550     	BNFET_ON								; Switch nFETs
02D2    E525          2550+1   MOV A , CURRENT_PWM_LIMITED 
02D4    6002          2550+1   JZ ( $+4 ) 
02D6    D295          2550+1   SETB P1 . 5 
                      2551     	CNFET_OFF								
02D8    207502        2551+1   JB FLAGS3 . 5 , ( $+5 ) 
02DB    C296          2551+1   CLR P1 . 6 
02DD    307502        2551+1   JNB FLAGS3 . 5 , ( $+5 ) 
02E0    C292          2551+1   CLR P1 . 2 
02E2    61D7          2552     	AJMP	T0_INT_PWM_ON_EXIT
                      2553     
                      2554     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      2555     	BPFET_OFF
02E4    C294          2555+1   CLR P1 . 4 
                      2556     	BNFET_ON								; Switch nFETs
02E6    E525          2556+1   MOV A , CURRENT_PWM_LIMITED 
02E8    6002          2556+1   JZ ( $+4 ) 
02EA    D295          2556+1   SETB P1 . 5 
                      2557     	CPFET_OFF
02EC    207502        2557+1   JB FLAGS3 . 5 , ( $+5 ) 
02EF    C297          2557+1   CLR P1 . 7 
02F1    307502        2557+1   JNB FLAGS3 . 5 , ( $+5 ) 
02F4    C293          2557+1   CLR P1 . 3 
                      2558     	CNFET_OFF								
02F6    207502        2558+1   JB FLAGS3 . 5 , ( $+5 ) 
02F9    C296          2558+1   CLR P1 . 6 
02FB    307502        2558+1   JNB FLAGS3 . 5 , ( $+5 ) 
02FE    C292          2558+1   CLR P1 . 2 
0300    61D7          2559     	AJMP	T0_INT_PWM_ON_EXIT
                      2560     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      2561     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2562     	BPFET_OFF
0302    C294          2562+1   CLR P1 . 4 
                      2563     	CPFET_OFF
0304    207502        2563+1   JB FLAGS3 . 5 , ( $+5 ) 
0307    C297          2563+1   CLR P1 . 7 
0309    307502        2563+1   JNB FLAGS3 . 5 , ( $+5 ) 
030C    C293          2563+1   CLR P1 . 3 
030E    7406          2564     MOV A , # 6 
0310    D5E0FD        2565     	DJNZ ACC,	$
                      2566     	BNFET_ON								; Switch nFETs
0313    E525          2566+1   MOV A , CURRENT_PWM_LIMITED 
0315    6002          2566+1   JZ ( $+4 ) 
0317    D295          2566+1   SETB P1 . 5 
                      2567     	CNFET_OFF								
0319    207502        2567+1   JB FLAGS3 . 5 , ( $+5 ) 
031C    C296          2567+1   CLR P1 . 6 
031E    307502        2567+1   JNB FLAGS3 . 5 , ( $+5 ) 
0321    C292          2567+1   CLR P1 . 2 
0323    61D7          2568     	AJMP	T0_INT_PWM_ON_EXIT
                      2569     
                      2570     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      2571     	CPFET_OFF
0325    207502        2571+1   JB FLAGS3 . 5 , ( $+5 ) 
0328    C297          2571+1   CLR P1 . 7 
032A    307502        2571+1   JNB FLAGS3 . 5 , ( $+5 ) 
032D    C293          2571+1   CLR P1 . 3 
                      2572     	CNFET_ON								; Switch nFETs
032F    E525          2572+1   MOV A , CURRENT_PWM_LIMITED 
0331    600A          2572+1   JZ ( $+12 ) 
0333    207502        2572+1   JB FLAGS3 . 5 , ( $+5 ) 
0336    D296          2572+1   SETB P1 . 6 
0338    307502        2572+1   JNB FLAGS3 . 5 , ( $+5 ) 
033B    D292          2572+1   SETB P1 . 2 
                      2573     	BPFET_OFF
033D    C294          2573+1   CLR P1 . 4 
                      2574     	ANFET_OFF								
033F    207502        2574+1   JB FLAGS3 . 5 , ( $+5 ) 
0342    C292          2574+1   CLR P1 . 2 
0344    307502        2574+1   JNB FLAGS3 . 5 , ( $+5 ) 
0347    C296          2574+1   CLR P1 . 6 
0349    61D7          2575     	AJMP	T0_INT_PWM_ON_EXIT
                      2576     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      2577     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2578     	CPFET_OFF
034B    207502        2578+1   JB FLAGS3 . 5 , ( $+5 ) 
034E    C297          2578+1   CLR P1 . 7 
0350    307502        2578+1   JNB FLAGS3 . 5 , ( $+5 ) 
0353    C293          2578+1   CLR P1 . 3 
                      2579     	BPFET_OFF
0355    C294          2579+1   CLR P1 . 4 
0357    7406          2580     MOV A , # 6 
0359    D5E0FD        2581     	DJNZ ACC,	$
                      2582     	CNFET_ON								; Switch nFETs
035C    E525          2582+1   MOV A , CURRENT_PWM_LIMITED 
035E    600A          2582+1   JZ ( $+12 ) 
0360    207502        2582+1   JB FLAGS3 . 5 , ( $+5 ) 
0363    D296          2582+1   SETB P1 . 6 
0365    307502        2582+1   JNB FLAGS3 . 5 , ( $+5 ) 
0368    D292          2582+1   SETB P1 . 2 
                      2583     	ANFET_OFF								
036A    207502        2583+1   JB FLAGS3 . 5 , ( $+5 ) 
036D    C292          2583+1   CLR P1 . 2 
036F    307502        2583+1   JNB FLAGS3 . 5 , ( $+5 ) 
0372    C296          2583+1   CLR P1 . 6 
0374    61D7          2584     	AJMP	T0_INT_PWM_ON_EXIT
                      2585     
                      2586     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      2587     	CPFET_OFF
0376    207502        2587+1   JB FLAGS3 . 5 , ( $+5 ) 
0379    C297          2587+1   CLR P1 . 7 
037B    307502        2587+1   JNB FLAGS3 . 5 , ( $+5 ) 
037E    C293          2587+1   CLR P1 . 3 
                      2588     	CNFET_ON								; Switch nFETs
0380    E525          2588+1   MOV A , CURRENT_PWM_LIMITED 
0382    600A          2588+1   JZ ( $+12 ) 
0384    207502        2588+1   JB FLAGS3 . 5 , ( $+5 ) 
0387    D296          2588+1   SETB P1 . 6 
0389    307502        2588+1   JNB FLAGS3 . 5 , ( $+5 ) 
038C    D292          2588+1   SETB P1 . 2 
                      2589     	APFET_OFF
038E    207502        2589+1   JB FLAGS3 . 5 , ( $+5 ) 
0391    C293          2589+1   CLR P1 . 3 
0393    307502        2589+1   JNB FLAGS3 . 5 , ( $+5 ) 
0396    C297          2589+1   CLR P1 . 7 
                      2590     	ANFET_OFF								
0398    207502        2590+1   JB FLAGS3 . 5 , ( $+5 ) 
039B    C292          2590+1   CLR P1 . 2 
039D    307502        2590+1   JNB FLAGS3 . 5 , ( $+5 ) 
03A0    C296          2590+1   CLR P1 . 6 
03A2    61D7          2591     	AJMP	T0_INT_PWM_ON_EXIT
                      2592     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      2593     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      2594     	CPFET_OFF
03A4    207502        2594+1   JB FLAGS3 . 5 , ( $+5 ) 
03A7    C297          2594+1   CLR P1 . 7 
03A9    307502        2594+1   JNB FLAGS3 . 5 , ( $+5 ) 
03AC    C293          2594+1   CLR P1 . 3 
                      2595     	APFET_OFF
03AE    207502        2595+1   JB FLAGS3 . 5 , ( $+5 ) 
03B1    C293          2595+1   CLR P1 . 3 
03B3    307502        2595+1   JNB FLAGS3 . 5 , ( $+5 ) 
03B6    C297          2595+1   CLR P1 . 7 
03B8    7406          2596     MOV A , # 6 
03BA    D5E0FD        2597     	DJNZ ACC,	$
                      2598     	CNFET_ON								; Switch nFETs
03BD    E525          2598+1   MOV A , CURRENT_PWM_LIMITED 
03BF    600A          2598+1   JZ ( $+12 ) 
03C1    207502        2598+1   JB FLAGS3 . 5 , ( $+5 ) 
03C4    D296          2598+1   SETB P1 . 6 
03C6    307502        2598+1   JNB FLAGS3 . 5 , ( $+5 ) 
03C9    D292          2598+1   SETB P1 . 2 
                      2599     	ANFET_OFF								
03CB    207502        2599+1   JB FLAGS3 . 5 , ( $+5 ) 
03CE    C292          2599+1   CLR P1 . 2 
03D0    307502        2599+1   JNB FLAGS3 . 5 , ( $+5 ) 
03D3    C296          2599+1   CLR P1 . 6 
03D5    61D7          2600     	AJMP	T0_INT_PWM_ON_EXIT
                      2601     
                      2602     T0_INT_PWM_ON_EXIT: 
                      2603     	; Set timer for coming on cycle length
03D7    E525          2604     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
03D9    F4            2605     	CPL	A						; cpl is 255-x
03DA    F58A          2606     	MOV	TL0, A					; Write start point for timer
                      2607     	; Set other variables
03DC    758B00        2608     	MOV	TL1, #0					; Reset timer1	
03DF    756000        2609     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
03E2    D25A          2610     SETB FLAGS0 . 2 
                      2611     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      2612     	; Exit interrupt
03E4    D0E0          2613     	POP	ACC			; Restore preserved registers
03E6    D0D0          2614     	POP	PSW
03E8    D2AF          2615     	SETB	EA			; Enable all interrupts
03EA    32            2616     	RETI
                      2617     
                      2618     
                      2619     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2620     ;
                      2621     ; Timer2 interrupt routine
                      2622     ;
                      2623     ; No assumptions
                      2624     ;
                      2625     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2626     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
03EB    C2AF          2627     	CLR 	EA			; Disable all interrupts
03ED    C0D0          2628     	PUSH	PSW			; Preserve registers through interrupt
03EF    C0E0          2629     	PUSH	ACC
03F1    D2D3          2630     	SETB	PSW.3		; Select register bank 1 for interrupt routines
                      2631     	; Clear low byte interrupt flag
03F3    C2CE          2632     	CLR	TF2L						; Clear interrupt flag
                      2633     	; Check RC pulse timeout counter
03F5    E528          2634     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03F7    600A          2635     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      2636     
                      2637     	; Decrement timeout counter (if PWM)
03F9    741F          2638     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
03FB    552E          2639     	ANL	A, FLAGS3					; Check pwm frequency flags
03FD    6049          2640     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      2641     
03FF    1528          2642     	DEC	RCP_TIMEOUT_CNT			; No - decrement
0401    8148          2643     	AJMP	T2_INT_SKIP_START
                      2644     
                      2645     T2_INT_PULSES_ABSENT: 
                      2646     	; Timeout counter has reached zero, pulses are absent
0403    7800          2647     MOV R0 , # 0 
0405    7900          2648     MOV R1 , # 0 
                      2649     	READ_RCP_INT 					; Look at value of Rcp_In
0407    E580          2649+1   MOV A , P0 
0409    307601        2649+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
040C    F4            2649+1   CPL A  ; YES - INVERT
040D    30E502        2650     JNB ACC . 5 , ( $+5 ) 
0410    78FF          2651     MOV R0 , # 255 
                      2652     	RCP_INT_FIRST 					; Set interrupt trig to first again
0412    53DACF        2652+1   ANL PCA0CPM0 , # 0CFH 
0415    207603        2652+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0418    43DA20        2652+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
041B    307603        2652+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
041E    43DA10        2652+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      2653     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0421    C2D8          2653+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0423    C269          2654     CLR FLAGS2 . 1 
                      2655     	READ_RCP_INT 					; Look once more at value of Rcp_In
0425    E580          2655+1   MOV A , P0 
0427    307601        2655+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
042A    F4            2655+1   CPL A  ; YES - INVERT
042B    30E502        2656     JNB ACC . 5 , ( $+5 ) 
042E    79FF          2657     MOV R1 , # 255 
0430    C3            2658     	CLR	C
0431    E8            2659     MOV A , R0 
0432    99            2660     SUBB A , R1 
0433    70CE          2661     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      2662     
0435    305903        2663     JNB FLAGS0 . 1 , ( $+6 ) 
                      2664     
0438    752818        2665     MOV RCP_TIMEOUT_CNT , # 24 
                      2666     
043B    741F          2667     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
043D    552E          2668     	ANL	A, FLAGS3					; Check pwm frequency flags
043F    6003          2669     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      2670     
0441    752818        2671     MOV RCP_TIMEOUT_CNT , # 24 
                      2672     
                      2673     T2_INT_PPM_TIMEOUT_SET: 
0444    8858          2674     MOV NEW_RCP , R0 
0446    D268          2675     SETB FLAGS2 . 0 
                      2676     
                      2677     
                      2678     T2_INT_SKIP_START: 
                      2679     	; Check RC pulse skip counter
0448    E529          2680     	MOV	A, RCP_SKIP_CNT			
044A    6004          2681     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      2682     	
                      2683     	; Decrement skip counter (only if edge counter is zero)
044C    1529          2684     	DEC	RCP_SKIP_CNT				; Decrement
044E    815B          2685     	AJMP	T2_INT_RCP_UPDATE_START
                      2686     
                      2687     T2_INT_SKIP_END: 
0450    741F          2688     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0452    552E          2689     	ANL	A, FLAGS3					; Check pwm frequency flags
0454    6005          2690     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      2691     
                      2692     	; Skip counter has reached zero, start looking for RC pulses again
                      2693     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
0456    43DA01        2693+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      2694     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0459    C2D8          2694+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      2695     	
                      2696     T2_INT_RCP_UPDATE_START: 
                      2697     	; Process updated RC pulse
045B    206802        2698     JB FLAGS2 . 0 , ( $+5 ) 
045E    81ED          2699     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      2700     
0460    E558          2701     	MOV	A, NEW_RCP				; Load new pulse value
0462    F8            2702     MOV R0 , A 
0463    C268          2703     CLR FLAGS2 . 0 
                      2704     	; Use a gain of 1.0625x for pwm input if not governor mode
0465    741F          2705     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0467    552E          2706     	ANL	A, FLAGS3					; Check pwm frequency flags
0469    6036          2707     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      2708     
                      2709     IF MODE <= 1	; Main or tail
                               	MOV	TEMP2, #PGM_GOV_MODE		; Governor mode?
                               	CJNE	@TEMP2, #4, T2_INT_PWM_MIN_RUN; Yes - branch
                               ENDIF
                      2713     IF MODE == 2	; Multi
046B    7982          2714     MOV R1 , # PGM_GOV_MODE 
046D    B70431        2715     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      2716     ENDIF
                      2717     
                      2718     	; Limit the maximum value to avoid wrap when scaled to pwm range
0470    C3            2719     	CLR	C
0471    E8            2720     MOV A , R0 
0472    94F0          2721     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
0474    4003          2722     	JC	T2_INT_RCP_UPDATE_MULT
                      2723     
0476    74F0          2724     	MOV	A, #240			; Set requested pwm to max
0478    F8            2725     MOV R0 , A 
                      2726     
                      2727     T2_INT_RCP_UPDATE_MULT: 	
                      2728     	; Multiply by 1.0625 (optional adjustment gyro gain)
0479    E8            2729     MOV A , R0 
047A    C4            2730     	SWAP	A			; After this "0.0625"
047B    540F          2731     	ANL	A, #0FH
047D    28            2732     ADD A , R0 
047E    F8            2733     MOV R0 , A 
                      2734     	; Adjust tail gain
047F    7984          2735     MOV R1 , # PGM_MOTOR_GAIN 
0481    B70302        2736     CJNE @ R1 , # 3 , ( $+5 ) 
0484    81A1          2737     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      2738     
0486    C3            2739     	CLR	C
0487    13            2740     	RRC	A			; After this "0.5"
0488    C3            2741     	CLR	C
0489    13            2742     	RRC	A			; After this "0.25"
048A    8721          2743     MOV BIT_ACCESS_INT , @ R1 
048C    200802        2744     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      2745     
048F    C3            2746     	CLR	C
0490    13            2747     	RRC	A			; After this "0.125"
                      2748     
                      2749     T2_INT_RCP_GAIN_CORR: 
0491    200A06        2750     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      2751     
0494    C3            2752     	CLR	C
0495    C8            2753     XCH A , R0 
0496    98            2754     SUBB A , R0 
0497    F8            2755     MOV R0 , A 
0498    81A1          2756     	AJMP	T2_INT_PWM_MIN_RUN
                      2757     
                      2758     T2_INT_RCP_GAIN_POS: 
049A    28            2759     ADD A , R0 
049B    F8            2760     MOV R0 , A 
049C    5003          2761     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      2762     
049E    74FF          2763     	MOV	A, #0FFH					; Yes - limit
04A0    F8            2764     MOV R0 , A 
                      2765     
                      2766     T2_INT_PWM_MIN_RUN:  
                      2767     	; Limit minimum pwm
04A1    C3            2768     	CLR	C
04A2    E8            2769     MOV A , R0 
04A3    955F          2770     	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
04A5    5003          2771     	JNC	T2_INT_PWM_UPDATE			; No - branch
                      2772     
04A7    E55F          2773     	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
04A9    F8            2774     MOV R0 , A 
                      2775     
                      2776     T2_INT_PWM_UPDATE:  
                      2777     	; Check if any startup phase flags are set
04AA    E52C          2778     	MOV	A, FLAGS1
04AC    5406          2779     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
04AE    703D          2780     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      2781     
                      2782     	; Update requested_pwm
04B0    8822          2783     MOV REQUESTED_PWM , R0 
                      2784     	; Limit pwm during direct start
04B2    30630A        2785     JNB FLAGS1 . 3 , T2_INT_CURRENT_PWM_UPDATE 
                      2786     
04B5    C3            2787     	CLR	C
04B6    E522          2788     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
04B8    955C          2789     	SUBB	A, PWM_LIMIT
04BA    4003          2790     	JC	T2_INT_CURRENT_PWM_UPDATE
                      2791     
04BC    855C22        2792     	MOV	REQUESTED_PWM, PWM_LIMIT
                      2793     
                      2794     T2_INT_CURRENT_PWM_UPDATE:  
                      2795     IF MODE <= 1	; Main or tail
                               	MOV	TEMP1, #PGM_GOV_MODE		; Governor mode?
                               	CJNE	@TEMP1, #4, T2_INT_PWM_EXIT	; Yes - branch
                               ENDIF
                      2799     IF MODE == 2	; Multi
04BF    7882          2800     MOV R0 , # PGM_GOV_MODE 
04C1    B60429        2801     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      2802     ENDIF
                      2803     
                      2804     	; Update current pwm, with limited throttle change rate
04C4    C3            2805     	CLR	C
04C5    E522          2806     	MOV	A, REQUESTED_PWM	
04C7    9524          2807     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
04C9    4012          2808     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      2809     
04CB    78A0          2810     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
04CD    96            2811     SUBB A , @ R0 
04CE    400D          2812     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      2813     
04D0    E524          2814     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
04D2    26            2815     ADD A , @ R0 
04D3    F524          2816     	MOV	CURRENT_PWM, A
04D5    5009          2817     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      2818     
04D7    7524FF        2819     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
04DA    0204E0        2820     	JMP	T2_INT_CURRENT_PWM_DONE
                      2821     
                      2822     T2_INT_SET_CURRENT_PWM: 
04DD    852224        2823     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      2824     T2_INT_CURRENT_PWM_DONE: 
                      2825     IF MODE == 1	; Tail
                               	; If tail, then set current_pwm_limited
                               	MOV	CURRENT_PWM_LIMITED, CURRENT_PWM	; Default not limited
                               	CLR	C
                               	MOV	A, CURRENT_PWM					; Check against limit
                               	SUBB	A, PWM_LIMIT
                               	JC	($+5)						; If current pwm below limit - branch
                               
                               	MOV	CURRENT_PWM_LIMITED, PWM_LIMIT	; Limit pwm
                               ENDIF
                      2835     IF MODE == 2	; Multi
                      2836     	; If multi, then set current_pwm_limited
04E0    852425        2837     	MOV	CURRENT_PWM_LIMITED, CURRENT_PWM	; Default not limited
04E3    C3            2838     	CLR	C
04E4    E524          2839     	MOV	A, CURRENT_PWM					; Check against limit
04E6    955C          2840     	SUBB	A, PWM_LIMIT
04E8    4003          2841     	JC	($+5)						; If current pwm below limit - branch
                      2842     
04EA    855C25        2843     	MOV	CURRENT_PWM_LIMITED, PWM_LIMIT	; Limit pwm
                      2844     ENDIF
                      2845     
                      2846     T2_INT_PWM_EXIT: 	
                      2847     	; Check if high byte flag is set
04ED    20CF09        2848     	JB	TF2H, T2H_INT		
04F0    D0E0          2849     	POP	ACC			; Restore preserved registers
04F2    D0D0          2850     	POP	PSW
04F4    C2D3          2851     	CLR	PSW.3		; Select register bank 0 for main program routines	
04F6    D2AF          2852     	SETB	EA			; Enable all interrupts
04F8    32            2853     	RETI
                      2854     
                      2855     T2H_INT: 
                      2856     	; High byte interrupt (happens every 32ms)
04F9    C2CF          2857     	CLR	TF2H					; Clear interrupt flag
04FB    7801          2858     MOV R0 , # 1 
                      2859     	; Check RC pulse timeout counter (used here for PPM only)
04FD    E528          2860     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04FF    6008          2861     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      2862     
                      2863     	; Decrement timeout counter (if PPM)
0501    741F          2864     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0503    552E          2865     	ANL	A, FLAGS3					; Check pwm frequency flags
0505    7002          2866     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      2867     
0507    1528          2868     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      2869     
                      2870     T2H_INT_RCP_STOP_CHECK: 
                      2871     	; Check RC pulse against stop value
0509    C3            2872     	CLR	C
050A    E558          2873     	MOV	A, NEW_RCP			; Load new pulse value
050C    9401          2874     SUBB A , # 1 
050E    4005          2875     	JC	T2H_INT_RCP_STOP
                      2876     
                      2877     	; RC pulse higher than stop value, reset stop counter
0510    755B00        2878     	MOV	RCP_STOP_CNT, #0		; Reset rcp stop counter
0513    A11C          2879     	AJMP	T2H_INT_RCP_GOV_PWM
                      2880     
                      2881     T2H_INT_RCP_STOP: 	
                      2882     	; RC pulse less than stop value, increment stop counter
0515    E55B          2883     	MOV	A, RCP_STOP_CNT		; Load rcp stop counter
0517    04            2884     	INC	A					; Check if counter is max
0518    6002          2885     	JZ	T2H_INT_RCP_GOV_PWM		; Branch if counter is equal to max
                      2886     
051A    055B          2887     	INC	RCP_STOP_CNT			; Increment stop counter 
                      2888     
                      2889     T2H_INT_RCP_GOV_PWM: 
                      2890     IF MODE == 0	; Main
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	CJNE	@TEMP2, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	CJNE	@TEMP2, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               
                               	INC	SPOOLUP_LIMIT_CNT				; Increment spoolup count
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	JNZ	($+4)						; Wrapped?
                               
                               	DEC	SPOOLUP_LIMIT_CNT				; Yes - decrement
                               
                               	DJNZ	SPOOLUP_LIMIT_SKIP, T2H_INT_RCP_EXIT	; Jump if skip count is not reached
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Reset skip count. Default is fast spoolup
                               	MOV	TEMP1, #3						; Default fast increase
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(3*MAIN_SPOOLUP_TIME)		; No spoolup until "30"*32ms
                               	JC	T2H_INT_RCP_EXIT
                               
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(10*MAIN_SPOOLUP_TIME)		; Slow spoolup until "100"*32ms
                               	JNC	T2H_INT_RCP_LIMIT_MIDDLE_RAMP
                               
                               	MOV	TEMP1, #1						; Slow initial spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #3			
                               	JMP	T2H_INT_RCP_SET_LIMIT
                               
                               T2H_INT_RCP_LIMIT_MIDDLE_RAMP:
                               	CLR	C
                               	MOV	A, SPOOLUP_LIMIT_CNT
                               	SUBB	A, #(15*MAIN_SPOOLUP_TIME)		; Faster spoolup until "150"*32ms
                               	JNC	T2H_INT_RCP_SET_LIMIT
                               
                               	MOV	TEMP1, #1						; Faster middle spoolup
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               T2H_INT_RCP_SET_LIMIT:
                               	; Do not increment spoolup limit if higher pwm is not requested, unless governor is active
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP
                               	SUBB	A, CURRENT_PWM
                               	JC	T2H_INT_RCP_INC_LIMIT			; If Current_Pwm is larger than Pwm_Limit_Spoolup - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JNZ	T2H_INT_RCP_INC_LIMIT			; Yes - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, CURRENT_PWM	; Set limit to what current pwm is
                               	MOV	A, SPOOLUP_LIMIT_CNT			; Check if spoolup limit count is 255. If it is, ten this is a "bailout" ramp
                               	INC	A
                               	JZ	($+5)
                               
                               	MOV	SPOOLUP_LIMIT_CNT, #(3*MAIN_SPOOLUP_TIME)	; Stay in an early part of the spoolup sequence (unless "bailout" ramp)
                               
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			; Set skip count
                               	MOV	GOVERNOR_REQ_PWM, #60			; Set governor requested speed to ensure that it requests higher speed
                               									; 20=Fail on jerk when governor activates
                               									; 30=Ok
                               									; 100=Fail on small governor settling overshoot on low headspeeds
                               									; 200=Fail on governor settling overshoot
                               	JMP	T2H_INT_RCP_EXIT				; Exit
                               
                               T2H_INT_RCP_INC_LIMIT:
                               	CLR	C
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm
                               	ADD	A, TEMP1
                               	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH
                               	AJMP	T2H_INT_RCP_EXIT
                               
                               T2H_INT_RCP_NO_LIMIT:
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               ENDIF
                      3007     IF MODE == 2	; Multi
051C    E55D          3008     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
051E    C3            3009     	CLR	C
051F    240A          3010     	ADD	A, #10
0521    5005          3011     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      3012     
0523    755DFF        3013     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
0526    A12A          3014     	AJMP	T2H_INT_RCP_EXIT
                      3015     
                      3016     T2H_INT_RCP_NO_LIMIT: 
0528    F55D          3017     	MOV	PWM_LIMIT_SPOOLUP, A
                      3018     ENDIF
                      3019     
                      3020     T2H_INT_RCP_EXIT: 
052A    D0E0          3021     	POP	ACC			; Restore preserved registers
052C    D0D0          3022     	POP	PSW
052E    C2D3          3023     	CLR	PSW.3		; Select register bank 0 for main program routines	
0530    D2AF          3024     	SETB	EA			; Enable all interrupts
0532    32            3025     	RETI
                      3026     
                      3027     
                      3028     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3029     ;
                      3030     ; Timer3 interrupt routine
                      3031     ;
                      3032     ; No assumptions
                      3033     ;
                      3034     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3035     T3_INT: 	; Used for commutation timing
0533    C2AF          3036     	CLR 	EA			; Disable all interrupts
0535    53917F        3037     	ANL	TMR3CN, #07FH		; Clear interrupt flag
0538    C258          3038     CLR FLAGS0 . 0 
053A    D2AF          3039     	SETB	EA			; Enable all interrupts
053C    32            3040     	RETI
                      3041     
                      3042     
                      3043     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3044     ;
                      3045     ; PCA interrupt routine
                      3046     ;
                      3047     ; No assumptions
                      3048     ;
                      3049     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3050     PCA_INT: 	; Used for RC pulse timing
053D    C2AF          3051     	CLR 	EA			; Disable all interrupts
053F    C0D0          3052     	PUSH	PSW			; Preserve registers through interrupt
0541    C0E0          3053     	PUSH	ACC
0543    C0F0          3054     	PUSH	B
0545    D2D3          3055     	SETB	PSW.3		; Select register bank 1 for interrupt routines
                      3056     	; Get the PCA counter values
                      3057     	GET_RCP_CAPTURE_VALUES
0547    A8FB          3057+1   MOV R0 , PCA0CPL0  ; GET PCA CAPTURE VALUES
0549    A9FC          3057+1   MOV R1 , PCA0CPH0 
                      3058     	; Clear interrupt flag
                      3059     	RCP_CLEAR_INT_FLAG 				
054B    C2D8          3059+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      3060     	; Check which edge it is
054D    306902        3061     JNB FLAGS2 . 1 , ( $+5 ) 
0550    A1A0          3062     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      3063     
                      3064     	RCP_INT_SECOND					; Yes - set second edge trig
0552    53DACF        3064+1   ANL PCA0CPM0 , # 0CFH 
0555    207603        3064+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0558    43DA10        3064+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
055B    307603        3064+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
055E    43DA20        3064+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0561    D269          3065     SETB FLAGS2 . 1 
                      3066     	; Read RC signal level
                      3067     	READ_RCP_INT			
0563    E580          3067+1   MOV A , P0 
0565    307601        3067+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0568    F4            3067+1   CPL A  ; YES - INVERT
                      3068     	; Test RC signal level
0569    20E502        3069     JB ACC . 5 , ( $+5 ) 
056C    A174          3070     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      3071     
                      3072     	; RC pulse was high, store RC pulse start timestamp
056E    8826          3073     MOV RCP_PREV_EDGE_L , R0 
0570    8927          3074     MOV RCP_PREV_EDGE_H , R1 
0572    E140          3075     	AJMP	PCA_INT_EXIT				; Exit
                      3076     
                      3077     PCA_INT_FAIL_MINIMUM: 
                      3078     	; Prepare for next interrupt
                      3079     	RCP_INT_FIRST					; Set interrupt trig to first again
0574    53DACF        3079+1   ANL PCA0CPM0 , # 0CFH 
0577    207603        3079+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
057A    43DA20        3079+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
057D    307603        3079+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0580    43DA10        3079+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      3080     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0583    C2D8          3080+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0585    C269          3081     CLR FLAGS2 . 1 
0587    741F          3082     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0589    552E          3083     	ANL	A, FLAGS3					; Check pwm frequency flags
058B    7002          3084     	JNZ	($+4)					; If a flag is set (PWM) - proceed
                      3085     
058D    E126          3086     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      3087     
058F    7800          3088     MOV R0 , # 0 
                      3089     	READ_RCP_INT 					; Test RC signal level again
0591    E580          3089+1   MOV A , P0 
0593    307601        3089+1   JNB FLAGS3 . 6 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0596    F4            3089+1   CPL A  ; YES - INVERT
0597    30E502        3090     JNB ACC . 5 , ( $+5 ) 
059A    E126          3091     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      3092     
059C    8858          3093     MOV NEW_RCP , R0 
059E    E126          3094     	AJMP	PCA_INT_SET_TIMEOUT			; Set new timeout and exit
                      3095     
                      3096     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      3097     	; Prepare for next interrupt
                      3098     	RCP_INT_FIRST 					; Set first edge trig
05A0    53DACF        3098+1   ANL PCA0CPM0 , # 0CFH 
05A3    207603        3098+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05A6    43DA20        3098+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
05A9    307603        3098+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05AC    43DA10        3098+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05AF    C269          3099     CLR FLAGS2 . 1 
                      3100     	; Check if pwm frequency shall be measured
05B1    205902        3101     JB FLAGS0 . 1 , ( $+5 ) 
05B4    C15A          3102     	AJMP	PCA_INT_FALL				; No - skip measurements
                      3103     
                      3104     	; Set second edge trig only during pwm frequency measurement
                      3105     	RCP_INT_SECOND 				; Set second edge trig
05B6    53DACF        3105+1   ANL PCA0CPM0 , # 0CFH 
05B9    207603        3105+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
05BC    43DA10        3105+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
05BF    307603        3105+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
05C2    43DA20        3105+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      3106     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
05C5    C2D8          3106+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
05C7    D269          3107     SETB FLAGS2 . 1 
                      3108     	; Store edge data to RAM
05C9    8853          3109     MOV RCP_EDGE_L , R0 
05CB    8954          3110     MOV RCP_EDGE_H , R1 
                      3111     	; Calculate pwm frequency
05CD    C3            3112     	CLR	C
05CE    E8            3113     MOV A , R0 
05CF    9551          3114     	SUBB	A, RCP_PREPREV_EDGE_L	
05D1    F8            3115     MOV R0 , A 
05D2    E9            3116     MOV A , R1 
05D3    9552          3117     	SUBB	A, RCP_PREPREV_EDGE_H
05D5    F9            3118     MOV R1 , A 
05D6    E4            3119     	CLR	A
05D7    FB            3120     MOV R3 , A 
05D8    7AFA          3121     MOV R2 , # 250 
                      3122     	; Check if pwm frequency is 12kHz
05DA    C3            3123     	CLR	C
05DB    E8            3124     MOV A , R0 
05DC    94C8          3125     	SUBB	A, #LOW(200)				; If below 100us, 12kHz pwm is assumed
05DE    E9            3126     MOV A , R1 
05DF    9400          3127     	SUBB	A, #HIGH(200)
05E1    5008          3128     	JNC	PCA_INT_CHECK_8KHZ
                      3129     
05E3    E4            3130     	CLR	A
05E4    D2E4          3131     SETB ACC . 4 
05E6    FB            3132     MOV R3 , A 
05E7    7A0A          3133     MOV R2 , # 10 
05E9    C12D          3134     	AJMP	PCA_INT_RESTORE_EDGE
                      3135     
                      3136     PCA_INT_CHECK_8KHZ: 
                      3137     	; Check if pwm frequency is 8kHz
05EB    C3            3138     	CLR	C
05EC    E8            3139     MOV A , R0 
05ED    9468          3140     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
05EF    E9            3141     MOV A , R1 
05F0    9401          3142     	SUBB	A, #HIGH(360)
05F2    5008          3143     	JNC	PCA_INT_CHECK_4KHZ
                      3144     
05F4    E4            3145     	CLR	A
05F5    D2E3          3146     SETB ACC . 3 
05F7    FB            3147     MOV R3 , A 
05F8    7A0F          3148     MOV R2 , # 15 
05FA    C12D          3149     	AJMP	PCA_INT_RESTORE_EDGE
                      3150     
                      3151     PCA_INT_CHECK_4KHZ: 
                      3152     	; Check if pwm frequency is 4kHz
05FC    C3            3153     	CLR	C
05FD    E8            3154     MOV A , R0 
05FE    94D0          3155     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
0600    E9            3156     MOV A , R1 
0601    9402          3157     	SUBB	A, #HIGH(720)
0603    5008          3158     	JNC	PCA_INT_CHECK_2KHZ
                      3159     
0605    E4            3160     	CLR	A
0606    D2E2          3161     SETB ACC . 2 
0608    FB            3162     MOV R3 , A 
0609    7A1E          3163     MOV R2 , # 30 
060B    C12D          3164     	AJMP	PCA_INT_RESTORE_EDGE
                      3165     
                      3166     PCA_INT_CHECK_2KHZ: 
                      3167     	; Check if pwm frequency is 2kHz
060D    C3            3168     	CLR	C
060E    E8            3169     MOV A , R0 
060F    94A0          3170     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
0611    E9            3171     MOV A , R1 
0612    9405          3172     	SUBB	A, #HIGH(1440)
0614    5008          3173     	JNC	PCA_INT_CHECK_1KHZ
                      3174     
0616    E4            3175     	CLR	A
0617    D2E1          3176     SETB ACC . 1 
0619    FB            3177     MOV R3 , A 
061A    7A3C          3178     MOV R2 , # 60 
061C    C12D          3179     	AJMP	PCA_INT_RESTORE_EDGE
                      3180     
                      3181     PCA_INT_CHECK_1KHZ: 
                      3182     	; Check if pwm frequency is 1kHz
061E    C3            3183     	CLR	C
061F    E8            3184     MOV A , R0 
0620    9498          3185     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
0622    E9            3186     MOV A , R1 
0623    9408          3187     	SUBB	A, #HIGH(2200)
0625    5006          3188     	JNC	PCA_INT_RESTORE_EDGE
                      3189     
0627    E4            3190     	CLR	A
0628    D2E0          3191     SETB ACC . 0 
062A    FB            3192     MOV R3 , A 
062B    7A78          3193     MOV R2 , # 120 
                      3194     
                      3195     PCA_INT_RESTORE_EDGE: 
                      3196     	; Calculate difference between this period and previous period
062D    C3            3197     	CLR	C
062E    E8            3198     MOV A , R0 
062F    9555          3199     	SUBB	A, RCP_PREV_PERIOD_L
0631    FC            3200     MOV R4 , A 
0632    E9            3201     MOV A , R1 
0633    9556          3202     	SUBB	A, RCP_PREV_PERIOD_H
0635    FD            3203     MOV R5 , A 
                      3204     	; Make positive
0636    30E708        3205     	JNB	ACC.7, PCA_INT_CHECK_DIFF
0639    EC            3206     MOV A , R4 
063A    F4            3207     	CPL	A
063B    2401          3208     	ADD	A, #1
063D    FC            3209     MOV R4 , A 
063E    ED            3210     MOV A , R5 
063F    F4            3211     	CPL	A
0640    FD            3212     MOV R5 , A 
                      3213     
                      3214     PCA_INT_CHECK_DIFF: 
                      3215     	; Check difference
0641    755700        3216     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
0644    7008          3217     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      3218     
0646    C3            3219     	CLR	C
0647    EC            3220     MOV A , R4 
0648    9A            3221     SUBB A , R2 
0649    5003          3222     	JNC	PCA_INT_STORE_DATA
                      3223     
064B    755701        3224     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      3225     
                      3226     PCA_INT_STORE_DATA: 
                      3227     	; Store previous period
064E    8855          3228     MOV RCP_PREV_PERIOD_L , R0 
0650    8956          3229     MOV RCP_PREV_PERIOD_H , R1 
                      3230     	; Restore edge data from RAM
0652    A853          3231     MOV R0 , RCP_EDGE_L 
0654    A954          3232     MOV R1 , RCP_EDGE_H 
                      3233     	; Store pre previous edge
0656    8851          3234     MOV RCP_PREPREV_EDGE_L , R0 
0658    8952          3235     MOV RCP_PREPREV_EDGE_H , R1 
                      3236     
                      3237     PCA_INT_FALL: 
                      3238     	; RC pulse edge was second, calculate new pulse length
065A    C3            3239     	CLR	C
065B    E8            3240     MOV A , R0 
065C    9526          3241     	SUBB	A, RCP_PREV_EDGE_L	
065E    F8            3242     MOV R0 , A 
065F    E9            3243     MOV A , R1 
0660    9527          3244     	SUBB	A, RCP_PREV_EDGE_H
0662    F9            3245     MOV R1 , A 
0663    307402        3246     JNB FLAGS3 . 4 , ( $+5 ) 
0666    C1F9          3247     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
0668    307302        3248     JNB FLAGS3 . 3 , ( $+5 ) 
066B    C1F9          3249     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      3250     
066D    307202        3251     JNB FLAGS3 . 2 , ( $+5 ) 
0670    C1F2          3252     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3253     
0672    E9            3254     MOV A , R1 
0673    C3            3255     	CLR	C
0674    13            3256     	RRC	A
0675    F9            3257     MOV R1 , A 
0676    E8            3258     MOV A , R0 
0677    13            3259     	RRC	A
0678    F8            3260     MOV R0 , A 
                      3261     
0679    307102        3262     JNB FLAGS3 . 1 , ( $+5 ) 
067C    C1F2          3263     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3264     
067E    E9            3265     MOV A , R1 
067F    C3            3266     	CLR	C
0680    13            3267     	RRC	A
0681    F9            3268     MOV R1 , A 
0682    E8            3269     MOV A , R0 
0683    13            3270     	RRC	A
0684    F8            3271     MOV R0 , A 
                      3272     
0685    307002        3273     JNB FLAGS3 . 0 , ( $+5 ) 
0688    C1F2          3274     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      3275     
068A    E9            3276     MOV A , R1 
068B    C3            3277     	CLR	C
068C    13            3278     	RRC	A
068D    FD            3279     MOV R5 , A 
068E    E8            3280     MOV A , R0 
068F    13            3281     	RRC	A
0690    FC            3282     MOV R4 , A 
                      3283     	; Skip range limitation if pwm frequency measurement
0691    205918        3284     JB FLAGS0 . 1 , PCA_INT_PPM_CHECK_FULL_RANGE 
                      3285     
                      3286     	; Check if 2160us or above (in order to ignore false pulses)
0694    C3            3287     	CLR	C
0695    EC            3288     MOV A , R4 
0696    941C          3289     	SUBB	A, #28
0698    ED            3290     MOV A , R5 
0699    9402          3291     	SUBB A, #2
069B    4003          3292     	JC	($+5)						; No - proceed
                      3293     
069D    020726        3294     	LJMP	PCA_INT_SET_TIMEOUT				; Yes - ignore pulse
                      3295     
                      3296     	; Check if below 800us (in order to ignore false pulses)
06A0    ED            3297     MOV A , R5 
06A1    7009          3298     	JNZ	PCA_INT_PPM_CHECK_FULL_RANGE
                      3299     
06A3    C3            3300     	CLR	C
06A4    EC            3301     MOV A , R4 
06A5    94C8          3302     	SUBB	A, #200
06A7    5003          3303     	JNC	PCA_INT_PPM_CHECK_FULL_RANGE		; No - proceed
                      3304     
06A9    020740        3305     	JMP	PCA_INT_EXIT					; Yes - ignore pulse
                      3306     
                      3307     PCA_INT_PPM_CHECK_FULL_RANGE: 
                      3308     	; Calculate "1000us" plus throttle minimum
06AC    7400          3309     	MOV	A, #0						; Set 1000us as default minimum
06AE    207703        3310     JB FLAGS3 . 7 , PCA_INT_PPM_CALCULATE 
                      3311     
06B1    7896          3312     MOV R0 , # PGM_PPM_MIN_THROTTLE 
06B3    E6            3313     MOV A , @ R0 
                      3314     
                      3315     PCA_INT_PPM_CALCULATE: 
06B4    24FA          3316     	ADD	A, #250
06B6    FE            3317     MOV R6 , A 
06B7    E4            3318     	CLR	A
06B8    3400          3319     	ADDC	A, #0
06BA    FF            3320     MOV R7 , A 
                      3321     
06BB    C3            3322     	CLR	C
06BC    EC            3323     MOV A , R4 
06BD    9E            3324     SUBB A , R6 
06BE    FC            3325     MOV R4 , A 
06BF    ED            3326     MOV A , R5 
06C0    9F            3327     SUBB A , R7 
06C1    FD            3328     MOV R5 , A 
06C2    5006          3329     	JNC	PCA_INT_PPM_NEG_CHECKED			; Is result negative?
                      3330     
06C4    7800          3331     MOV R0 , # 0 
06C6    7900          3332     MOV R1 , # 0 
06C8    C1F9          3333     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      3334     
                      3335     PCA_INT_PPM_NEG_CHECKED: 
06CA    C3            3336     	CLR	C							; Check that RC pulse is within legal range (1000+4*255=2020)
06CB    EC            3337     MOV A , R4 
06CC    94FF          3338     SUBB A , # 255 
06CE    ED            3339     MOV A , R5 
06CF    9400          3340     	SUBB	A, #0
06D1    4006          3341     	JC	PCA_INT_PPM_MAX_CHECKED
                      3342     
06D3    78FF          3343     MOV R0 , # 255 
06D5    7900          3344     MOV R1 , # 0 
06D7    C1F9          3345     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      3346     
                      3347     PCA_INT_PPM_MAX_CHECKED: 
06D9    EC            3348     MOV A , R4 
06DA    856CF0        3349     	MOV	B, PPM_THROTTLE_GAIN
06DD    A4            3350     	MUL	AB
06DE    C5F0          3351     	XCH	A, B
06E0    A2F7          3352     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
06E2    33            3353     	RLC	A
06E3    F8            3354     MOV R0 , A 
06E4    7900          3355     MOV R1 , # 0 
06E6    4003          3356     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
                      3357     	
06E8    020715        3358     	JMP	PCA_INT_LIMITED			
                      3359     
                      3360     PCA_INT_PPM_LIMIT_AFTER_MULT: 
06EB    78FF          3361     MOV R0 , # 255 
06ED    7900          3362     MOV R1 , # 0 
06EF    020715        3363     	JMP	PCA_INT_LIMITED			
                      3364     
                      3365     PCA_INT_PWM_DIVIDE: 
06F2    E9            3366     MOV A , R1 
06F3    C3            3367     	CLR	C
06F4    13            3368     	RRC	A
06F5    F9            3369     MOV R1 , A 
06F6    E8            3370     MOV A , R0 
06F7    13            3371     	RRC	A
06F8    F8            3372     MOV R0 , A 
                      3373     
                      3374     PCA_INT_PWM_DIVIDE_DONE: 
06F9    30740E        3375     JNB FLAGS3 . 4 , PCA_INT_CHECK_LEGAL_RANGE 
06FC    E9            3376     MOV A , R1 
06FD    6002          3377     	JZ	($+4)
                      3378     
06FF    78FF          3379     MOV R0 , # 255 
                      3380     
0701    C3            3381     	CLR	C
0702    E8            3382     MOV A , R0 
0703    13            3383     	RRC	A
0704    38            3384     ADDC A , R0 
0705    F8            3385     MOV R0 , A 
0706    E4            3386     	CLR	A
0707    3400          3387     	ADDC	A, #0
0709    F9            3388     MOV R1 , A 
                      3389     
                      3390     PCA_INT_CHECK_LEGAL_RANGE: 
                      3391     	; Check that RC pulse is within legal range
070A    C3            3392     	CLR	C
070B    E8            3393     MOV A , R0 
070C    94FF          3394     SUBB A , # 255 
070E    E9            3395     MOV A , R1 
070F    9400          3396     	SUBB	A, #0
0711    4002          3397     	JC	PCA_INT_LIMITED
                      3398     
0713    78FF          3399     MOV R0 , # 255 
                      3400     
                      3401     PCA_INT_LIMITED: 
                      3402     	; RC pulse value accepted
0715    8858          3403     MOV NEW_RCP , R0 
0717    D268          3404     SETB FLAGS2 . 0 
0719    205902        3405     JB FLAGS0 . 1 , ( $+5 ) 
071C    E126          3406     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      3407     
071E    741F          3408     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0720    F4            3409     	CPL	A
0721    552E          3410     	ANL	A, FLAGS3					; Clear all pwm frequency flags
0723    4B            3411     ORL A , R3 
0724    F52E          3412     	MOV	FLAGS3, A
                      3413     
                      3414     PCA_INT_SET_TIMEOUT: 
0726    752818        3415     MOV RCP_TIMEOUT_CNT , # 24 
0729    741F          3416     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
072B    552E          3417     	ANL	A, FLAGS3					; Check pwm frequency flags
072D    7003          3418     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      3419     
072F    75280A        3420     MOV RCP_TIMEOUT_CNT , # 10 
                      3421     
                      3422     PCA_INT_PPM_TIMEOUT_SET: 
0732    305902        3423     JNB FLAGS0 . 1 , ( $+5 ) 
0735    E140          3424     	AJMP PCA_INT_EXIT				; Yes - exit
                      3425     
0737    741F          3426     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0739    552E          3427     	ANL	A, FLAGS3					; Check pwm frequency flags
073B    6003          3428     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      3429     
                      3430     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
073D    53DAFE        3430+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      3431     
                      3432     PCA_INT_EXIT: 	; Exit interrupt routine	
0740    752906        3433     MOV RCP_SKIP_CNT , # 6 
0743    741F          3434     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0745    552E          3435     	ANL	A, FLAGS3					; Check pwm frequency flags
0747    7003          3436     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      3437     
0749    75290A        3438     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      3439     
074C    D0F0          3440     	POP	B			; Restore preserved registers
074E    D0E0          3441     	POP	ACC			
0750    D0D0          3442     	POP	PSW
0752    C2D3          3443     	CLR	PSW.3		; Select register bank 0 for main program routines	
0754    D2AF          3444     	SETB	EA			; Enable all interrupts
0756    32            3445     	RETI
                      3446     
                      3447     
                      3448     
                      3449     
                      3450     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3451     ;
                      3452     ; Wait xms ~(x*4*250)  (Different entry points)	
                      3453     ;
                      3454     ; No assumptions
                      3455     ;
                      3456     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3457     WAIT1MS: 	
0757    7901          3458     MOV R1 , # 1 
0759    E16F          3459     	AJMP	WAITXMS_O
                      3460     
                      3461     WAIT3MS: 	
075B    7903          3462     MOV R1 , # 3 
075D    E16F          3463     	AJMP	WAITXMS_O
                      3464     
                      3465     WAIT10MS: 	
075F    790A          3466     MOV R1 , # 10 
0761    E16F          3467     	AJMP	WAITXMS_O
                      3468     
                      3469     WAIT30MS: 	
0763    791E          3470     MOV R1 , # 30 
0765    E16F          3471     	AJMP	WAITXMS_O
                      3472     
                      3473     WAIT100MS: 	
0767    7964          3474     MOV R1 , # 100 
0769    E16F          3475     	AJMP	WAITXMS_O
                      3476     
                      3477     WAIT200MS: 	
076B    79C8          3478     MOV R1 , # 200 
076D    E16F          3479     	AJMP	WAITXMS_O
                      3480     
                      3481     WAITXMS_O: 	; Outer loop
076F    7817          3482     MOV R0 , # 23 
                      3483     WAITXMS_M: 	; Middle loop
0771    E4            3484     	CLR	A
0772    D5E0FD        3485      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
0775    D8FA          3486     DJNZ R0 , WAITXMS_M 
0777    D9F6          3487     DJNZ R1 , WAITXMS_O 
0779    22            3488     	RET
                      3489     
                      3490     
                      3491     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3492     ;
                      3493     ; Beeper routines (4 different entry points) 
                      3494     ;
                      3495     ; No assumptions
                      3496     ;
                      3497     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3498     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
077A    7A14          3499     MOV R2 , # 20 
077C    7B78          3500     MOV R3 , # 120 
077E    020796        3501     	JMP	BEEP
                      3502     
                      3503     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
0781    7A10          3504     MOV R2 , # 16 
0783    7B8C          3505     MOV R3 , # 140 
0785    020796        3506     	JMP	BEEP
                      3507     
                      3508     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
0788    7A0D          3509     MOV R2 , # 13 
078A    7BB4          3510     MOV R3 , # 180 
078C    020796        3511     	JMP	BEEP
                      3512     
                      3513     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
078F    7A0B          3514     MOV R2 , # 11 
0791    7BC8          3515     MOV R3 , # 200 
0793    020796        3516     	JMP	BEEP
                      3517     
                      3518     BEEP: 	; Beep loop start
0796    AC25          3519     MOV R4 , CURRENT_PWM_LIMITED 
0798    752501        3520     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
079B    7902          3521     MOV R1 , # 2 
                      3522     BEEP_ONOFF: 
079D    B275          3523     CPL FLAGS3 . 5 
079F    E4            3524     	CLR	A
                      3525     	BPFET_OFF			; BpFET off
07A0    C294          3525+1   CLR P1 . 4 
07A2    D5E0FD        3526     	DJNZ	ACC, $		; Allow some time after pfet is turned off
                      3527     	BNFET_ON			; BnFET on (in order to charge the driver of the BpFET)
07A5    E525          3527+1   MOV A , CURRENT_PWM_LIMITED 
07A7    6002          3527+1   JZ ( $+4 ) 
07A9    D295          3527+1   SETB P1 . 5 
07AB    D5E0FD        3528     	DJNZ	ACC, $		; Let the nfet be turned on a while
                      3529     	BNFET_OFF			; BnFET off again
07AE    C295          3529+1   CLR P1 . 5 
07B0    D5E0FD        3530     	DJNZ	ACC, $		; Allow some time after nfet is turned off
                      3531     	BPFET_ON			; BpFET on
07B3    D294          3531+1   SETB P1 . 4 
07B5    D5E0FD        3532     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      3533     	; Turn on nfet
                      3534     	ANFET_ON			; AnFET on
07B8    E525          3534+1   MOV A , CURRENT_PWM_LIMITED 
07BA    600A          3534+1   JZ ( $+12 ) 
07BC    207502        3534+1   JB FLAGS3 . 5 , ( $+5 ) 
07BF    D292          3534+1   SETB P1 . 2 
07C1    307502        3534+1   JNB FLAGS3 . 5 , ( $+5 ) 
07C4    D296          3534+1   SETB P1 . 6 
07C6    E56D          3535     	MOV	A, BEEP_STRENGTH
07C8    D5E0FD        3536     	DJNZ	ACC, $		
                      3537     	; Turn off nfet
                      3538     	ANFET_OFF			; AnFET off
07CB    207502        3538+1   JB FLAGS3 . 5 , ( $+5 ) 
07CE    C292          3538+1   CLR P1 . 2 
07D0    307502        3538+1   JNB FLAGS3 . 5 , ( $+5 ) 
07D3    C296          3538+1   CLR P1 . 6 
07D5    7496          3539     	MOV	A, #150		; 25s off
07D7    D5E0FD        3540     	DJNZ	ACC, $		
07DA    D9C1          3541     DJNZ R1 , BEEP_ONOFF 
                      3542     	; Copy variable
07DC    EA            3543     MOV A , R2 
07DD    F8            3544     MOV R0 , A 
                      3545     BEEP_OFF: 		; Fets off loop
07DE    D5E0FD        3546     	DJNZ	ACC, $
07E1    D8FB          3547     DJNZ R0 , BEEP_OFF 
                      3548     
                      3549     BEEP_RECHARGE_DONE: 
07E3    DBB1          3550     DJNZ R3 , BEEP 
                      3551     	BPFET_OFF			; BpFET off
07E5    C294          3551+1   CLR P1 . 4 
07E7    8C25          3552     MOV CURRENT_PWM_LIMITED , R4 
07E9    22            3553     	RET
                      3554     
                      3555     
                      3556     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3557     ;
                      3558     ; Division 16bit unsigned by 16bit unsigned
                      3559     ;
                      3560     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                      3561     ; Result will be in Temp2/Temp1
                      3562     ;
                      3563     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3564     DIV_U16_BY_U16: 	
07EA    C3            3565     	CLR	C       
07EB    7C00          3566     MOV R4 , # 0 
07ED    7D00          3567     MOV R5 , # 0 
07EF    75F000        3568     	MOV	B, #0
                      3569     DIV_U16_BY_U16_DIV1: 
07F2    05F0          3570     	INC	B      			; Increment counter for each left shift
07F4    EA            3571     MOV A , R2 
07F5    33            3572     	RLC	A      		
07F6    FA            3573     MOV R2 , A 
07F7    EB            3574     MOV A , R3 
07F8    33            3575     	RLC	A      	  	
07F9    FB            3576     MOV R3 , A 
07FA    50F6          3577     	JNC	DIV_U16_BY_U16_DIV1	; Repeat until carry flag is set from high-byte
                      3578     DIV_U16_BY_U16_DIV2:         
07FC    EB            3579     MOV A , R3 
07FD    13            3580     	RRC	A      
07FE    FB            3581     MOV R3 , A 
07FF    EA            3582     MOV A , R2 
0800    13            3583     	RRC	A      
0801    FA            3584     MOV R2 , A 
0802    C3            3585     	CLR	C      
0803    E9            3586     MOV A , R1 
0804    FF            3587     MOV R7 , A 
0805    E8            3588     MOV A , R0 
0806    FE            3589     MOV R6 , A 
0807    E8            3590     MOV A , R0 
0808    9A            3591     SUBB A , R2 
0809    F8            3592     MOV R0 , A 
080A    E9            3593     MOV A , R1 
080B    9B            3594     SUBB A , R3 
080C    F9            3595     MOV R1 , A 
080D    5004          3596     	JNC	DIV_U16_BY_U16_DIV3	; If carry flag is NOT set, result is 1
080F    EF            3597     MOV A , R7 
0810    F9            3598     MOV R1 , A 
0811    EE            3599     MOV A , R6 
0812    F8            3600     MOV R0 , A 
                      3601     DIV_U16_BY_U16_DIV3: 
0813    B3            3602     	CPL	C      			; Invert carry, so it can be directly copied into result
0814    EC            3603     MOV A , R4 
0815    33            3604     	RLC	A      			; Shift carry flag into temporary result
0816    FC            3605     MOV R4 , A 
0817    ED            3606     MOV A , R5 
0818    33            3607     	RLC	A
0819    FD            3608     MOV R5 , A 
081A    D5F0DF        3609     	DJNZ	B, DIV_U16_BY_U16_DIV2 	;Now count backwards and repeat until "B" is zero
081D    ED            3610     MOV A , R5 
081E    F9            3611     MOV R1 , A 
081F    EC            3612     MOV A , R4 
0820    F8            3613     MOV R0 , A 
0821    22            3614     	RET
                      3615     
                      3616     
                      3617     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3618     ;
                      3619     ; Multiplication 16bit signed by 8bit unsigned
                      3620     ;
                      3621     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      3622     ; Result will be in Temp2/Temp1. Result will divided by 16
                      3623     ;
                      3624     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3625     MULT_S16_BY_U8_DIV_16: 
0822    E8            3626     MOV A , R0 
0823    89F0          3627     MOV B , R1 
0825    8A20          3628     MOV BIT_ACCESS , R2 
0827    D2D4          3629     	SETB	PSW.4		; Select register bank 2 for math routines
0829    F8            3630     MOV R0 , A 
082A    A9F0          3631     MOV R1 , B 
082C    7B00          3632     MOV R3 , # 0 
082E    30F70B        3633     	JNB	B.7, MULT_S16_BY_U8_POSITIVE	
                      3634     
0831    7BFF          3635     MOV R3 , # 0FFH 
0833    F4            3636     	CPL	A
0834    2401          3637     	ADD	A, #1
0836    F8            3638     MOV R0 , A 
0837    E9            3639     MOV A , R1 
0838    F4            3640     	CPL	A
0839    3400          3641     	ADDC	A, #0
083B    F9            3642     MOV R1 , A 
                      3643     MULT_S16_BY_U8_POSITIVE: 
083C    E8            3644     MOV A , R0 
083D    8520F0        3645     	MOV	B, BIT_ACCESS
0840    A4            3646     	MUL	AB
0841    ADF0          3647     MOV R5 , B 
0843    F8            3648     MOV R0 , A 
0844    E9            3649     MOV A , R1 
0845    8520F0        3650     	MOV	B, BIT_ACCESS
0848    A4            3651     	MUL	AB
0849    AFF0          3652     MOV R7 , B 
084B    FE            3653     MOV R6 , A 
084C    ED            3654     MOV A , R5 
084D    2E            3655     ADD A , R6 
084E    F9            3656     MOV R1 , A 
084F    7400          3657     	MOV	A, #0
0851    3F            3658     ADDC A , R7 
0852    FA            3659     MOV R2 , A 
0853    7C04          3660     MOV R4 , # 4 
                      3661     MULT_S16_BY_U8_DIV_LOOP: 
0855    C3            3662     	CLR	C			; Rotate right 
0856    EA            3663     MOV A , R2 
0857    13            3664     	RRC	A
0858    FA            3665     MOV R2 , A 
0859    E9            3666     MOV A , R1 
085A    13            3667     	RRC	A
085B    F9            3668     MOV R1 , A 
085C    E8            3669     MOV A , R0 
085D    13            3670     	RRC	A
085E    F8            3671     MOV R0 , A 
085F    DCF4          3672     DJNZ R4 , MULT_S16_BY_U8_DIV_LOOP 
                      3673     
0861    8BF0          3674     MOV B , R3 
0863    30F70A        3675     	JNB	B.7, MULT_S16_BY_U8_EXIT	
                      3676     
0866    E8            3677     MOV A , R0 
0867    F4            3678     	CPL	A
0868    2401          3679     	ADD	A, #1
086A    F8            3680     MOV R0 , A 
086B    E9            3681     MOV A , R1 
086C    F4            3682     	CPL	A
086D    3400          3683     	ADDC	A, #0
086F    F9            3684     MOV R1 , A 
                      3685     
                      3686     MULT_S16_BY_U8_EXIT: 
0870    E8            3687     MOV A , R0 
0871    89F0          3688     MOV B , R1 
0873    C2D4          3689     	CLR	PSW.4		; Select normal register bank
0875    F8            3690     MOV R0 , A 
0876    A9F0          3691     MOV R1 , B 
0878    22            3692     	RET
                      3693     
                      3694     
                      3695     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3696     ;
                      3697     ; Calculate governor routines
                      3698     ;
                      3699     ; No assumptions
                      3700     ;
                      3701     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      3702     ; The governor task is split into several routines in order to distribute processing time
                      3703     ;
                      3704     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3705     ; First governor routine - calculate governor target
                      3706     IF MODE <= 1	; Main or tail
                               CALC_GOVERNOR_TARGET:
                               	MOV	TEMP1, #PGM_GOV_MODE			; Governor mode?
                               	CJNE	@TEMP1, #4, GOVERNOR_SPEED_CHECK	; Yes
                               	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                               
                               GOVERNOR_SPEED_CHECK:
                               	; Stop governor for stop RC pulse	
                               	CLR	C
                               	MOV	A, NEW_RCP				; Check RC pulse against stop value
                               	SUBB	A, #RCP_STOP				; Is pulse below stop value?
                               	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                               
                               	; Skip speed check if governor is alrady active
                               	MOV	A, GOV_ACTIVE
                               	JNZ	GOVERNOR_TARGET_CALC
                               
                               	; Check speed (do not run governor for low speeds)
                               	MOV	TEMP1, #05H				; Default high range activation limit value (~62500 eRPM)
                               	CLR	C
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	CJNE	@TEMP2, #2, ($+5)
                               
                               	MOV	TEMP1, #12H				; Low range activation limit value (~17400 eRPM)
                               
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_L
                               	SUBB	A, #00H
                               	MOV	A, COMM_PERIOD4X_H
                               	SUBB	A, TEMP1
                               	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                               
                               GOVERNOR_DEACTIVATE:
                               	MOV	A, GOV_ACTIVE
                               	JZ	GOVERNOR_FIRST_DEACTIVATE_DONE; This code is executed continuously. Only execute the code below the first time
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
                               	MOV	SPOOLUP_LIMIT_CNT, #255
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               GOVERNOR_FIRST_DEACTIVATE_DONE:
                               	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
                               	CLR	A
                               	MOV	GOV_TARGET_L, A			; Set target to zero
                               	MOV	GOV_TARGET_H, A
                               	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
                               	MOV	GOV_INTEGRAL_H, A
                               	MOV	GOV_INTEGRAL_X, A
                               	MOV	GOV_ACTIVE, A
                               	JMP	CALC_GOVERNOR_TARGET_EXIT
                               
                               GOVERNOR_ACTIVATE:
                               	MOV	GOV_ACTIVE, #1
                               
                               GOVERNOR_TARGET_CALC:
                               	; Governor calculations
                               	CLR	C
                               	MOV	TEMP2, #PGM_GOV_RANGE
                               	MOV	A, @TEMP2				; Check high or low range (Temp2 has #Pgm_Gov_Range)
                               	SUBB	A, #2
                               	JZ	CALC_GOVERNOR_TARGET_LOW
                               
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	MOV	TEMP2, A				; Now 1 lsb is valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 7 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #01H				; Calculate H byte
                               	INC	A					; Add 1
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0FEH				; Calculate L byte
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               	JMP	CALC_GOVERNOR_STORE_TARGET
                               
                               CALC_GOVERNOR_TARGET_LOW:
                               	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
                               	CPL	A					; Calculate 255-pwm (invert pwm) 
                               	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
                               	RLC	A					; Msb to carry
                               	RLC	A					; To bit0
                               	RLC	A					; To bit1
                               	RLC	A					; To bit2
                               	MOV	TEMP2, A				; Now 3 lsbs are valid for H
                               	RRC	A					
                               	MOV	TEMP1, A				; Now 4 msbs are valid for L
                               	MOV	A, TEMP2
                               	ANL	A, #07H				; Calculate H byte
                               	INC	A					; Add 1
                               	INC	A					; Add 1 more
                               	MOV	TEMP2, A
                               	MOV	A, TEMP1
                               	ANL	A, #0F8H				; Calculate L byte
                               	CLR	C
                               	SUBB	A, #40H				; Subtract 0.25
                               	MOV	TEMP1, A
                               	MOV	A, TEMP2
                               	SUBB	A, #0
                               	MOV	TEMP2, A
                               
                               CALC_GOVERNOR_STORE_TARGET:
                               	; Store governor target
                               	MOV	GOV_TARGET_L, TEMP1
                               	MOV	GOV_TARGET_H, TEMP2
                               CALC_GOVERNOR_TARGET_EXIT:
                               	RET						
                               ENDIF
                      3822     IF MODE == 2	; Multi
                      3823     CALC_GOVERNOR_TARGET: 
0879    7882          3824     MOV R0 , # PGM_GOV_MODE 
087B    B60403        3825     CJNE @ R0 , # 4 , GOVERNOR_TARGET_CALC 
087E    0208D6        3826     	JMP	CALC_GOVERNOR_TARGET_EXIT		; No
                      3827     
                      3828     GOVERNOR_TARGET_CALC: 
                      3829     	; Stop governor for stop RC pulse	
0881    C3            3830     	CLR	C
0882    E558          3831     	MOV	A, NEW_RCP				; Check RC pulse against stop value
0884    9401          3832     SUBB A , # 1 
0886    4003          3833     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      3834     
0888    02089E        3835     	JMP	GOVERNOR_ACTIVATE			; No - activate
                      3836     
                      3837     GOVERNOR_DEACTIVATE: 
088B    852224        3838     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
088E    E4            3839     	CLR	A
088F    F53F          3840     	MOV	GOV_TARGET_L, A			; Set target to zero
0891    F540          3841     	MOV	GOV_TARGET_H, A
0893    F541          3842     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
0895    F542          3843     	MOV	GOV_INTEGRAL_H, A
0897    F543          3844     	MOV	GOV_INTEGRAL_X, A
0899    F548          3845     	MOV	GOV_ACTIVE, A
089B    0208D6        3846     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      3847     
                      3848     GOVERNOR_ACTIVATE: 
089E    7882          3849     MOV R0 , # PGM_GOV_MODE 
08A0    E6            3850     MOV A , @ R0 
08A1    FC            3851     MOV R4 , A 
08A2    754801        3852     	MOV	GOV_ACTIVE, #1
08A5    E522          3853     	MOV	A, REQUESTED_PWM		; Load requested pwm
08A7    F523          3854     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm
                      3855     	; Calculate comm period target 2*(51000/Requested_Pwm)
08A9    7838          3856     MOV R0 , # 38H 
08AB    79C7          3857     MOV R1 , # 0C7H 
08AD    AA3B          3858     MOV R2 , COMM_PERIOD4X_L 
08AF    AB3C          3859     MOV R3 , COMM_PERIOD4X_H 
                      3860     	; Set speed range. Bare Comm_Period4x corresponds to 400k rpm, because it is 500n units
08B1    C3            3861     	CLR	C
08B2    EB            3862     MOV A , R3 
08B3    13            3863     	RRC	A
08B4    FB            3864     MOV R3 , A 
08B5    EA            3865     MOV A , R2 
08B6    13            3866     	RRC	A
08B7    FA            3867     MOV R2 , A 
                      3868     	; Check range
08B8    EC            3869     MOV A , R4 
08B9    14            3870     	DEC	A
08BA    6013          3871     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 200k eRPM? - branch
                      3872     GOVERNOR_ACTIVATE_100K: 
08BC    C3            3873     	CLR	C
08BD    EB            3874     MOV A , R3 
08BE    13            3875     	RRC	A
08BF    FB            3876     MOV R3 , A 
08C0    EA            3877     MOV A , R2 
08C1    13            3878     	RRC	A
08C2    FA            3879     MOV R2 , A 
08C3    EC            3880     MOV A , R4 
08C4    14            3881     	DEC	A
08C5    14            3882     	DEC	A
08C6    6007          3883     	JZ	GOVERNOR_ACTIVATE_RANGE_SET	; 100k eRPM? - branch
                      3884     GOVERNOR_ACTIVATE_50K: 
08C8    C3            3885     	CLR	C
08C9    EB            3886     MOV A , R3 
08CA    13            3887     	RRC	A
08CB    FB            3888     MOV R3 , A 
08CC    EA            3889     MOV A , R2 
08CD    13            3890     	RRC	A
08CE    FA            3891     MOV R2 , A 
                      3892     GOVERNOR_ACTIVATE_RANGE_SET: 
08CF    1207EA        3893     	CALL	DIV_U16_BY_U16
                      3894     	; Store governor target
08D2    883F          3895     MOV GOV_TARGET_L , R0 
08D4    8940          3896     MOV GOV_TARGET_H , R1 
                      3897     CALC_GOVERNOR_TARGET_EXIT: 
08D6    22            3898     	RET						
                      3899     ENDIF
                      3900     
                      3901     ; Second governor routine - calculate governor proportional error
                      3902     CALC_GOVERNOR_PROP_ERROR: 
                      3903     	; Exit if governor is inactive
08D7    E548          3904     	MOV	A, GOV_ACTIVE
08D9    6034          3905     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      3906     
                      3907     IF MODE <= 1	; Main or tail
                               	; Load comm period and divide by 2
                               	CLR	C
                               	MOV	A, COMM_PERIOD4X_H
                               	RRC	A
                               	MOV	TEMP2, A
                               	MOV	A, COMM_PERIOD4X_L
                               	RRC	A
                               	MOV	TEMP1, A
                               	; Calculate error
                               	CLR	C
                               	MOV	A, GOV_TARGET_L
                               	SUBB	A, TEMP1
                               	MOV	TEMP1, A
                               	MOV	A, GOV_TARGET_H
                               	SUBB	A, TEMP2
                               	MOV	TEMP2, A
                               ENDIF
                      3925     IF MODE == 2	; Multi
                      3926     	; Calculate error
08DB    C3            3927     	CLR	C
08DC    E53F          3928     	MOV	A, GOV_TARGET_L
08DE    9523          3929     	SUBB	A, GOVERNOR_REQ_PWM
08E0    F8            3930     MOV R0 , A 
08E1    E540          3931     	MOV	A, GOV_TARGET_H
08E3    9400          3932     	SUBB	A, #0
08E5    F9            3933     MOV R1 , A 
                      3934     ENDIF
                      3935     	; Check error and limit
08E6    500C          3936     	JNC	GOVERNOR_CHECK_PROP_LIMIT_POS	; Check carry
                      3937     
08E8    C3            3938     	CLR	C
08E9    E8            3939     MOV A , R0 
08EA    9480          3940     	SUBB	A, #80H					; Is error too negative?
08EC    E9            3941     MOV A , R1 
08ED    94FF          3942     	SUBB	A, #0FFH
08EF    4016          3943     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
08F1    02090B        3944     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3945     
                      3946     GOVERNOR_CHECK_PROP_LIMIT_POS: 
08F4    C3            3947     	CLR	C
08F5    E8            3948     MOV A , R0 
08F6    947F          3949     	SUBB	A, #7FH					; Is error too positive?
08F8    E9            3950     MOV A , R1 
08F9    9400          3951     	SUBB	A, #00H
08FB    5003          3952     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
08FD    02090B        3953     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3954     
                      3955     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0900    787F          3956     MOV R0 , # 7FH 
0902    7900          3957     MOV R1 , # 00H 
0904    02090B        3958     	JMP	GOVERNOR_STORE_PROP_ERROR
                      3959     
                      3960     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
0907    7880          3961     MOV R0 , # 80H 
0909    79FF          3962     MOV R1 , # 0FFH 
                      3963     
                      3964     GOVERNOR_STORE_PROP_ERROR: 
                      3965     	; Store proportional
090B    8844          3966     MOV GOV_PROPORTIONAL_L , R0 
090D    8945          3967     MOV GOV_PROPORTIONAL_H , R1 
                      3968     CALC_GOVERNOR_PROP_ERROR_EXIT: 
090F    22            3969     	RET						
                      3970     
                      3971     
                      3972     ; Third governor routine - calculate governor integral error
                      3973     CALC_GOVERNOR_INT_ERROR: 
                      3974     	; Exit if governor is inactive
0910    E548          3975     	MOV	A, GOV_ACTIVE
0912    6058          3976     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      3977     
                      3978     	; Add proportional to integral
0914    E544          3979     	MOV	A, GOV_PROPORTIONAL_L
0916    2541          3980     	ADD	A, GOV_INTEGRAL_L
0918    F8            3981     MOV R0 , A 
0919    E545          3982     	MOV	A, GOV_PROPORTIONAL_H
091B    3542          3983     	ADDC	A, GOV_INTEGRAL_H
091D    F9            3984     MOV R1 , A 
091E    854520        3985     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_H		; Sign extend high byte
0921    E4            3986     	CLR	A
0922    300701        3987     	JNB	BIT_ACCESS.7, ($+4)			
0925    F4            3988     	CPL	A
0926    3543          3989     	ADDC	A, GOV_INTEGRAL_X
0928    FA            3990     MOV R2 , A 
                      3991     	; Check integral and limit
0929    30E709        3992     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      3993     
092C    C3            3994     	CLR	C
092D    EA            3995     MOV A , R2 
092E    94F0          3996     	SUBB	A, #0F0H					; Is error too negative?
0930    4015          3997     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
0932    02094D        3998     	JMP	GOVERNOR_CHECK_PWM
                      3999     
                      4000     GOVERNOR_CHECK_INT_LIMIT_POS: 
0935    C3            4001     	CLR	C
0936    EA            4002     MOV A , R2 
0937    940F          4003     	SUBB	A, #0FH					; Is error too positive?
0939    5003          4004     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
093B    02094D        4005     	JMP	GOVERNOR_CHECK_PWM
                      4006     
                      4007     GOVERNOR_LIMIT_INT_ERROR_POS: 
093E    78FF          4008     MOV R0 , # 0FFH 
0940    79FF          4009     MOV R1 , # 0FFH 
0942    7A0F          4010     MOV R2 , # 0FH 
0944    02094D        4011     	JMP	GOVERNOR_CHECK_PWM
                      4012     
                      4013     GOVERNOR_LIMIT_INT_ERROR_NEG: 
0947    7800          4014     MOV R0 , # 00H 
0949    7900          4015     MOV R1 , # 00H 
094B    7AF0          4016     MOV R2 , # 0F0H 
                      4017     
                      4018     GOVERNOR_CHECK_PWM: 
                      4019     	; Check current pwm
094D    C3            4020     	CLR	C
094E    E524          4021     	MOV	A, CURRENT_PWM
0950    955C          4022     	SUBB	A, PWM_LIMIT				; Is current pwm at or above pwm limit?
0952    5006          4023     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      4024     
0954    E524          4025     	MOV	A, CURRENT_PWM				; Is current pwm at zero?
0956    6009          4026     	JZ	GOVERNOR_INT_MIN_PWM		; Yes - branch
                      4027     
0958    2166          4028     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      4029     
                      4030     GOVERNOR_INT_MAX_PWM: 
095A    E545          4031     	MOV	A, GOV_PROPORTIONAL_H
095C    20E70D        4032     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
095F    2166          4033     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      4034     
                      4035     GOVERNOR_INT_MIN_PWM: 
0961    E545          4036     	MOV	A, GOV_PROPORTIONAL_H
0963    30E706        4037     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      4038     
                      4039     GOVERNOR_STORE_INT_ERROR: 
                      4040     	; Store integral
0966    8841          4041     MOV GOV_INTEGRAL_L , R0 
0968    8942          4042     MOV GOV_INTEGRAL_H , R1 
096A    8A43          4043     MOV GOV_INTEGRAL_X , R2 
                      4044     CALC_GOVERNOR_INT_ERROR_EXIT: 
096C    22            4045     	RET						
                      4046     
                      4047     
                      4048     ; Fourth governor routine - calculate governor proportional correction
                      4049     CALC_GOVERNOR_PROP_CORRECTION: 
                      4050     	; Exit if governor is inactive
096D    E548          4051     	MOV	A, GOV_ACTIVE
096F    7003          4052     	JNZ	CALC_GOVERNOR_PROP_CORR
0971    0209D0        4053     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      4054     
                      4055     CALC_GOVERNOR_PROP_CORR: 
                      4056     	; Load proportional gain
0974    789E          4057     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
0976    E6            4058     MOV A , @ R0 
0977    FA            4059     MOV R2 , A 
                      4060     	; Load proportional
0978    C3            4061     	CLR	C
0979    E544          4062     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
097B    33            4063     	RLC	A
097C    F8            4064     MOV R0 , A 
097D    E545          4065     	MOV	A, GOV_PROPORTIONAL_H
097F    33            4066     	RLC	A
0980    F9            4067     MOV R1 , A 
                      4068     	; Apply gain
0981    1122          4069     	CALL	MULT_S16_BY_U8_DIV_16
                      4070     	; Check error and limit (to low byte)
0983    E9            4071     MOV A , R1 
0984    30E70B        4072     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      4073     
0987    C3            4074     	CLR	C
0988    E8            4075     MOV A , R0 
0989    9480          4076     	SUBB	A, #80H					; Is error too negative?
098B    E9            4077     MOV A , R1 
098C    94FF          4078     	SUBB	A, #0FFH
098E    4013          4079     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
0990    21A7          4080     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4081     
                      4082     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
0992    C3            4083     	CLR	C
0993    E8            4084     MOV A , R0 
0994    947F          4085     	SUBB	A, #7FH					; Is error too positive?
0996    E9            4086     MOV A , R1 
0997    9400          4087     	SUBB	A, #00H
0999    5002          4088     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
099B    21A7          4089     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4090     
                      4091     GOVERNOR_LIMIT_PROP_CORR_POS: 
099D    787F          4092     MOV R0 , # 7FH 
099F    7900          4093     MOV R1 , # 00H 
09A1    21A7          4094     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      4095     
                      4096     GOVERNOR_LIMIT_PROP_CORR_NEG: 
09A3    7880          4097     MOV R0 , # 80H 
09A5    79FF          4098     MOV R1 , # 0FFH 
                      4099     
                      4100     GOVERNOR_APPLY_PROP_CORR: 
                      4101     	; Test proportional sign
09A7    E8            4102     MOV A , R0 
09A8    20E715        4103     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      4104     
                      4105     	; Subtract positive proportional
09AB    C3            4106     	CLR	C
09AC    E523          4107     	MOV	A, GOVERNOR_REQ_PWM
09AE    98            4108     SUBB A , R0 
09AF    F8            4109     MOV R0 , A 
                      4110     	; Check result
09B0    4009          4111     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      4112     
09B2    C3            4113     	CLR	C
09B3    E8            4114     MOV A , R0 
09B4    9401          4115     	SUBB	A, #1
09B6    4003          4116     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
09B8    0209CE        4117     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4118     
                      4119     GOVERNOR_CORR_PROP_MIN_PWM: 
09BB    7801          4120     MOV R0 , # 1 
09BD    0209CE        4121     	JMP	GOVERNOR_STORE_PROP_CORR
                      4122     
                      4123     GOVERNOR_CORR_NEG_PROP: 
                      4124     	; Add negative proportional
09C0    E8            4125     MOV A , R0 
09C1    F4            4126     	CPL	A
09C2    2401          4127     	ADD	A, #1
09C4    2523          4128     	ADD	A, GOVERNOR_REQ_PWM
09C6    F8            4129     MOV R0 , A 
                      4130     	; Check result
09C7    4003          4131     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
09C9    0209CE        4132     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      4133     
                      4134     GOVERNOR_CORR_PROP_MAX_PWM: 
09CC    78FF          4135     MOV R0 , # 255 
                      4136     GOVERNOR_STORE_PROP_CORR: 
                      4137     	; Store proportional pwm
09CE    8846          4138     MOV GOV_PROP_PWM , R0 
                      4139     CALC_GOVERNOR_PROP_CORR_EXIT: 
09D0    22            4140     	RET
                      4141     
                      4142     
                      4143     ; Fifth governor routine - calculate governor integral correction
                      4144     CALC_GOVERNOR_INT_CORRECTION: 
                      4145     	; Exit if governor is inactive
09D1    E548          4146     	MOV	A, GOV_ACTIVE
09D3    7003          4147     	JNZ	CALC_GOVERNOR_INT_CORR
09D5    020A32        4148     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      4149     
                      4150     CALC_GOVERNOR_INT_CORR: 
                      4151     	; Load integral gain
09D8    789F          4152     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
09DA    E6            4153     MOV A , @ R0 
09DB    FA            4154     MOV R2 , A 
                      4155     	; Load integral
09DC    A842          4156     MOV R0 , GOV_INTEGRAL_H 
09DE    A943          4157     MOV R1 , GOV_INTEGRAL_X 
                      4158     	; Apply gain
09E0    1122          4159     	CALL	MULT_S16_BY_U8_DIV_16
                      4160     	; Check integral and limit
09E2    E9            4161     MOV A , R1 
09E3    30E70C        4162     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      4163     
09E6    C3            4164     	CLR	C
09E7    E8            4165     MOV A , R0 
09E8    9401          4166     	SUBB	A, #01H					; Is integral too negative?
09EA    E9            4167     MOV A , R1 
09EB    94FF          4168     	SUBB	A, #0FFH
09ED    4016          4169     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
09EF    020A09        4170     	JMP	GOVERNOR_APPLY_INT_CORR
                      4171     
                      4172     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
09F2    C3            4173     	CLR	C
09F3    E8            4174     MOV A , R0 
09F4    94FF          4175     	SUBB	A, #0FFH					; Is integral too positive?
09F6    E9            4176     MOV A , R1 
09F7    9400          4177     	SUBB	A, #00H
09F9    5003          4178     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
09FB    020A09        4179     	JMP	GOVERNOR_APPLY_INT_CORR
                      4180     
                      4181     GOVERNOR_LIMIT_INT_CORR_POS: 
09FE    78FF          4182     MOV R0 , # 0FFH 
0A00    7900          4183     MOV R1 , # 00H 
0A02    020A09        4184     	JMP	GOVERNOR_APPLY_INT_CORR
                      4185     
                      4186     GOVERNOR_LIMIT_INT_CORR_NEG: 
0A05    7801          4187     MOV R0 , # 01H 
0A07    79FF          4188     MOV R1 , # 0FFH 
                      4189     
                      4190     GOVERNOR_APPLY_INT_CORR: 
                      4191     	; Test integral sign
0A09    E9            4192     MOV A , R1 
0A0A    20E715        4193     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      4194     
                      4195     	; Subtract positive integral
0A0D    C3            4196     	CLR	C
0A0E    E546          4197     	MOV	A, GOV_PROP_PWM
0A10    98            4198     SUBB A , R0 
0A11    F8            4199     MOV R0 , A 
                      4200     	; Check result
0A12    4009          4201     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      4202     
0A14    C3            4203     	CLR	C
0A15    E8            4204     MOV A , R0 
0A16    9401          4205     	SUBB	A, #1
0A18    4003          4206     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0A1A    020A30        4207     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4208     
                      4209     GOVERNOR_CORR_INT_MIN_PWM: 
0A1D    7800          4210     MOV R0 , # 0 
0A1F    020A30        4211     	JMP	GOVERNOR_STORE_INT_CORR
                      4212     
                      4213     GOVERNOR_CORR_NEG_INT: 
                      4214     	; Add negative integral
0A22    E8            4215     MOV A , R0 
0A23    F4            4216     	CPL	A
0A24    2401          4217     	ADD	A, #1
0A26    2546          4218     	ADD	A, GOV_PROP_PWM
0A28    F8            4219     MOV R0 , A 
                      4220     	; Check result
0A29    4003          4221     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0A2B    020A30        4222     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      4223     
                      4224     GOVERNOR_CORR_INT_MAX_PWM: 
0A2E    78FF          4225     MOV R0 , # 255 
                      4226     GOVERNOR_STORE_INT_CORR: 
                      4227     	; Store current pwm
0A30    8824          4228     MOV CURRENT_PWM , R0 
                      4229     CALC_GOVERNOR_INT_CORR_EXIT: 
0A32    22            4230     	RET
                      4231     
                      4232     
                      4233     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4234     ;
                      4235     ; Measure lipo cells
                      4236     ;
                      4237     ; No assumptions
                      4238     ;
                      4239     ; Measure voltage and calculate lipo cells
                      4240     ;
                      4241     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4242     MEASURE_LIPO_CELLS: 
                      4243     IF MODE == 1	; Tail
                               	; If tail, then exit
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      4247     MEASURE_LIPO_START: 
                      4248     	; Load programmed low voltage limit
0A33    7883          4249     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0A35    E6            4250     MOV A , @ R0 
0A36    F520          4251     	MOV	BIT_ACCESS, A				; Store in Bit_Access
                      4252     	; Set commutation to BpFET on
0A38    120F6F        4253     	CALL	COMM5COMM6			
                      4254     	; Start adc
                      4255     	START_ADC 
0A3B    75E890        4255+1   MOV ADC0CN , # 90H  ; ADC START
                      4256     	; Wait for ADC conversion to complete
                      4257     	GET_ADC_STATUS 
0A3E    E5E8          4257+1   MOV A , ADC0CN 
0A40    20ECF0        4258     	JB	AD0BUSY, MEASURE_LIPO_CELLS
                      4259     	; Read ADC result
                      4260     	READ_ADC_RESULT
0A43    A8BD          4260+1   MOV R0 , ADC0L 
0A45    A9BE          4260+1   MOV R1 , ADC0H 
                      4261     	; Stop ADC
                      4262     	STOP_ADC
                      4263     	; Switch power off
0A47    121004        4264     	CALL	SWITCH_POWER_OFF		
                      4265     	; Set limit step
0A4A    756855        4266     MOV LIPO_ADC_LIMIT_L , # 85 
0A4D    756900        4267     MOV LIPO_ADC_LIMIT_H , # 0 
0A50    C3            4268     	CLR	C
0A51    7400          4269     MOV A , # 0 
0A53    13            4270     	RRC	A
0A54    FD            4271     MOV R5 , A 
0A55    7455          4272     MOV A , # 85 
0A57    13            4273     	RRC	A
0A58    FC            4274     MOV R4 , A 
0A59    7455          4275     MOV A , # 85 
0A5B    2C            4276     ADD A , R4 
0A5C    FC            4277     MOV R4 , A 
0A5D    7400          4278     MOV A , # 0 
0A5F    3D            4279     ADDC A , R5 
0A60    FD            4280     MOV R5 , A 
0A61    EC            4281     MOV A , R4 
0A62    FA            4282     MOV R2 , A 
0A63    ED            4283     MOV A , R5 
0A64    FB            4284     MOV R3 , A 
                      4285     MEASURE_LIPO_CELL_LOOP: 
                      4286     	; Check voltage against xS lower limit
0A65    C3            4287     	CLR	C
0A66    E8            4288     MOV A , R0 
0A67    9A            4289     SUBB A , R2 
0A68    E9            4290     MOV A , R1 
0A69    9B            4291     SUBB A , R3 
0A6A    4014          4292     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      4293     
                      4294     	; Set xS voltage limit
0A6C    E568          4295     	MOV	A, LIPO_ADC_LIMIT_L		
0A6E    2455          4296     ADD A , # 85 
0A70    F568          4297     	MOV	LIPO_ADC_LIMIT_L, A
0A72    E569          4298     	MOV	A, LIPO_ADC_LIMIT_H		
0A74    3400          4299     ADDC A , # 0 
0A76    F569          4300     	MOV	LIPO_ADC_LIMIT_H, A
                      4301     	; Set (x+1)S lower limit
0A78    EA            4302     MOV A , R2 
0A79    2C            4303     ADD A , R4 
0A7A    FA            4304     MOV R2 , A 
0A7B    EB            4305     MOV A , R3 
0A7C    3D            4306     ADDC A , R5 
0A7D    FB            4307     MOV R3 , A 
0A7E    80E5          4308     	JMP	MEASURE_LIPO_CELL_LOOP	; Check for one more battery cell
                      4309     
                      4310     MEASURE_LIPO_ADJUST: 
0A80    AE68          4311     MOV R6 , LIPO_ADC_LIMIT_L 
0A82    AF69          4312     MOV R7 , LIPO_ADC_LIMIT_H 
                      4313     	; Calculate 3.125%
0A84    C3            4314     	CLR	C
0A85    E569          4315     	MOV	A, LIPO_ADC_LIMIT_H
0A87    13            4316     	RRC	A
0A88    F9            4317     MOV R1 , A 
0A89    E568          4318     	MOV	A, LIPO_ADC_LIMIT_L	
0A8B    13            4319     	RRC	A
0A8C    F8            4320     MOV R0 , A 
0A8D    C3            4321     	CLR	C
0A8E    E9            4322     MOV A , R1 
0A8F    13            4323     	RRC	A
0A90    F9            4324     MOV R1 , A 
0A91    E8            4325     MOV A , R0 
0A92    13            4326     	RRC	A
0A93    F8            4327     MOV R0 , A 
0A94    E568          4328     	MOV	A, LIPO_ADC_LIMIT_L		; Set adc reference for voltage compensation
0A96    28            4329     ADD A , R0 
0A97    F566          4330     	MOV	LIPO_ADC_REFERENCE_L, A
0A99    E569          4331     	MOV	A, LIPO_ADC_LIMIT_H
0A9B    39            4332     ADDC A , R1 
0A9C    F567          4333     	MOV	LIPO_ADC_REFERENCE_H, A
                      4334     	; Divide three times to get to 3.125%
0A9E    7A03          4335     MOV R2 , # 3 
                      4336     MEASURE_LIPO_DIVIDE_LOOP: 
0AA0    C3            4337     	CLR	C
0AA1    E9            4338     MOV A , R1 
0AA2    13            4339     	RRC	A
0AA3    F9            4340     MOV R1 , A 
0AA4    E8            4341     MOV A , R0 
0AA5    13            4342     	RRC	A
0AA6    F8            4343     MOV R0 , A 
0AA7    DAF7          4344     DJNZ R2 , MEASURE_LIPO_DIVIDE_LOOP 
                      4345     
                      4346     	; Add the programmed number of 0.1V (or 3.125% increments)
0AA9    AA20          4347     MOV R2 , BIT_ACCESS 
0AAB    1A            4348     DEC R2 
0AAC    7009          4349     	JNZ	MEASURE_LIPO_LIMIT_ON	; Is low voltage limiting on?
                      4350     
0AAE    756800        4351     	MOV	LIPO_ADC_LIMIT_L, #0	; No - set limit to zero
0AB1    756900        4352     	MOV	LIPO_ADC_LIMIT_H, #0
0AB4    020AC7        4353     	JMP	MEASURE_LIPO_EXIT	
                      4354     
                      4355     MEASURE_LIPO_LIMIT_ON: 
0AB7    1A            4356     DEC R2 
0AB8    EA            4357     MOV A , R2 
0AB9    6008          4358     	JZ	MEASURE_LIPO_UPDATE
                      4359     
                      4360     MEASURE_LIPO_ADD_LOOP: 
0ABB    EE            4361     MOV A , R6 
0ABC    28            4362     ADD A , R0 
0ABD    FE            4363     MOV R6 , A 
0ABE    EF            4364     MOV A , R7 
0ABF    39            4365     ADDC A , R1 
0AC0    FF            4366     MOV R7 , A 
0AC1    DAF8          4367     DJNZ R2 , MEASURE_LIPO_ADD_LOOP 
                      4368     
                      4369     MEASURE_LIPO_UPDATE: 
                      4370     	; Set ADC limit
0AC3    8E68          4371     MOV LIPO_ADC_LIMIT_L , R6 
0AC5    8F69          4372     MOV LIPO_ADC_LIMIT_H , R7 
                      4373     MEASURE_LIPO_EXIT: 
0AC7    22            4374     	RET
                      4375     
                      4376     
                      4377     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4378     ;
                      4379     ; Start ADC conversion
                      4380     ;
                      4381     ; No assumptions
                      4382     ;
                      4383     ; Start conversion used for measuring power supply voltage
                      4384     ;
                      4385     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4386     START_ADC_CONVERSION: 
                      4387     	; Start adc
                      4388     	START_ADC 
0AC8    75E890        4388+1   MOV ADC0CN , # 90H  ; ADC START
0ACB    22            4389     	RET
                      4390     
                      4391     
                      4392     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4393     ;
                      4394     ; Check temperature, power supply voltage and limit power
                      4395     ;
                      4396     ; No assumptions
                      4397     ;
                      4398     ; Used to limit main motor power in order to maintain the required voltage
                      4399     ;
                      4400     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4401     CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER: 
                      4402     	; Load programmed low voltage limit
0ACC    7883          4403     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0ACE    E6            4404     MOV A , @ R0 
0ACF    FF            4405     MOV R7 , A 
                      4406     	; Wait for ADC conversion to complete
                      4407     	GET_ADC_STATUS 
0AD0    E5E8          4407+1   MOV A , ADC0CN 
0AD2    20ECF7        4408     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
                      4409     	; Read ADC result
                      4410     	READ_ADC_RESULT
0AD5    A8BD          4410+1   MOV R0 , ADC0L 
0AD7    A9BE          4410+1   MOV R1 , ADC0H 
                      4411     	; Stop ADC
                      4412     	STOP_ADC
                      4413     
0AD9    056A          4414     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0ADB    C3            4415     	CLR	C
0ADC    E56A          4416     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0ADE    9408          4417     SUBB A , # 8 
0AE0    4052          4418     	JC	CHECK_VOLTAGE_START			; No - check voltage
                      4419     
0AE2    756A00        4420     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0AE5    E9            4421     MOV A , R1 
0AE6    7007          4422     	JNZ	TEMP_AVERAGE_INC_DEC		; No - proceed
                      4423     
0AE8    E56B          4424     	MOV	A, CURRENT_AVERAGE_TEMP		; Yes -  decrement average
0AEA    601B          4425     	JZ	TEMP_AVERAGE_UPDATED		; Already zero - no change
0AEC    020AFB        4426     	JMP	TEMP_AVERAGE_DEC			; Decrement 
                      4427     
                      4428     TEMP_AVERAGE_INC_DEC: 
0AEF    C3            4429     	CLR	C
0AF0    E8            4430     MOV A , R0 
0AF1    956B          4431     	SUBB	A, CURRENT_AVERAGE_TEMP
0AF3    6010          4432     	JZ	TEMP_AVERAGE_UPDATED_LOAD_ACC	; Equal - no change
                      4433     
0AF5    E56B          4434     	MOV	A, CURRENT_AVERAGE_TEMP		; Above - increment average
0AF7    5006          4435     	JNC	TEMP_AVERAGE_INC				
                      4436     
0AF9    600C          4437     	JZ	TEMP_AVERAGE_UPDATED		; Below - decrement average if average is not already zero
                      4438     TEMP_AVERAGE_DEC: 
0AFB    14            4439     	DEC	A						; Decrement average
0AFC    020B07        4440     	JMP	TEMP_AVERAGE_UPDATED
                      4441     
                      4442     TEMP_AVERAGE_INC: 
0AFF    04            4443     	INC	A						; Increment average
0B00    60F9          4444     	JZ	TEMP_AVERAGE_DEC
0B02    020B07        4445     	JMP	TEMP_AVERAGE_UPDATED
                      4446     
                      4447     TEMP_AVERAGE_UPDATED_LOAD_ACC: 
0B05    E56B          4448     	MOV	A, CURRENT_AVERAGE_TEMP
                      4449     TEMP_AVERAGE_UPDATED: 
0B07    F56B          4450     	MOV	CURRENT_AVERAGE_TEMP, A
0B09    C3            4451     	CLR	C
0B0A    9472          4452     SUBB A , # 114 
0B0C    F8            4453     MOV R0 , A 
0B0D    4021          4454     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      4455     
0B0F    755CC0        4456     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      4457     
0B12    C3            4458     	CLR	C
0B13    E8            4459     MOV A , R0 
0B14    9404          4460     SUBB A , # 4 
0B16    F8            4461     MOV R0 , A 
0B17    4017          4462     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      4463     
0B19    755C80        4464     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      4465     
0B1C    C3            4466     	CLR	C
0B1D    E8            4467     MOV A , R0 
0B1E    9404          4468     SUBB A , # 4 
0B20    F8            4469     MOV R0 , A 
0B21    400D          4470     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      4471     
0B23    755C40        4472     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      4473     
0B26    C3            4474     	CLR	C
0B27    E8            4475     MOV A , R0 
0B28    9404          4476     SUBB A , # 4 
0B2A    F8            4477     MOV R0 , A 
0B2B    4003          4478     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      4479     
0B2D    755C00        4480     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      4481     
                      4482     TEMP_CHECK_EXIT: 
                      4483     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0B30    75BB09        4483+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0B33    22            4484     	RET
                      4485     
                      4486     CHECK_VOLTAGE_START: 
                      4487     IF MODE == 0 OR MODE == 2	; Main or multi
                      4488     	; Check if low voltage limiting is enabled
0B34    EF            4489     MOV A , R7 
0B35    C3            4490     	CLR	C
0B36    9401          4491     	SUBB	A, #1					; Is low voltage limit disabled?
0B38    601B          4492     	JZ	CHECK_VOLTAGE_GOOD			; Yes - voltage declared good
                      4493     
                      4494     	; Check if ADC is saturated
0B3A    C3            4495     	CLR	C
0B3B    E8            4496     MOV A , R0 
0B3C    94FF          4497     	SUBB	A, #0FFH
0B3E    E9            4498     MOV A , R1 
0B3F    9403          4499     	SUBB	A, #03H
0B41    5012          4500     	JNC	CHECK_VOLTAGE_GOOD		; ADC saturated, can not make judgement
                      4501     
                      4502     	; Check voltage against limit
0B43    C3            4503     	CLR	C
0B44    E8            4504     MOV A , R0 
0B45    9568          4505     	SUBB	A, LIPO_ADC_LIMIT_L
0B47    E9            4506     MOV A , R1 
0B48    9569          4507     	SUBB	A, LIPO_ADC_LIMIT_H
0B4A    5009          4508     	JNC	CHECK_VOLTAGE_GOOD		; If voltage above limit - branch
                      4509     
                      4510     	; Decrease pwm limit
0B4C    E55C          4511     	MOV  A, PWM_LIMIT
0B4E    600C          4512     	JZ	CHECK_VOLTAGE_LIM		; If limit zero - branch
                      4513     
0B50    155C          4514     	DEC	PWM_LIMIT				; Decrement limit
0B52    020B5C        4515     	JMP	CHECK_VOLTAGE_LIM
                      4516     
                      4517     CHECK_VOLTAGE_GOOD: 
                      4518     	; Increase pwm limit
0B55    E55C          4519     	MOV  A, PWM_LIMIT
0B57    F4            4520     	CPL	A			
0B58    6002          4521     	JZ	CHECK_VOLTAGE_LIM		; If limit max - branch
                      4522     
0B5A    055C          4523     	INC	PWM_LIMIT				; Increment limit
                      4524     
                      4525     CHECK_VOLTAGE_LIM: 
0B5C    A85C          4526     MOV R0 , PWM_LIMIT 
0B5E    C3            4527     	CLR	C
0B5F    E524          4528     	MOV	A, CURRENT_PWM
0B61    98            4529     SUBB A , R0 
0B62    5002          4530     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      4531     
0B64    A824          4532     MOV R0 , CURRENT_PWM 
                      4533     
                      4534     CHECK_VOLTAGE_SPOOLUP_LIM: 
0B66    8825          4535     MOV CURRENT_PWM_LIMITED , R0 
                      4536     	; Slow spoolup
0B68    C3            4537     	CLR	C
0B69    E525          4538     	MOV	A, CURRENT_PWM_LIMITED
0B6B    955D          4539     	SUBB	A, PWM_LIMIT_SPOOLUP
0B6D    400B          4540     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      4541     
0B6F    855D25        4542     	MOV	CURRENT_PWM_LIMITED, PWM_LIMIT_SPOOLUP
0B72    E55D          4543     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0B74    F4            4544     	CPL	A
0B75    6003          4545     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      4546      
0B77    855D5C        4547     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      4548     
                      4549     CHECK_VOLTAGE_EXIT: 
                      4550     ENDIF
                      4551     	; Set adc mux for next conversion
0B7A    C3            4552     	CLR	C
0B7B    E56A          4553     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0B7D    B40703        4554     	CJNE	A, #(TEMP_CHECK_RATE-1), ($+6)
                      4555     
                      4556     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0B80    75BB10        4556+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      4557     
0B83    22            4558     	RET
                      4559     
                      4560     
                      4561     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4562     ;
                      4563     ; Set startup PWM routine
                      4564     ;
                      4565     ; No assumptions
                      4566     ;
                      4567     ; Used for pwm control during startup
                      4568     ;
                      4569     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4570     SET_STARTUP_PWM: 	
                      4571     	; Set pwm values according to startup phase flags
0B84    306102        4572     JNB FLAGS1 . 1 , ( $+5 ) 
0B87    7832          4573     MOV R0 , # 50 
0B89    306202        4574     JNB FLAGS1 . 2 , ( $+5 ) 
0B8C    7878          4575     MOV R0 , # 120 
                      4576     
                      4577     	; Update pwm variables if any startup phase flag is set
0B8E    E52C          4578     	MOV	A, FLAGS1
0B90    5406          4579     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE))
0B92    601F          4580     	JZ	STARTUP_PWM_EXIT				; If no startup phase set - exit
                      4581     
                      4582     	; Adjust startup power
0B94    E8            4583     MOV A , R0 
0B95    79A1          4584     MOV R1 , # PGM_STARTUP_PWR_DECODED 
0B97    87F0          4585     MOV B , @ R1 
0B99    A4            4586     	MUL	AB
0B9A    C5F0          4587     	XCH	A, B
0B9C    A2F7          4588     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
0B9E    33            4589     	RLC	A
0B9F    F8            4590     MOV R0 , A 
0BA0    C3            4591     	CLR	C
0BA1    E8            4592     MOV A , R0 
0BA2    955C          4593     	SUBB	A, PWM_LIMIT	
0BA4    4002          4594     	JC	STARTUP_PWM_SET_PWM				; If pwm below limit - branch
                      4595     
0BA6    A85C          4596     MOV R0 , PWM_LIMIT 
                      4597     
                      4598     STARTUP_PWM_SET_PWM: 
                      4599     	; Set pwm variables
0BA8    8822          4600     MOV REQUESTED_PWM , R0 
0BAA    8824          4601     MOV CURRENT_PWM , R0 
0BAC    8825          4602     MOV CURRENT_PWM_LIMITED , R0 
0BAE    306102        4603     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      4604     
0BB1    885E          4605     MOV PWM_SPOOLUP_BEG , R0 
                      4606     
                      4607     STARTUP_PWM_EXIT: 
0BB3    22            4608     	RET
                      4609     
                      4610     
                      4611     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4612     ;
                      4613     ; Initialize all timings routine
                      4614     ;
                      4615     ; No assumptions
                      4616     ;
                      4617     ; Part of initialization before motor start
                      4618     ;
                      4619     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4620     INITIALIZE_ALL_TIMINGS:  
                      4621     	; Load programmed startup rpm
0BB4    788F          4622     MOV R0 , # PGM_STARTUP_RPM 
0BB6    E6            4623     MOV A , @ R0 
0BB7    FF            4624     MOV R7 , A 
                      4625     	; Check startup rpm setting and set step accordingly
0BB8    C3            4626     	CLR	C
0BB9    EF            4627     MOV A , R7 
0BBA    9405          4628     	SUBB	A, #5
0BBC    5018          4629     	JNC	STEPPER_STEP_HIGH
0BBE    C3            4630     	CLR	C
0BBF    EF            4631     MOV A , R7 
0BC0    9404          4632     	SUBB	A, #4
0BC2    5020          4633     	JNC	STEPPER_STEP_MED_HIGH
0BC4    C3            4634     	CLR	C
0BC5    EF            4635     MOV A , R7 
0BC6    9403          4636     	SUBB	A, #3
0BC8    5028          4637     	JNC	STEPPER_STEP_MED
0BCA    C3            4638     	CLR	C
0BCB    EF            4639     MOV A , R7 
0BCC    9402          4640     	SUBB	A, #2
0BCE    5030          4641     	JNC	STEPPER_STEP_MED_LOW
0BD0    C3            4642     	CLR	C
0BD1    EF            4643     MOV A , R7 
0BD2    9401          4644     	SUBB	A, #1
0BD4    5038          4645     	JNC	STEPPER_STEP_LOW
                      4646     
                      4647     STEPPER_STEP_HIGH: 
0BD6    7533A0        4648     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0BD9    75340F        4649     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0BDC    75353C        4650     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0BDF    753605        4651     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0BE2    811C          4652     	AJMP	STEPPER_STEP_SET
                      4653     STEPPER_STEP_MED_HIGH: 
0BE4    7533C0        4654     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0BE7    753412        4655     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0BEA    753540        4656     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0BED    753606        4657     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0BF0    811C          4658     	AJMP	STEPPER_STEP_SET
                      4659     STEPPER_STEP_MED: 
0BF2    753370        4660     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0BF5    753417        4661     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0BF8    7535D0        4662     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0BFB    753607        4663     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0BFE    811C          4664     	AJMP	STEPPER_STEP_SET
                      4665     STEPPER_STEP_MED_LOW: 
0C00    75334C        4666     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0C03    75341D        4667     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0C06    7535C4        4668     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0C09    753609        4669     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0C0C    811C          4670     	AJMP	STEPPER_STEP_SET
                      4671     STEPPER_STEP_LOW: 
0C0E    753328        4672     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0C11    753423        4673     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0C14    7535B8        4674     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0C17    75360B        4675     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
0C1A    811C          4676     	AJMP	STEPPER_STEP_SET
                      4677     
                      4678     STEPPER_STEP_SET: 
0C1C    85334F        4679     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0C1F    853450        4680     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0C22    753B00        4681     	MOV	COMM_PERIOD4X_L, #00H				; Set commutation period registers
0C25    753C08        4682     	MOV	COMM_PERIOD4X_H, #08H
0C28    22            4683     	RET
                      4684     
                      4685     
                      4686     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4687     ;
                      4688     ; Calculate next commutation timing routine
                      4689     ;
                      4690     ; No assumptions
                      4691     ;
                      4692     ; Called immediately after each commutation
                      4693     ; Also sets up timer 1 to wait advance timing
                      4694     ; Two entry points are used
                      4695     ;
                      4696     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4697     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0C29    A84F          4698     MOV R0 , WT_STEPPER_STEP_L 
0C2B    A950          4699     MOV R1 , WT_STEPPER_STEP_H 
0C2D    020C34        4700     	JMP	READ_TIMER
                      4701     
                      4702     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0C30    A849          4703     MOV R0 , WT_ADVANCE_L 
0C32    A94A          4704     MOV R1 , WT_ADVANCE_H 
                      4705     READ_TIMER: 
                      4706     	; Set up next wait
0C34    759100        4707     	MOV	TMR3CN, #00H		; Timer3 disabled
0C37    C3            4708     	CLR	C
0C38    E4            4709     	CLR	A
0C39    98            4710     SUBB A , R0 
0C3A    F594          4711     	MOV	TMR3L, A
0C3C    E4            4712     	CLR	A
0C3D    99            4713     SUBB A , R1 
0C3E    F595          4714     	MOV	TMR3H, A
0C40    759104        4715     	MOV	TMR3CN, #04H		; Timer3 enabled
0C43    D258          4716     SETB FLAGS0 . 0 
                      4717     	; Read commutation time
0C45    75C820        4718     	MOV	TMR2CN, #20H		; Timer2 disabled
0C48    A8CC          4719     MOV R0 , TMR2L 
0C4A    A9CD          4720     MOV R1 , TMR2H 
0C4C    75C824        4721     	MOV	TMR2CN, #24H		; Timer2 enabled
                      4722     	; Calculate this commutation time
0C4F    AA39          4723     MOV R2 , PREV_COMM_L 
0C51    AB3A          4724     MOV R3 , PREV_COMM_H 
0C53    8839          4725     MOV PREV_COMM_L , R0 
0C55    893A          4726     MOV PREV_COMM_H , R1 
0C57    C3            4727     	CLR	C
0C58    E8            4728     MOV A , R0 
0C59    9A            4729     SUBB A , R2 
0C5A    F8            4730     MOV R0 , A 
0C5B    E9            4731     MOV A , R1 
0C5C    9B            4732     SUBB A , R3 
0C5D    F9            4733     MOV R1 , A 
                      4734     	; Calculate next zero cross scan timeout 
0C5E    AA3B          4735     MOV R2 , COMM_PERIOD4X_L 
0C60    AB3C          4736     MOV R3 , COMM_PERIOD4X_H 
0C62    C3            4737     	CLR	C
0C63    EB            4738     MOV A , R3 
0C64    13            4739     	RRC	A					; Divide by 2
0C65    FD            4740     MOV R5 , A 
0C66    EA            4741     MOV A , R2 
0C67    13            4742     	RRC	A
0C68    FC            4743     MOV R4 , A 
0C69    C3            4744     	CLR	C
0C6A    ED            4745     MOV A , R5 
0C6B    13            4746     	RRC	A					; Divide by 2 again
0C6C    FD            4747     MOV R5 , A 
0C6D    EC            4748     MOV A , R4 
0C6E    13            4749     	RRC	A
0C6F    FC            4750     MOV R4 , A 
0C70    C3            4751     	CLR	C
0C71    EA            4752     MOV A , R2 
0C72    9C            4753     SUBB A , R4 
0C73    FA            4754     MOV R2 , A 
0C74    EB            4755     MOV A , R3 
0C75    9D            4756     SUBB A , R5 
0C76    FB            4757     MOV R3 , A 
                      4758     
0C77    EA            4759     MOV A , R2 
0C78    28            4760     ADD A , R0 
0C79    FA            4761     MOV R2 , A 
0C7A    EB            4762     MOV A , R3 
0C7B    39            4763     ADDC A , R1 
0C7C    FB            4764     MOV R3 , A 
0C7D    8A3B          4765     MOV COMM_PERIOD4X_L , R2 
0C7F    8B3C          4766     MOV COMM_PERIOD4X_H , R3 
0C81    4001          4767     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
                      4768     
0C83    22            4769     	RET
                      4770     
                      4771     CALC_NEXT_COMM_SLOW: 
0C84    753BFF        4772     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0C87    753CFF        4773     	MOV	COMM_PERIOD4X_H, #0FFH
0C8A    22            4774     	RET
                      4775     
                      4776     
                      4777     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4778     ;
                      4779     ; Wait advance timing routine
                      4780     ;
                      4781     ; No assumptions
                      4782     ;
                      4783     ; Waits for the advance timing to elapse
                      4784     ; Also sets up timer 1 to wait the zero cross scan wait time
                      4785     ; And has a separate entry point for just setting up zero cross scan wait
                      4786     ;
                      4787     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4788     WAIT_ADVANCE_TIMING: 	
0C8B    305802        4789     JNB FLAGS0 . 0 , ( $+5 ) 
0C8E    818B          4790     	AJMP	WAIT_ADVANCE_TIMING
                      4791     
                      4792     SETUP_ZC_SCAN_WAIT: 
0C90    759100        4793     	MOV	TMR3CN, #00H		; Timer3 disabled
0C93    C3            4794     	CLR	C
0C94    E4            4795     	CLR	A
0C95    954B          4796     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0C97    F594          4797     	MOV	TMR3L, A
0C99    E4            4798     	CLR	A
0C9A    954C          4799     	SUBB	A, WT_ZC_SCAN_H		
0C9C    F595          4800     	MOV	TMR3H, A
0C9E    759104        4801     	MOV	TMR3CN, #04H		; Timer3 enabled
0CA1    D258          4802     SETB FLAGS0 . 0 
0CA3    22            4803     	RET
                      4804     
                      4805     
                      4806     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4807     ;
                      4808     ; Calculate new wait times routine
                      4809     ;
                      4810     ; No assumptions
                      4811     ;
                      4812     ; Calculates new wait times
                      4813     ;
                      4814     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4815     CALC_NEW_WAIT_TIMES: 	
                      4816     	; Load programmed commutation timing
0CA4    7892          4817     MOV R0 , # PGM_COMM_TIMING 
0CA6    E6            4818     MOV A , @ R0 
0CA7    FF            4819     MOV R7 , A 
0CA8    7E10          4820     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
0CAA    305B02        4821     JNB FLAGS0 . 3 , CALC_NEW_WAIT_CHECK_STARTUP 
                      4822     
0CAD    7F05          4823     MOV R7 , # 5 
                      4824     
                      4825     CALC_NEW_WAIT_CHECK_STARTUP: 
0CAF    306304        4826     JNB FLAGS1 . 3 , CALC_NEW_WAIT_DIR_START_SET 
                      4827     
0CB2    7F03          4828     MOV R7 , # 3 
0CB4    7E00          4829     MOV R6 , # 0 
                      4830     
                      4831     CALC_NEW_WAIT_DIR_START_SET: 
                      4832     	; Load current commutation timing
0CB6    A93C          4833     MOV R1 , COMM_PERIOD4X_H 
0CB8    A83B          4834     MOV R0 , COMM_PERIOD4X_L 
0CBA    7A04          4835     MOV R2 , # 4 
                      4836     DIVIDE_WAIT_TIMES: 
0CBC    C3            4837     	CLR	C
0CBD    E9            4838     MOV A , R1 
0CBE    13            4839     	RRC	A					; Divide by 2
0CBF    F9            4840     MOV R1 , A 
0CC0    E8            4841     MOV A , R0 
0CC1    13            4842     	RRC	A
0CC2    F8            4843     MOV R0 , A 
0CC3    DAF7          4844     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      4845     
0CC5    C3            4846     	CLR	C
0CC6    E8            4847     MOV A , R0 
0CC7    9E            4848     SUBB A , R6 
0CC8    F8            4849     MOV R0 , A 
0CC9    E9            4850     MOV A , R1 
0CCA    9400          4851     	SUBB	A, #0
0CCC    F9            4852     MOV R1 , A 
0CCD    4009          4853     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      4854     
0CCF    C3            4855     	CLR	C
0CD0    E8            4856     MOV A , R0 
0CD1    9402          4857     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0CD3    E9            4858     MOV A , R1 
0CD4    9400          4859     	SUBB	A, #0
0CD6    5004          4860     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      4861     
                      4862     LOAD_MIN_TIME: 
0CD8    7802          4863     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0CDA    E4            4864     	CLR	A
0CDB    F9            4865     MOV R1 , A 
                      4866     
                      4867     ADJUST_TIMING: 
0CDC    E9            4868     MOV A , R1 
0CDD    FB            4869     MOV R3 , A 
0CDE    E8            4870     MOV A , R0 
0CDF    FA            4871     MOV R2 , A 
0CE0    C3            4872     	CLR	C
0CE1    E9            4873     MOV A , R1 
0CE2    13            4874     	RRC	A					; Divide by 2
0CE3    FD            4875     MOV R5 , A 
0CE4    E8            4876     MOV A , R0 
0CE5    13            4877     	RRC	A
0CE6    FC            4878     MOV R4 , A 
0CE7    C3            4879     	CLR	C
0CE8    EF            4880     MOV A , R7 
0CE9    9403          4881     	SUBB	A, #3				; Is timing normal?
0CEB    602E          4882     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      4883     
0CED    EF            4884     MOV A , R7 
0CEE    20E00D        4885     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      4886     
0CF1    E8            4887     MOV A , R0 
0CF2    2C            4888     ADD A , R4 
0CF3    F8            4889     MOV R0 , A 
0CF4    E9            4890     MOV A , R1 
0CF5    3D            4891     ADDC A , R5 
0CF6    F9            4892     MOV R1 , A 
0CF7    EC            4893     MOV A , R4 
0CF8    FA            4894     MOV R2 , A 
0CF9    ED            4895     MOV A , R5 
0CFA    FB            4896     MOV R3 , A 
0CFB    020D08        4897     	JMP	STORE_TIMES_UP_OR_DOWN
                      4898     
                      4899     ADJUST_TIMING_TWO_STEPS: 
0CFE    E8            4900     MOV A , R0 
0CFF    28            4901     ADD A , R0 
0D00    F8            4902     MOV R0 , A 
0D01    E9            4903     MOV A , R1 
0D02    39            4904     ADDC A , R1 
0D03    F9            4905     MOV R1 , A 
0D04    7A02          4906     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0D06    E4            4907     	CLR	A
0D07    FB            4908     MOV R3 , A 
                      4909     
                      4910     STORE_TIMES_UP_OR_DOWN: 
0D08    C3            4911     	CLR	C
0D09    EF            4912     MOV A , R7 
0D0A    9403          4913     	SUBB	A, #3				; Is timing higher than normal?
0D0C    400D          4914     	JC	STORE_TIMES_DECREASE	; No - branch
                      4915     
                      4916     STORE_TIMES_INCREASE: 
0D0E    8A4D          4917     MOV WT_COMM_L , R2 
0D10    8B4E          4918     MOV WT_COMM_H , R3 
0D12    8849          4919     MOV WT_ADVANCE_L , R0 
0D14    894A          4920     MOV WT_ADVANCE_H , R1 
0D16    8C4B          4921     MOV WT_ZC_SCAN_L , R4 
0D18    8D4C          4922     MOV WT_ZC_SCAN_H , R5 
0D1A    22            4923     	RET
                      4924     
                      4925     STORE_TIMES_DECREASE: 
0D1B    884D          4926     MOV WT_COMM_L , R0 
0D1D    894E          4927     MOV WT_COMM_H , R1 
0D1F    8A49          4928     MOV WT_ADVANCE_L , R2 
0D21    8B4A          4929     MOV WT_ADVANCE_H , R3 
0D23    8C4B          4930     MOV WT_ZC_SCAN_L , R4 
0D25    8D4C          4931     MOV WT_ZC_SCAN_H , R5 
0D27    22            4932     	RET
                      4933     
                      4934     
                      4935     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4936     ;
                      4937     ; Wait before zero cross scan routine
                      4938     ;
                      4939     ; No assumptions
                      4940     ;
                      4941     ; Waits for the zero cross scan wait time to elapse
                      4942     ; Also sets up timer 1 to wait the zero cross scan timeout time
                      4943     ;
                      4944     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4945     WAIT_BEFORE_ZC_SCAN: 	
0D28    305802        4946     JNB FLAGS0 . 0 , ( $+5 ) 
0D2B    A128          4947     	AJMP	WAIT_BEFORE_ZC_SCAN
                      4948     
0D2D    759100        4949     	MOV	TMR3CN, #00H		; Timer3 disabled
0D30    C3            4950     	CLR	C
0D31    E4            4951     	CLR	A
0D32    953B          4952     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0D34    F594          4953     	MOV	TMR3L, A
0D36    E4            4954     	CLR	A
0D37    953C          4955     	SUBB	A, COMM_PERIOD4X_H		
0D39    F595          4956     	MOV	TMR3H, A
0D3B    759104        4957     	MOV	TMR3CN, #04H		; Timer3 enabled
0D3E    D258          4958     SETB FLAGS0 . 0 
0D40    22            4959     	RET
                      4960     
                      4961     
                      4962     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4963     ;
                      4964     ; Wait for comparator to go low/high routines
                      4965     ;
                      4966     ; No assumptions
                      4967     ;
                      4968     ; Waits for the zero cross scan wait time to elapse
                      4969     ; Then scans for comparator going low/high
                      4970     ;
                      4971     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4972     WAIT_FOR_COMP_OUT_LOW: 
0D41    753E00        4973     	MOV	COMP_WAIT_READS, #0
0D44    752000        4974     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0D47    020D50        4975     	JMP	WAIT_FOR_COMP_OUT_START
                      4976     
                      4977     WAIT_FOR_COMP_OUT_HIGH: 
0D4A    753E00        4978     	MOV	COMP_WAIT_READS, #0
0D4D    752040        4979     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4980     
                      4981     WAIT_FOR_COMP_OUT_START: 
0D50    D2AF          4982     	SETB	EA						; Enable interrupts
0D52    053E          4983     	INC	COMP_WAIT_READS
0D54    205801        4984     JB FLAGS0 . 0 , ( $+4 ) 
0D57    22            4985     	RET							; Yes - return
                      4986     
                      4987     	; Set default comparator response times
0D58    759D00        4988     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
                      4989     IF COMP1_USED==1			
                               	MOV	CPT1MD, #0				; Set fast response (100ns) as default		
                               ENDIF
                      4992     	; Select number of comparator readings based upon current rotation speed
0D5B    E53C          4993     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0D5D    C3            4994     	CLR	C
0D5E    13            4995     	RRC	A						; Divide by 4
0D5F    C3            4996     	CLR	C
0D60    13            4997     	RRC	A
0D61    F8            4998     MOV R0 , A 
0D62    08            4999     INC R0 
0D63    6030          5000     	JZ	COMP_WAIT_ON_COMP_ABLE		; If minimum number of readings - jump directly to reading
                      5001     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0D65    306A06        5002     JNB FLAGS2 . 2 , COMP_WAIT_SET_MAX_READINGS 
                      5003     
0D68    C3            5004     	CLR	C
0D69    13            5005     	RRC	A						; Divide by 4 again
0D6A    C3            5006     	CLR	C
0D6B    13            5007     	RRC	A
0D6C    F8            5008     MOV R0 , A 
0D6D    08            5009     INC R0 
                      5010     
                      5011     COMP_WAIT_SET_MAX_READINGS: 
0D6E    C3            5012     	CLR	C
0D6F    E8            5013     MOV A , R0 
0D70    940A          5014     	SUBB	A, #10
0D72    4002          5015     	JC	($+4)
                      5016     
0D74    780A          5017     MOV R0 , # 10 
                      5018     
0D76    306D08        5019     JNB FLAGS2 . 5 , COMP_WAIT_SET_RESPONSE_TIME 
                      5020     
0D79    C3            5021     	CLR	C
0D7A    E8            5022     MOV A , R0 
0D7B    9404          5023     	SUBB	A, #4
0D7D    4002          5024     	JC	($+4)
                      5025     
0D7F    7804          5026     MOV R0 , # 4 
                      5027     
                      5028     COMP_WAIT_SET_RESPONSE_TIME: 
0D81    C3            5029     	CLR	C
0D82    E53C          5030     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0D84    9408          5031     	SUBB	A, #8
0D86    400D          5032     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      5033     
0D88    759D02        5034     	MOV	CPT0MD, #2				; Set medium response (300ns)
                      5035     IF COMP1_USED==1			
                               	MOV	CPT1MD, #2				; Set medium response (300ns)
                               ENDIF
0D8B    C3            5038     	CLR	C
0D8C    E53C          5039     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0D8E    9410          5040     	SUBB	A, #16
0D90    4003          5041     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      5042     
0D92    759D03        5043     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      5044     IF COMP1_USED==1			
                               	MOV	CPT1MD, #3				; Set slow response (1000ns) 	
                               ENDIF
                      5047     
                      5048     COMP_WAIT_ON_COMP_ABLE: 
0D95    205803        5049     JB FLAGS0 . 0 , ( $+6 ) 
0D98    D2AF          5050     	SETB	EA						; Enable interrupts
0D9A    22            5051     	RET							; Yes - return
                      5052     
0D9B    791E          5053     MOV R1 , # 30 
0D9D    206D02        5054     JB FLAGS2 . 5 , ( $+5 ) 
0DA0    790A          5055     MOV R1 , # 10 
0DA2    D2AF          5056     	SETB	EA							; Enable interrupts
0DA4    00            5057     	NOP								; Allocate only just enough time to capture interrupt
0DA5    00            5058     	NOP
0DA6    C2AF          5059     	CLR	EA							; Disable interrupts
0DA8    205A0A        5060     JB FLAGS0 . 2 , PWM_WAIT_STARTUP 
                      5061     
0DAB    793C          5062     MOV R1 , # 60 
0DAD    206D02        5063     JB FLAGS2 . 5 , ( $+5 ) 
0DB0    7914          5064     MOV R1 , # 20 
0DB2    306FE0        5065     JNB FLAGS2 . 7 , COMP_WAIT_ON_COMP_ABLE 
                      5066     
                      5067     PWM_WAIT_STARTUP: 						
0DB5    306302        5068     JNB FLAGS1 . 3 , PWM_WAIT 
                      5069     
0DB8    7978          5070     MOV R1 , # 120 
                      5071     PWM_WAIT: 						
0DBA    C3            5072     	CLR	C
0DBB    E58B          5073     	MOV	A, TL1
0DBD    99            5074     SUBB A , R1 
                      5075     IF DAMPED_MODE_ENABLE==0				
                               	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle for slower escs
                               ENDIF
                      5078     IF DAMPED_MODE_ENABLE==1				; Assume same pwm cycle for fast escs
0DBE    206302        5079     JB FLAGS1 . 3 , ( $+5 ) 
0DC1    40F7          5080     	JC	PWM_WAIT
0DC3    40D0          5081     	JC	COMP_WAIT_ON_COMP_ABLE		; Re-evaluate pwm cycle during direct start
                      5082     ENDIF
                      5083     
                      5084     COMP_READ: 
                      5085     	READ_COMP_OUT 					; Read comparator output
0DC5    E59B          5085+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0DC7    F4            5086     	CPL	A
0DC8    5440          5087     	ANL	A, #40H
0DCA    B52002        5088     	CJNE	A, BIT_ACCESS, ($+5)		; If comparator output is correct - proceed
                      5089     
0DCD    A150          5090     	AJMP	WAIT_FOR_COMP_OUT_START		; If comparator output is not correct - go back and restart
                      5091     
0DCF    D8C4          5092     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
                      5093     
0DD1    D2AF          5094     	SETB	EA						; Enable interrupts
0DD3    22            5095     	RET							
                      5096     
                      5097     
                      5098     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5099     ;
                      5100     ; Evaluate comparator integrity
                      5101     ;
                      5102     ; No assumptions
                      5103     ;
                      5104     ; Checks comparator signal behaviour versus expected behaviour
                      5105     ;
                      5106     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5107     EVALUATE_COMPARATOR_INTEGRITY: 
0DD4    C25B          5108     CLR FLAGS0 . 3 
                      5109     	; Check if demag compensation is enabled
0DD6    789C          5110     MOV R0 , # PGM_DEMAG_COMP 
0DD8    E6            5111     MOV A , @ R0 
0DD9    14            5112     	DEC	A
0DDA    6007          5113     	JZ	EVAL_COMP_NO_DEMAG
                      5114     
                      5115     	; Check if a demag situation has occurred
0DDC    E53E          5116     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none a demag situation has occurred
0DDE    14            5117     	DEC	A
0DDF    7002          5118     	JNZ	EVAL_COMP_NO_DEMAG
                      5119     
0DE1    D25B          5120     SETB FLAGS0 . 3 
                      5121     
                      5122     EVAL_COMP_NO_DEMAG: 
0DE3    30630B        5123     JNB FLAGS1 . 3 , EVAL_COMP_CHECK_TIMEOUT 
                      5124     
0DE6    0538          5125     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0DE8    205810        5126     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      5127     
0DEB    753800        5128     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0DEE    020DFB        5129     	JMP	EVAL_COMP_EXIT
                      5130     
                      5131     EVAL_COMP_CHECK_TIMEOUT: 
0DF1    205807        5132     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0DF4    1581          5133     	DEC	SP							; Routine exit without "ret" command
0DF6    1581          5134     	DEC	SP
0DF8    02174A        5135     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      5136     
                      5137     EVAL_COMP_EXIT: 
0DFB    22            5138     	RET
                      5139     
                      5140     
                      5141     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5142     ;
                      5143     ; Setup commutation timing routine
                      5144     ;
                      5145     ; No assumptions
                      5146     ;
                      5147     ; Sets up and starts wait from commutation to zero cross
                      5148     ;
                      5149     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5150     SETUP_COMM_WAIT:  
0DFC    759100        5151     	MOV	TMR3CN, #00H		; Timer3 disabled
0DFF    C3            5152     	CLR	C
0E00    E4            5153     	CLR	A
0E01    954D          5154     	SUBB	A, WT_COMM_L		; Set wait commutation value
0E03    F594          5155     	MOV	TMR3L, A
0E05    E4            5156     	CLR	A
0E06    954E          5157     	SUBB	A, WT_COMM_H		
0E08    F595          5158     	MOV	TMR3H, A
0E0A    759104        5159     	MOV	TMR3CN, #04H		; Timer3 enabled
0E0D    D258          5160     SETB FLAGS0 . 0 
0E0F    22            5161     	RET
                      5162     
                      5163     
                      5164     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5165     ;
                      5166     ; Wait for commutation routine
                      5167     ;
                      5168     ; No assumptions
                      5169     ;
                      5170     ; Waits from zero cross to commutation 
                      5171     ;
                      5172     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5173     WAIT_FOR_COMM:  
                      5174     	; Store motor power
0E10    AE25          5175     MOV R6 , CURRENT_PWM_LIMITED 
                      5176     	; Check if a demag situation has occurred
0E12    305B4F        5177     JNB FLAGS0 . 3 , WAIT_FOR_COMM_WAIT 
                      5178     
                      5179     	; Load programmed demag compensation
0E15    78A3          5180     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
0E17    E6            5181     MOV A , @ R0 
0E18    FF            5182     MOV R7 , A 
                      5183     
                      5184     	; Check for first power off
0E19    BF010B        5185     CJNE R7 , # 1 , WAIT_FOR_COMM_BLIND 
                      5186     
0E1C    D25C          5187     SETB FLAGS0 . 4 
0E1E    752500        5188     	MOV	CURRENT_PWM_LIMITED, #0				
                      5189     	ALL_NFETS_OFF
0E21    C292          5189+1   CLR P1 . 2 
0E23    C296          5189+1   CLR P1 . 6 
0E25    C295          5189+1   CLR P1 . 5 
                      5190     
                      5191     	; Wait a blind wait
                      5192     WAIT_FOR_COMM_BLIND: 
0E27    9190          5193     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      5194     WAIT_DEMAG_DEFAULT_ZC1: 	
0E29    305C03        5195     JNB FLAGS0 . 4 , ( $+6 ) 
0E2C    752500        5196     	MOV	CURRENT_PWM_LIMITED, #0			
0E2F    305802        5197     JNB FLAGS0 . 0 , ( $+5 ) 
0E32    C129          5198     	AJMP	WAIT_DEMAG_DEFAULT_ZC1
                      5199     
                      5200     	; Check for second power off
0E34    BF020B        5201     CJNE R7 , # 2 , WAIT_FOR_COMM_SECOND_BLIND_WAIT 
                      5202     
0E37    D25C          5203     SETB FLAGS0 . 4 
0E39    752500        5204     	MOV	CURRENT_PWM_LIMITED, #0				
                      5205     	ALL_NFETS_OFF
0E3C    C292          5205+1   CLR P1 . 2 
0E3E    C296          5205+1   CLR P1 . 6 
0E40    C295          5205+1   CLR P1 . 5 
                      5206     
                      5207     	; Check for another blind wait
                      5208     WAIT_FOR_COMM_SECOND_BLIND_WAIT: 
0E42    78A2          5209     MOV R0 , # PGM_DEMAG_COMP_WAIT_DECODED 
0E44    B6010D        5210     CJNE @ R0 , # 1 , WAIT_FOR_COMM_POWER3 
                      5211     
0E47    9190          5212     	CALL	SETUP_ZC_SCAN_WAIT					; Setup a zero cross scan wait (7.5 deg)
                      5213     WAIT_DEMAG_DEFAULT_ZC2: 	
0E49    305C03        5214     JNB FLAGS0 . 4 , ( $+6 ) 
0E4C    752500        5215     	MOV	CURRENT_PWM_LIMITED, #0			
0E4F    305802        5216     JNB FLAGS0 . 0 , ( $+5 ) 
0E52    C149          5217     	AJMP	WAIT_DEMAG_DEFAULT_ZC2
                      5218     
                      5219     WAIT_FOR_COMM_POWER3: 
                      5220     	; Check for third power off
0E54    BF030B        5221     CJNE R7 , # 3 , WAIT_FOR_COMM_SETUP 
                      5222     
0E57    D25C          5223     SETB FLAGS0 . 4 
0E59    752500        5224     	MOV	CURRENT_PWM_LIMITED, #0				
                      5225     	ALL_NFETS_OFF
0E5C    C292          5225+1   CLR P1 . 2 
0E5E    C296          5225+1   CLR P1 . 6 
0E60    C295          5225+1   CLR P1 . 5 
                      5226     
                      5227     WAIT_FOR_COMM_SETUP: 
0E62    B1FC          5228     	CALL	SETUP_COMM_WAIT					; Setup commutation wait
                      5229     WAIT_FOR_COMM_WAIT: 
0E64    305C03        5230     JNB FLAGS0 . 4 , ( $+6 ) 
0E67    752500        5231     	MOV	CURRENT_PWM_LIMITED, #0			
0E6A    305802        5232     JNB FLAGS0 . 0 , ( $+5 ) 
0E6D    C164          5233     	AJMP	WAIT_FOR_COMM_WAIT					
                      5234     
0E6F    305B04        5235     JNB FLAGS0 . 3 , WAIT_FOR_COMM_EXIT 
                      5236     
0E72    C25C          5237     CLR FLAGS0 . 4 
0E74    8E25          5238     MOV CURRENT_PWM_LIMITED , R6 
                      5239     
                      5240     WAIT_FOR_COMM_EXIT: 
0E76    22            5241     	RET
                      5242     
                      5243     
                      5244     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5245     ;
                      5246     ; Commutation routines
                      5247     ;
                      5248     ; No assumptions
                      5249     ;
                      5250     ; Performs commutation switching 
                      5251     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      5252     ;
                      5253     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5254     COMM1COMM2: 	
0E77    C2AF          5255     	CLR 	EA					; Disable all interrupts
                      5256     	BPFET_OFF					; Bp off
0E79    C294          5256+1   CLR P1 . 4 
0E7B    206A03        5257     JB FLAGS2 . 2 , COMM12_DAMP 
0E7E    020E96        5258     	JMP	COMM12_NONDAMP
                      5259     COMM12_DAMP: 
                      5260     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM12_NONDAMP
                               ENDIF
                      5264     IF DAMPED_MODE_ENABLE == 1
0E81    90034B        5265     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
                      5266     ENDIF
0E84    306E0F        5267     JNB FLAGS2 . 6 , COMM12_NONDAMP 
                      5268     	CPFET_OFF				
0E87    207502        5268+1   JB FLAGS3 . 5 , ( $+5 ) 
0E8A    C297          5268+1   CLR P1 . 7 
0E8C    307502        5268+1   JNB FLAGS3 . 5 , ( $+5 ) 
0E8F    C293          5268+1   CLR P1 . 3 
0E91    7406          5269     MOV A , # 6 
0E93    D5E0FD        5270     	DJNZ ACC,	$
                      5271     COMM12_NONDAMP: 
                      5272     	APFET_ON					; Ap on
0E96    207502        5272+1   JB FLAGS3 . 5 , ( $+5 ) 
0E99    D293          5272+1   SETB P1 . 3 
0E9B    307502        5272+1   JNB FLAGS3 . 5 , ( $+5 ) 
0E9E    D297          5272+1   SETB P1 . 7 
                      5273     	SET_COMP_PHASE_B 			; Set comparator to phase B
0EA0    759F80        5273+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0EA3    753D02        5274     	MOV	COMM_PHASE, #2
0EA6    D2AF          5275     	SETB	EA					; Enable all interrupts
0EA8    22            5276     	RET
                      5277     
                      5278     COMM2COMM3: 	
0EA9    C2AF          5279     	CLR 	EA					; Disable all interrupts
0EAB    206A03        5280     JB FLAGS2 . 2 , COMM23_DAMP 
0EAE    020ECB        5281     	JMP	COMM23_NONDAMP
                      5282     COMM23_DAMP: 
                      5283     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                               ENDIF
                      5286     IF DAMPED_MODE_ENABLE == 1
0EB1    900302        5287     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE	
                      5288     ENDIF
0EB4    306E17        5289     JNB FLAGS2 . 6 , COMM23_NFET 
                      5290     	BPFET_OFF				
0EB7    C294          5290+1   CLR P1 . 4 
                      5291     	CPFET_OFF				
0EB9    207502        5291+1   JB FLAGS3 . 5 , ( $+5 ) 
0EBC    C297          5291+1   CLR P1 . 7 
0EBE    307502        5291+1   JNB FLAGS3 . 5 , ( $+5 ) 
0EC1    C293          5291+1   CLR P1 . 3 
0EC3    7406          5292     MOV A , # 6 
0EC5    D5E0FD        5293     	DJNZ ACC,	$
0EC8    020ECE        5294     	JMP	COMM23_NFET
                      5295     COMM23_NONDAMP: 
0ECB    9001E5        5296     	MOV	DPTR, #PWM_BFET_ON	
                      5297     COMM23_NFET: 
                      5298     	CNFET_OFF					; Cn off
0ECE    207502        5298+1   JB FLAGS3 . 5 , ( $+5 ) 
0ED1    C296          5298+1   CLR P1 . 6 
0ED3    307502        5298+1   JNB FLAGS3 . 5 , ( $+5 ) 
0ED6    C292          5298+1   CLR P1 . 2 
0ED8    305A06        5299     JNB FLAGS0 . 2 , COMM23_CP 
                      5300     	BNFET_ON					; Yes - Bn on
0EDB    E525          5300+1   MOV A , CURRENT_PWM_LIMITED 
0EDD    6002          5300+1   JZ ( $+4 ) 
0EDF    D295          5300+1   SETB P1 . 5 
                      5301     COMM23_CP: 
                      5302     	SET_COMP_PHASE_C 			; Set comparator to phase C
0EE1    207503        5302+1   JB FLAGS3 . 5 , ( $+6 ) 
0EE4    759F89        5302+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0EE7    307503        5302+1   JNB FLAGS3 . 5 , ( $+6 ) 
0EEA    759F81        5302+1   MOV CPT0MX , # 81H 
0EED    753D03        5303     	MOV	COMM_PHASE, #3
0EF0    D2AF          5304     	SETB	EA					; Enable all interrupts
0EF2    22            5305     	RET
                      5306     
                      5307     COMM3COMM4: 	
0EF3    C2AF          5308     	CLR 	EA					; Disable all interrupts
                      5309     	APFET_OFF					; Ap off
0EF5    207502        5309+1   JB FLAGS3 . 5 , ( $+5 ) 
0EF8    C293          5309+1   CLR P1 . 3 
0EFA    307502        5309+1   JNB FLAGS3 . 5 , ( $+5 ) 
0EFD    C297          5309+1   CLR P1 . 7 
0EFF    206A03        5310     JB FLAGS2 . 2 , COMM34_DAMP 
0F02    020F12        5311     	JMP	COMM34_NONDAMP
                      5312     COMM34_DAMP: 
                      5313     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM34_NONDAMP
                               ENDIF
                      5317     IF DAMPED_MODE_ENABLE == 1
0F05    9002C1        5318     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
                      5319     ENDIF
0F08    306E07        5320     JNB FLAGS2 . 6 , COMM34_NONDAMP 
                      5321     	BPFET_OFF				
0F0B    C294          5321+1   CLR P1 . 4 
0F0D    7406          5322     MOV A , # 6 
0F0F    D5E0FD        5323     	DJNZ ACC,	$
                      5324     COMM34_NONDAMP: 
                      5325     	CPFET_ON					; Cp on
0F12    207502        5325+1   JB FLAGS3 . 5 , ( $+5 ) 
0F15    D297          5325+1   SETB P1 . 7 
0F17    307502        5325+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F1A    D293          5325+1   SETB P1 . 3 
                      5326     	SET_COMP_PHASE_A 			; Set comparator to phase A
0F1C    207503        5326+1   JB FLAGS3 . 5 , ( $+6 ) 
0F1F    759F81        5326+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0F22    307503        5326+1   JNB FLAGS3 . 5 , ( $+6 ) 
0F25    759F89        5326+1   MOV CPT0MX , # 89H 
0F28    753D04        5327     	MOV	COMM_PHASE, #4
0F2B    D2AF          5328     	SETB	EA					; Enable all interrupts
0F2D    22            5329     	RET
                      5330     
                      5331     COMM4COMM5: 	
0F2E    C2AF          5332     	CLR 	EA					; Disable all interrupts
0F30    206A03        5333     JB FLAGS2 . 2 , COMM45_DAMP 
0F33    020F50        5334     	JMP	COMM45_NONDAMP
                      5335     COMM45_DAMP: 
                      5336     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                               ENDIF
                      5339     IF DAMPED_MODE_ENABLE == 1
0F36    900280        5340     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      5341     ENDIF
0F39    306E17        5342     JNB FLAGS2 . 6 , COMM45_NFET 
                      5343     	APFET_OFF				
0F3C    207502        5343+1   JB FLAGS3 . 5 , ( $+5 ) 
0F3F    C293          5343+1   CLR P1 . 3 
0F41    307502        5343+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F44    C297          5343+1   CLR P1 . 7 
                      5344     	BPFET_OFF				
0F46    C294          5344+1   CLR P1 . 4 
0F48    7406          5345     MOV A , # 6 
0F4A    D5E0FD        5346     	DJNZ ACC,	$
0F4D    020F53        5347     	JMP	COMM45_NFET
                      5348     COMM45_NONDAMP: 
0F50    9001D3        5349     	MOV	DPTR, #PWM_AFET_ON
                      5350     COMM45_NFET: 
                      5351     	BNFET_OFF					; Bn off
0F53    C295          5351+1   CLR P1 . 5 
0F55    305A0E        5352     JNB FLAGS0 . 2 , COMM45_CP 
                      5353     	ANFET_ON					; Yes - An on
0F58    E525          5353+1   MOV A , CURRENT_PWM_LIMITED 
0F5A    600A          5353+1   JZ ( $+12 ) 
0F5C    207502        5353+1   JB FLAGS3 . 5 , ( $+5 ) 
0F5F    D292          5353+1   SETB P1 . 2 
0F61    307502        5353+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F64    D296          5353+1   SETB P1 . 6 
                      5354     COMM45_CP: 
                      5355     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F66    759F80        5355+1   MOV CPT0MX , # 80H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F69    753D05        5356     	MOV	COMM_PHASE, #5
0F6C    D2AF          5357     	SETB	EA					; Enable all interrupts
0F6E    22            5358     	RET
                      5359     
                      5360     COMM5COMM6: 	
0F6F    C2AF          5361     	CLR 	EA					; Disable all interrupts
                      5362     	CPFET_OFF					; Cp off
0F71    207502        5362+1   JB FLAGS3 . 5 , ( $+5 ) 
0F74    C297          5362+1   CLR P1 . 7 
0F76    307502        5362+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F79    C293          5362+1   CLR P1 . 3 
0F7B    206A03        5363     JB FLAGS2 . 2 , COMM56_DAMP 
0F7E    020F96        5364     	JMP	COMM56_NONDAMP
                      5365     COMM56_DAMP: 
                      5366     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                               	JB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT, COMM56_NONDAMP
                               ENDIF
                      5370     IF DAMPED_MODE_ENABLE == 1
0F81    900237        5371     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
                      5372     ENDIF
0F84    306E0F        5373     JNB FLAGS2 . 6 , COMM56_NONDAMP 
                      5374     	APFET_OFF				
0F87    207502        5374+1   JB FLAGS3 . 5 , ( $+5 ) 
0F8A    C293          5374+1   CLR P1 . 3 
0F8C    307502        5374+1   JNB FLAGS3 . 5 , ( $+5 ) 
0F8F    C297          5374+1   CLR P1 . 7 
0F91    7406          5375     MOV A , # 6 
0F93    D5E0FD        5376     	DJNZ ACC,	$
                      5377     COMM56_NONDAMP: 
                      5378     	BPFET_ON					; Bp on
0F96    D294          5378+1   SETB P1 . 4 
                      5379     	SET_COMP_PHASE_C 			; Set comparator to phase C
0F98    207503        5379+1   JB FLAGS3 . 5 , ( $+6 ) 
0F9B    759F89        5379+1   MOV CPT0MX , # 89H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F9E    307503        5379+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FA1    759F81        5379+1   MOV CPT0MX , # 81H 
0FA4    753D06        5380     	MOV	COMM_PHASE, #6
0FA7    D2AF          5381     	SETB	EA					; Enable all interrupts
0FA9    22            5382     	RET
                      5383     
                      5384     COMM6COMM1: 	
0FAA    C2AF          5385     	CLR 	EA					; Disable all interrupts
0FAC    206A03        5386     JB FLAGS2 . 2 , COMM61_DAMP 
0FAF    020FD4        5387     	JMP	COMM61_NONDAMP
                      5388     COMM61_DAMP: 
                      5389     IF DAMPED_MODE_ENABLE == 0
                               	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                               ENDIF
                      5392     IF DAMPED_MODE_ENABLE == 1
0FB2    9003A4        5393     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      5394     ENDIF
0FB5    306E1F        5395     JNB FLAGS2 . 6 , COMM61_NFET 
                      5396     	APFET_OFF				
0FB8    207502        5396+1   JB FLAGS3 . 5 , ( $+5 ) 
0FBB    C293          5396+1   CLR P1 . 3 
0FBD    307502        5396+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FC0    C297          5396+1   CLR P1 . 7 
                      5397     	CPFET_OFF				
0FC2    207502        5397+1   JB FLAGS3 . 5 , ( $+5 ) 
0FC5    C297          5397+1   CLR P1 . 7 
0FC7    307502        5397+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FCA    C293          5397+1   CLR P1 . 3 
0FCC    7406          5398     MOV A , # 6 
0FCE    D5E0FD        5399     	DJNZ ACC,	$
0FD1    020FD7        5400     	JMP	COMM61_NFET
                      5401     COMM61_NONDAMP: 
0FD4    9001F7        5402     	MOV	DPTR, #PWM_CFET_ON
                      5403     COMM61_NFET: 
                      5404     	ANFET_OFF					; An off
0FD7    207502        5404+1   JB FLAGS3 . 5 , ( $+5 ) 
0FDA    C292          5404+1   CLR P1 . 2 
0FDC    307502        5404+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FDF    C296          5404+1   CLR P1 . 6 
0FE1    305A0E        5405     JNB FLAGS0 . 2 , COMM61_CP 
                      5406     	CNFET_ON					; Yes - Cn on
0FE4    E525          5406+1   MOV A , CURRENT_PWM_LIMITED 
0FE6    600A          5406+1   JZ ( $+12 ) 
0FE8    207502        5406+1   JB FLAGS3 . 5 , ( $+5 ) 
0FEB    D296          5406+1   SETB P1 . 6 
0FED    307502        5406+1   JNB FLAGS3 . 5 , ( $+5 ) 
0FF0    D292          5406+1   SETB P1 . 2 
                      5407     COMM61_CP: 
                      5408     	SET_COMP_PHASE_A 			; Set comparator to phase A
0FF2    207503        5408+1   JB FLAGS3 . 5 , ( $+6 ) 
0FF5    759F81        5408+1   MOV CPT0MX , # 81H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0FF8    307503        5408+1   JNB FLAGS3 . 5 , ( $+6 ) 
0FFB    759F89        5408+1   MOV CPT0MX , # 89H 
0FFE    753D01        5409     	MOV	COMM_PHASE, #1
1001    D2AF          5410     	SETB	EA					; Enable all interrupts
1003    22            5411     	RET
                      5412     
                      5413     
                      5414     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5415     ;
                      5416     ; Switch power off routine
                      5417     ;
                      5418     ; No assumptions
                      5419     ;
                      5420     ; Switches all fets off 
                      5421     ;
                      5422     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5423     SWITCH_POWER_OFF: 
1004    9001D1        5424     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      5425     	ALL_NFETS_OFF			; Turn off all nfets
1007    C292          5425+1   CLR P1 . 2 
1009    C296          5425+1   CLR P1 . 6 
100B    C295          5425+1   CLR P1 . 5 
                      5426     	ALL_PFETS_OFF			; Turn off all pfets
100D    C293          5426+1   CLR P1 . 3 
100F    C297          5426+1   CLR P1 . 7 
1011    C294          5426+1   CLR P1 . 4 
1013    22            5427     	RET			
                      5428     
                      5429     
                      5430     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5431     ;
                      5432     ; Decrement stepper step routine
                      5433     ;
                      5434     ; No assumptions
                      5435     ;
                      5436     ; Decrements the stepper step 
                      5437     ;
                      5438     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5439     DECREMENT_STEPPER_STEP: 
1014    C3            5440     	CLR	C
1015    E54F          5441     	MOV	A, WT_STEPPER_STEP_L
1017    9535          5442     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
1019    E550          5443     	MOV	A, WT_STEPPER_STEP_H
101B    9536          5444     	SUBB	A, STEPPER_STEP_END_H	
101D    5001          5445     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
101F    22            5446     	RET
                      5447     
                      5448     DECREMENT_STEP: 
                      5449     	; Load programmed startup acceleration
1020    7890          5450     MOV R0 , # PGM_STARTUP_ACCEL 
1022    E6            5451     MOV A , @ R0 
1023    FF            5452     MOV R7 , A 
                      5453     	; Check acceleration setting and set step size accordingly
1024    C3            5454     	CLR	C
1025    EF            5455     MOV A , R7 
1026    9405          5456     	SUBB	A, #5
1028    5018          5457     	JNC	DEC_STEP_HIGH
102A    C3            5458     	CLR	C
102B    EF            5459     MOV A , R7 
102C    9404          5460     	SUBB	A, #4
102E    501B          5461     	JNC	DEC_STEP_MED_HIGH
1030    C3            5462     	CLR	C
1031    EF            5463     MOV A , R7 
1032    9403          5464     	SUBB	A, #3
1034    501E          5465     	JNC	DEC_STEP_MED
1036    C3            5466     	CLR	C
1037    EF            5467     MOV A , R7 
1038    9402          5468     	SUBB	A, #2
103A    5021          5469     	JNC	DEC_STEP_MED_LOW
103C    C3            5470     	CLR	C
103D    EF            5471     MOV A , R7 
103E    9401          5472     	SUBB	A, #1
1040    5024          5473     	JNC	DEC_STEP_LOW
                      5474     
                      5475     DEC_STEP_HIGH: 
1042    C3            5476     	CLR	C
1043    E54F          5477     	MOV	A, WT_STEPPER_STEP_L
1045    943C          5478     	SUBB	A, #LOW(30 SHL 1)		
1047    F8            5479     MOV R0 , A 
1048    02106F        5480     	JMP	DECREMENT_STEP_EXIT
                      5481     DEC_STEP_MED_HIGH: 
104B    C3            5482     	CLR	C
104C    E54F          5483     	MOV	A, WT_STEPPER_STEP_L
104E    9428          5484     	SUBB	A, #LOW(20 SHL 1)		
1050    F8            5485     MOV R0 , A 
1051    02106F        5486     	JMP	DECREMENT_STEP_EXIT
                      5487     DEC_STEP_MED: 
1054    C3            5488     	CLR	C
1055    E54F          5489     	MOV	A, WT_STEPPER_STEP_L
1057    941A          5490     	SUBB	A, #LOW(13 SHL 1)		
1059    F8            5491     MOV R0 , A 
105A    02106F        5492     	JMP	DECREMENT_STEP_EXIT
                      5493     DEC_STEP_MED_LOW: 
105D    C3            5494     	CLR	C
105E    E54F          5495     	MOV	A, WT_STEPPER_STEP_L
1060    9412          5496     	SUBB	A, #LOW(9 SHL 1)		
1062    F8            5497     MOV R0 , A 
1063    02106F        5498     	JMP	DECREMENT_STEP_EXIT
                      5499     DEC_STEP_LOW: 
1066    C3            5500     	CLR	C
1067    E54F          5501     	MOV	A, WT_STEPPER_STEP_L
1069    940A          5502     	SUBB	A, #LOW(5 SHL 1)		
106B    F8            5503     MOV R0 , A 
106C    02106F        5504     	JMP	DECREMENT_STEP_EXIT
                      5505     
                      5506     DECREMENT_STEP_EXIT: 
106F    E550          5507     	MOV	A, WT_STEPPER_STEP_H
1071    9400          5508     	SUBB	A, #0		
1073    F9            5509     MOV R1 , A 
1074    884F          5510     MOV WT_STEPPER_STEP_L , R0 
1076    8950          5511     MOV WT_STEPPER_STEP_H , R1 
1078    22            5512     	RET
                      5513     
                      5514     
                      5515     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5516     ;
                      5517     ; Stepper timer wait
                      5518     ;
                      5519     ; No assumptions
                      5520     ;
                      5521     ; Waits for the stepper step timer to elapse
                      5522     ;
                      5523     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5524     STEPPER_TIMER_WAIT: 
1079    305803        5525     JNB FLAGS0 . 0 , ( $+6 ) 
107C    021079        5526     	LJMP	STEPPER_TIMER_WAIT		; Yes, go back
107F    22            5527     	RET
                      5528     
                      5529     
                      5530     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5531     ;
                      5532     ; Set default parameters
                      5533     ;
                      5534     ; No assumptions
                      5535     ;
                      5536     ; Sets default programming parameters
                      5537     ;
                      5538     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5539     SET_DEFAULT_PARAMETERS: 
                      5540     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	MOV	TEMP1, #PGM_GOV_I_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	MOV	TEMP1, #PGM_GOV_MODE
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	MOV	TEMP1, #PGM_GOV_RANGE
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	MOV	TEMP1, #PGM_LOW_VOLTAGE_LIM
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	MOV	TEMP1, #PGM_STARTUP_PWR
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	MOV	TEMP1, #PGM_STARTUP_RPM
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	MOV	TEMP1, #PGM_STARTUP_ACCEL
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	MOV	TEMP1, #PGM_STARTUP_METHOD
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	MOV	TEMP1, #PGM_COMM_TIMING
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	MOV	TEMP1, #PGM_THROTTLE_RATE
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	MOV	TEMP1, #PGM_DAMPING_FORCE
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	MOV	TEMP1, #PGM_PWM_FREQ
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	MOV	TEMP1, #PGM_DEMAG_COMP
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DEMAG_COMP
                               	MOV	TEMP1, #PGM_DIRECTION_REV
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION_REV
                               	MOV	TEMP1, #PGM_INPUT_POL
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               	MOV	TEMP1, #PGM_MOTOR_IDLE
                               	MOV	@TEMP1, #0
                               ENDIF
                      5576     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_MOTOR_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	MOV	TEMP1, #PGM_MOTOR_IDLE
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	MOV	TEMP1, #PGM_STARTUP_PWR
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	MOV	TEMP1, #PGM_STARTUP_RPM
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	MOV	TEMP1, #PGM_STARTUP_ACCEL
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	MOV	TEMP1, #PGM_STARTUP_METHOD
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	MOV	TEMP1, #PGM_COMM_TIMING
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	MOV	TEMP1, #PGM_THROTTLE_RATE
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	MOV	TEMP1, #PGM_DAMPING_FORCE
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	MOV	TEMP1, #PGM_PWM_FREQ
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	MOV	TEMP1, #PGM_DEMAG_COMP
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                               	MOV	TEMP1, #PGM_DIRECTION_REV
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION_REV
                               	MOV	TEMP1, #PGM_INPUT_POL
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               	MOV	TEMP1, #PGM_GOV_MODE
                               	MOV	@TEMP1, #4
                               ENDIF
                      5606     IF MODE == 2	; Multi
1080    7880          5607     MOV R0 , # PGM_GOV_P_GAIN 
1082    7607          5608     MOV @ R0 , # 7 
1084    7881          5609     MOV R0 , # PGM_GOV_I_GAIN 
1086    7607          5610     MOV @ R0 , # 7 
1088    7882          5611     MOV R0 , # PGM_GOV_MODE 
108A    7601          5612     MOV @ R0 , # 1 
108C    7884          5613     MOV R0 , # PGM_MOTOR_GAIN 
108E    7603          5614     MOV @ R0 , # 3 
1090    7883          5615     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
1092    7601          5616     MOV @ R0 , # 1 
1094    7886          5617     MOV R0 , # PGM_STARTUP_PWR 
1096    7609          5618     MOV @ R0 , # 9 
1098    788F          5619     MOV R0 , # PGM_STARTUP_RPM 
109A    7601          5620     MOV @ R0 , # 1 
109C    7890          5621     MOV R0 , # PGM_STARTUP_ACCEL 
109E    7605          5622     MOV @ R0 , # 5 
10A0    7895          5623     MOV R0 , # PGM_STARTUP_METHOD 
10A2    7602          5624     MOV @ R0 , # 2 
10A4    7892          5625     MOV R0 , # PGM_COMM_TIMING 
10A6    7603          5626     MOV @ R0 , # 3 
10A8    789B          5627     MOV R0 , # PGM_THROTTLE_RATE 
10AA    760D          5628     MOV @ R0 , # 13 
10AC    7893          5629     MOV R0 , # PGM_DAMPING_FORCE 
10AE    7606          5630     MOV @ R0 , # 6 
10B0    7887          5631     MOV R0 , # PGM_PWM_FREQ 
10B2    7601          5632     MOV @ R0 , # 1 
10B4    789C          5633     MOV R0 , # PGM_DEMAG_COMP 
10B6    7602          5634     MOV @ R0 , # 2 
10B8    7888          5635     MOV R0 , # PGM_DIRECTION_REV 
10BA    7601          5636     MOV @ R0 , # 1 
10BC    7889          5637     MOV R0 , # PGM_INPUT_POL 
10BE    7601          5638     MOV @ R0 , # 1 
10C0    7885          5639     MOV R0 , # PGM_MOTOR_IDLE 
10C2    7600          5640     MOV @ R0 , # 0 
                      5641     ENDIF
10C4    788C          5642     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
10C6    7601          5643     MOV @ R0 , # 1 
10C8    788D          5644     MOV R0 , # PGM_MAIN_REARM_START 
10CA    7600          5645     MOV @ R0 , # 0 
10CC    788E          5646     MOV R0 , # PGM_GOV_SETUP_TARGET 
10CE    76B4          5647     MOV @ R0 , # 180 
10D0    7896          5648     MOV R0 , # PGM_PPM_MIN_THROTTLE 
10D2    7625          5649     MOV @ R0 , # 37 
10D4    7897          5650     MOV R0 , # PGM_PPM_MAX_THROTTLE 
10D6    76D0          5651     MOV @ R0 , # 208 
10D8    7898          5652     MOV R0 , # PGM_BEEP_STRENGTH 
10DA    7678          5653     MOV @ R0 , # 120 
10DC    7899          5654     MOV R0 , # PGM_BEACON_STRENGTH 
10DE    76C8          5655     MOV @ R0 , # 200 
10E0    789A          5656     MOV R0 , # PGM_BEACON_DELAY 
10E2    7604          5657     MOV @ R0 , # 4 
10E4    789D          5658     MOV R0 , # PGM_BEC_VOLTAGE_HIGH 
10E6    7600          5659     MOV @ R0 , # 0 
10E8    22            5660     	RET
                      5661     
                      5662     
                      5663     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5664     ;
                      5665     ; Decode parameters
                      5666     ;
                      5667     ; No assumptions
                      5668     ;
                      5669     ; Decodes programming parameters
                      5670     ;
                      5671     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5672     DECODE_PARAMETERS: 
                      5673     	; Load programmed damping force
10E9    7893          5674     MOV R0 , # PGM_DAMPING_FORCE 
10EB    E6            5675     MOV A , @ R0 
10EC    FF            5676     MOV R7 , A 
                      5677     	; Decode damping
10ED    756409        5678     	MOV	DAMPING_PERIOD, #9		; Set default
10F0    756501        5679     	MOV	DAMPING_ON, #1
10F3    C3            5680     	CLR	C
10F4    BF0209        5681     CJNE R7 , # 2 , DECODE_DAMPING_3 
                      5682     
10F7    756405        5683     	MOV	DAMPING_PERIOD, #5
10FA    756501        5684     	MOV	DAMPING_ON, #1
10FD    02112E        5685     	JMP	DECODE_DAMPING_DONE
                      5686     
                      5687     DECODE_DAMPING_3: 
1100    C3            5688     	CLR	C
1101    BF0309        5689     CJNE R7 , # 3 , DECODE_DAMPING_4 
                      5690     
1104    756405        5691     	MOV	DAMPING_PERIOD, #5
1107    756502        5692     	MOV	DAMPING_ON, #2
110A    02112E        5693     	JMP	DECODE_DAMPING_DONE
                      5694     
                      5695     DECODE_DAMPING_4: 
110D    C3            5696     	CLR	C
110E    BF0409        5697     CJNE R7 , # 4 , DECODE_DAMPING_5 
                      5698     
1111    756405        5699     	MOV	DAMPING_PERIOD, #5
1114    756503        5700     	MOV	DAMPING_ON, #3
1117    02112E        5701     	JMP	DECODE_DAMPING_DONE
                      5702     
                      5703     DECODE_DAMPING_5: 
111A    C3            5704     	CLR	C
111B    BF0506        5705     CJNE R7 , # 5 , DECODE_DAMPING_6 
                      5706     
111E    756409        5707     	MOV	DAMPING_PERIOD, #9
1121    756507        5708     	MOV	DAMPING_ON, #7
                      5709     
                      5710     DECODE_DAMPING_6: 
1124    C3            5711     	CLR	C
1125    BF0606        5712     CJNE R7 , # 6 , DECODE_DAMPING_DONE 
                      5713     
1128    756400        5714     	MOV	DAMPING_PERIOD, #0
112B    756500        5715     	MOV	DAMPING_ON, #0
                      5716     
                      5717     DECODE_DAMPING_DONE: 
                      5718     	; Load programmed pwm frequency
112E    7887          5719     MOV R0 , # PGM_PWM_FREQ 
1130    E6            5720     MOV A , @ R0 
1131    FF            5721     MOV R7 , A 
                      5722     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	CJNE	TEMP8, #3, ($+5)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      5729     IF MODE >= 1	; Tail or multi
1132    C26C          5730     CLR FLAGS2 . 4 
1134    C3            5731     	CLR	C
1135    BF0302        5732     CJNE R7 , # 3 , ( $+5 ) 
1138    D26C          5733     SETB FLAGS2 . 4 
113A    C26B          5734     CLR FLAGS2 . 3 
113C    C3            5735     	CLR	C
113D    BF0402        5736     CJNE R7 , # 4 , ( $+5 ) 
1140    D26B          5737     SETB FLAGS2 . 3 
                      5738     ENDIF
1142    C26A          5739     CLR FLAGS2 . 2 
1144    7418          5740     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
1146    552D          5741     	ANL	A, FLAGS2					; Check if any damped mode is set
1148    6002          5742     	JZ	($+4)
114A    D26A          5743     SETB FLAGS2 . 2 
114C    C26E          5744     CLR FLAGS2 . 6 
114E    6002          5745     	JZ	($+4)
1150    D26E          5746     SETB FLAGS2 . 6 
1152    D26F          5747     SETB FLAGS2 . 7 
1154    6002          5748     	JZ	($+4)
1156    C26F          5749     CLR FLAGS2 . 7 
1158    C275          5750     CLR FLAGS3 . 5 
115A    7888          5751     MOV R0 , # PGM_DIRECTION_REV 
115C    E6            5752     MOV A , @ R0 
115D    30E102        5753     	JNB	ACC.1, ($+5)
1160    D275          5754     SETB FLAGS3 . 5 
1162    C276          5755     CLR FLAGS3 . 6 
1164    7889          5756     MOV R0 , # PGM_INPUT_POL 
1166    E6            5757     MOV A , @ R0 
1167    30E102        5758     	JNB	ACC.1, ($+5)
116A    D276          5759     SETB FLAGS3 . 6 
116C    C3            5760     	CLR	C
116D    EF            5761     MOV A , R7 
116E    9402          5762     	SUBB	A, #2
1170    6008          5763     	JZ	DECODE_PWM_FREQ_LOW
                      5764     
1172    758E01        5765     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
1175    D26D          5766     SETB FLAGS2 . 5 
1177    02117F        5767     	JMP	DECODE_PWM_FREQ_END
                      5768     
                      5769     DECODE_PWM_FREQ_LOW: 
117A    758E00        5770     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
117D    C26D          5771     CLR FLAGS2 . 5 
                      5772     
                      5773     DECODE_PWM_FREQ_END: 
117F    22            5774     	RET
                      5775     
                      5776     
                      5777     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5778     ;
                      5779     ; Decode governor gain
                      5780     ;
                      5781     ; No assumptions
                      5782     ;
                      5783     ; Decodes governor gains
                      5784     ;
                      5785     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5786     DECODE_GOVERNOR_GAINS: 
                      5787     	; Decode governor gains
1180    7880          5788     MOV R0 , # PGM_GOV_P_GAIN 
1182    E6            5789     MOV A , @ R0 
1183    14            5790     	DEC	A	
1184    900080        5791     	MOV	DPTR, #GOV_GAIN_TABLE
1187    93            5792     	MOVC A, @A+DPTR	
1188    789E          5793     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
118A    F6            5794     MOV @ R0 , A 
118B    7881          5795     MOV R0 , # PGM_GOV_I_GAIN 
118D    E6            5796     MOV A , @ R0 
118E    14            5797     	DEC	A	
118F    900080        5798     	MOV	DPTR, #GOV_GAIN_TABLE
1192    93            5799     	MOVC A, @A+DPTR	
1193    789F          5800     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1195    F6            5801     MOV @ R0 , A 
1196    1104          5802     	CALL	SWITCH_POWER_OFF		; Reset DPTR
1198    22            5803     	RET
                      5804     
                      5805     
                      5806     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5807     ;
                      5808     ; Decode throttle rate
                      5809     ;
                      5810     ; No assumptions
                      5811     ;
                      5812     ; Decodes throttle rate
                      5813     ;
                      5814     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5815     DECODE_THROTTLE_RATE: 
                      5816     	; Decode throttle rate
1199    789B          5817     MOV R0 , # PGM_THROTTLE_RATE 
119B    E6            5818     MOV A , @ R0 
119C    14            5819     	DEC	A	
119D    90008D        5820     	MOV	DPTR, #THROTTLE_RATE_TABLE
11A0    93            5821     	MOVC A, @A+DPTR	
11A1    78A0          5822     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
11A3    F6            5823     MOV @ R0 , A 
11A4    1104          5824     	CALL	SWITCH_POWER_OFF			; Reset DPTR
11A6    22            5825     	RET
                      5826     
                      5827     
                      5828     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5829     ;
                      5830     ; Decode startup power
                      5831     ;
                      5832     ; No assumptions
                      5833     ;
                      5834     ; Decodes startup power
                      5835     ;
                      5836     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5837     DECODE_STARTUP_POWER: 
                      5838     	; Decode startup power
11A7    7886          5839     MOV R0 , # PGM_STARTUP_PWR 
11A9    E6            5840     MOV A , @ R0 
11AA    14            5841     	DEC	A	
11AB    90009A        5842     	MOV	DPTR, #STARTUP_POWER_TABLE
11AE    93            5843     	MOVC A, @A+DPTR	
11AF    78A1          5844     MOV R0 , # PGM_STARTUP_PWR_DECODED 
11B1    F6            5845     MOV @ R0 , A 
11B2    1104          5846     	CALL	SWITCH_POWER_OFF			; Reset DPTR
11B4    22            5847     	RET
                      5848     
                      5849     
                      5850     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5851     ;
                      5852     ; Decode demag compensation
                      5853     ;
                      5854     ; No assumptions
                      5855     ;
                      5856     ; Decodes throttle rate
                      5857     ;
                      5858     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5859     DECODE_DEMAG_COMP: 
                      5860     	; Decode demag compensation
11B5    789C          5861     MOV R0 , # PGM_DEMAG_COMP 
11B7    E6            5862     MOV A , @ R0 
11B8    14            5863     	DEC	A	
11B9    9000A7        5864     	MOV	DPTR, #DEMAG_WAIT_TABLE
11BC    93            5865     	MOVC A, @A+DPTR	
11BD    78A2          5866     MOV R0 , # PGM_DEMAG_COMP_WAIT_DECODED 
11BF    F6            5867     MOV @ R0 , A 
11C0    789C          5868     MOV R0 , # PGM_DEMAG_COMP 
11C2    E6            5869     MOV A , @ R0 
11C3    14            5870     	DEC	A	
11C4    9000AC        5871     	MOV	DPTR, #DEMAG_POWER_TABLE
11C7    93            5872     	MOVC A, @A+DPTR	
11C8    78A3          5873     MOV R0 , # PGM_DEMAG_COMP_POWER_DECODED 
11CA    F6            5874     MOV @ R0 , A 
11CB    1104          5875     	CALL	SWITCH_POWER_OFF			; Reset DPTR
11CD    22            5876     	RET
                      5877     
                      5878     
                      5879     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5880     ;
                      5881     ; Set BEC voltage
                      5882     ;
                      5883     ; No assumptions
                      5884     ;
                      5885     ; Sets the BEC output voltage low or high
                      5886     ;
                      5887     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5888     SET_BEC_VOLTAGE: 
                      5889     	; Set bec voltage
                      5890     IF DUAL_BEC_VOLTAGE == 1
                               	SET_BEC_LO			; Set default to low
                               	MOV	TEMP1, #PGM_BEC_VOLTAGE_HIGH		
                               	MOV	A, @TEMP1				
                               	JZ	SET_BEC_VOLTAGE_EXIT	
                               
                               	SET_BEC_HI			; Set to high
                               
                               SET_BEC_VOLTAGE_EXIT:
                               ENDIF
11CE    22            5900     	RET
                      5901     
                      5902     
                      5903     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5904     ;
                      5905     ; Find throttle gain
                      5906     ;
                      5907     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      5908     ;
                      5909     ; Finds throttle gain from throttle calibration values
                      5910     ;
                      5911     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5912     FIND_THROTTLE_GAIN: 
                      5913     	; Load programmed minimum and maximum throttle
11CF    7896          5914     MOV R0 , # PGM_PPM_MIN_THROTTLE 
11D1    E6            5915     MOV A , @ R0 
11D2    FA            5916     MOV R2 , A 
11D3    7897          5917     MOV R0 , # PGM_PPM_MAX_THROTTLE 
11D5    E6            5918     MOV A , @ R0 
11D6    FB            5919     MOV R3 , A 
                      5920     	; Check if full range is chosen
11D7    307704        5921     JNB FLAGS3 . 7 , FIND_THROTTLE_GAIN_CALCULATE 
                      5922     
11DA    7A00          5923     MOV R2 , # 0 
11DC    7BFF          5924     MOV R3 , # 255 
                      5925     
                      5926     FIND_THROTTLE_GAIN_CALCULATE: 
                      5927     	; Calculate difference
11DE    C3            5928     	CLR	C
11DF    EB            5929     MOV A , R3 
11E0    9A            5930     SUBB A , R2 
11E1    FC            5931     MOV R4 , A 
                      5932     	; Check that difference is minimum 130
11E2    C3            5933     	CLR	C
11E3    9482          5934     	SUBB	A, #130
11E5    5002          5935     	JNC	($+4)
                      5936     
11E7    7C82          5937     MOV R4 , # 130 
                      5938     
                      5939     	; Find gain
11E9    756C00        5940     	MOV	PPM_THROTTLE_GAIN, #0
                      5941     TEST_GAIN: 
11EC    056C          5942     	INC	PPM_THROTTLE_GAIN
11EE    EC            5943     MOV A , R4 
11EF    856CF0        5944     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
11F2    A4            5945     	MUL	AB
11F3    C3            5946     	CLR	C
11F4    E5F0          5947     	MOV	A, B
11F6    9480          5948     	SUBB	A, #128
11F8    40F2          5949     	JC	TEST_GAIN
11FA    22            5950     	RET
                      5951     
                      5952     
                      5953     
                      5954     
                      5955     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5956     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5957     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5958     ;
                      5959     ; Main program start
                      5960     ;
                      5961     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5962     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5963     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5964     
                      5965     RESET: 
                      5966     	; Select register bank 0 for main program routines
11FB    C2D3          5967     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      5968     	; Disable the WDT.
11FD    53D9BF        5969     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      5970     	; Initialize stack
1200    7581C0        5971     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      5972     	; Initialize VDD monitor
1203    43FF80        5973     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
1206    120757        5974     	CALL	WAIT1MS			; Wait at least 100us
                      5975     IF ONE_S_CAPABLE == 0		
1209    75EF02        5976     	MOV 	RSTSRC, #02H   	; Set VDD monitor as a reset source (PORSF) if not 1S capable                                
                      5977     ELSE
                               	MOV 	RSTSRC, #00H   	; Do not set VDD monitor as a reset source for 1S ESCSs, in order to avoid resets due to it                              
                               ENDIF
                      5980     	; Set clock frequency
120C    43B203        5981     	ORL	OSCICN, #03H		; Set clock divider to 1
120F    E5B3          5982     	MOV	A, OSCICL				
1211    2404          5983     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
1213    4002          5984     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      5985     
1215    F5B3          5986     	MOV	OSCICL, A
                      5987     
                      5988     RESET_CAL_DONE: 
                      5989     	; Ports initialization
1217    7580FF        5990     MOV P0 , # 255 
121A    75A400        5991     MOV P0MDOUT , # 0 
121D    75F1F0        5992     MOV P0MDIN , # -16 
1220    75D4DF        5993     MOV P0SKIP , # -33 
1223    759002        5994     MOV P1 , # 2 
1226    75A5FC        5995     MOV P1MDOUT , # 252 
1229    75F2FD        5996     MOV P1MDIN , # -3 
122C    75D502        5997     MOV P1SKIP , # 2 
                      5998     IF PORT3_EXIST == 1
                               	MOV	P2, #P2_INIT				
                               ENDIF
122F    75A610        6001     MOV P2MDOUT , # 16 
                      6002     IF PORT3_EXIST == 1
                               	MOV	P2MDIN, #P2_DIGITAL				
                               	MOV	P2SKIP, #P2_SKIP				
                               	MOV	P3, #P3_INIT				
                               	MOV	P3MDOUT, #P3_PUSHPULL				
                               	MOV	P3MDIN, #P3_DIGITAL				
                               ENDIF
                      6009     
                      6010     	; Initialize the XBAR and related functionality
                      6011     	INITIALIZE_XBAR		
1232    75A0FF        6011+1   MOV P2 , # 255  ; DO PORT 2 INITIALIZATION HERE			
1235    75F3F1        6011+1   MOV P2MDIN , # -15 
1238    75E241        6011+1   MOV XBR1 , # 41H  ; XBAR ENABLED, CEX0 ROUTED TO PIN RCP_IN			
                      6012     	; Switch power off
123B    1104          6013     	CALL	SWITCH_POWER_OFF
                      6014     	; Clear RAM
123D    E4            6015     	CLR	A				; Clear accumulator
123E    F8            6016     MOV R0 , A 
                      6017     CLEAR_RAM: 	
123F    F6            6018     MOV @ R0 , A 
1240    D8FD          6019     DJNZ R0 , CLEAR_RAM 
                      6020     	; Set default programmed parameters
1242    1180          6021     	CALL	SET_DEFAULT_PARAMETERS
                      6022     	; Read all programmed parameters
1244    121778        6023     	CALL READ_ALL_EEPROM_PARAMETERS
                      6024     	; Decode parameters
1247    11E9          6025     	CALL	DECODE_PARAMETERS
                      6026     	; Decode governor gains
1249    3180          6027     	CALL	DECODE_GOVERNOR_GAINS
                      6028     	; Decode throttle rate
124B    3199          6029     	CALL	DECODE_THROTTLE_RATE
                      6030     	; Decode startup power
124D    31A7          6031     	CALL	DECODE_STARTUP_POWER
                      6032     	; Decode demag compensation
124F    31B5          6033     	CALL	DECODE_DEMAG_COMP
                      6034     	; Set BEC voltage
1251    31CE          6035     	CALL	SET_BEC_VOLTAGE
                      6036     	; Find throttle gain from stored min and max settings
1253    31CF          6037     	CALL	FIND_THROTTLE_GAIN
                      6038     	; Set beep strength
1255    7898          6039     MOV R0 , # PGM_BEEP_STRENGTH 
1257    866D          6040     MOV BEEP_STRENGTH , @ R0 
                      6041     	; Switch power off
1259    1104          6042     	CALL	SWITCH_POWER_OFF
                      6043     	; Timer control
125B    758850        6044     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      6045     	; Timer mode
125E    758902        6046     	MOV	TMOD, #02H		; Timer0 as 8bit
                      6047     	; Timer2: clk/12 for 128us and 32ms interrupts
1261    75C824        6048     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      6049     	; Timer3: clk/12 for commutation timing
1264    759104        6050     	MOV	TMR3CN, #04H		; Timer3 enabled
                      6051     	; PCA
1267    75D840        6052     	MOV	PCA0CN, #40H		; PCA enabled
                      6053     	; Initializing beep
126A    12076B        6054     	CALL WAIT200MS	
126D    12077A        6055     	CALL BEEP_F1
1270    120763        6056     	CALL WAIT30MS
1273    120781        6057     	CALL BEEP_F2
1276    120763        6058     	CALL WAIT30MS
1279    120788        6059     	CALL BEEP_F3
127C    120763        6060     	CALL WAIT30MS
                      6061     
                      6062     	; Wait for receiver to initialize
127F    121CE5        6063     	CALL	WAIT1S
1282    12076B        6064     	CALL	WAIT200MS
1285    12076B        6065     	CALL	WAIT200MS
1288    120767        6066     	CALL	WAIT100MS
                      6067     
                      6068     	; Enable interrupts
128B    75A822        6069     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
128E    75B802        6070     	MOV	IP, #02H			; High priority to timer0 interrupts
1291    75E690        6071     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
1294    75F610        6072     	MOV	EIP1, #10H		; High priority to PCA interrupts
                      6073     	; Initialize comparator
1297    759B80        6074     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
129A    759D03        6075     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      6076     IF COMP1_USED==1			
                               	MOV	CPT1CN, #80H		; Comparator enabled, no hysteresis
                               	MOV	CPT1MD, #03H		; Comparator response time 1us
                               ENDIF
                      6080     	; Initialize ADC
                      6081     	INITIALIZE_ADC			; Initialize ADC operation
129D    75D10E        6081+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
12A0    75BC58        6081+1   MOV ADC0CF , # 58H  ; ADC CLOCK 2MHZ
12A3    75BB09        6081+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
12A6    75BA11        6081+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
12A9    75E880        6081+1   MOV ADC0CN , # 80H  ; ADC ENABLED
12AC    120757        6082     	CALL	WAIT1MS
12AF    D2AF          6083     	SETB	EA				; Enable all interrupts
                      6084     	; Measure number of lipo cells
12B1    120A33        6085     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      6086     	; Initialize rc pulse
                      6087     	RCP_INT_ENABLE		 			; Enable interrupt
12B4    43DA01        6087+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      6088     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
12B7    C2D8          6088+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
12B9    C269          6089     CLR FLAGS2 . 1 
12BB    12076B        6090     	CALL WAIT200MS
                      6091     	; Set initial arm variable
12BE    753001        6092     	MOV	INITIAL_ARM, #1
                      6093     
                      6094     	; Measure PWM frequency
                      6095     MEASURE_PWM_FREQ_INIT: 	
12C1    D259          6096     SETB FLAGS0 . 1 
                      6097     MEASURE_PWM_FREQ_START: 	
12C3    7A05          6098     MOV R2 , # 5 
                      6099     MEASURE_PWM_FREQ_LOOP: 	
                      6100     	; Check if period diff was accepted
12C5    E557          6101     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
12C7    7002          6102     	JNZ	($+4)
                      6103     
12C9    7A05          6104     MOV R2 , # 5 
                      6105     
12CB    12075B        6106     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
12CE    E558          6107     	MOV	A, NEW_RCP					; Load value
12D0    C3            6108     	CLR	C
12D1    9402          6109     SUBB A , # 2 
12D3    40EE          6110     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      6111     
12D5    E52E          6112     	MOV	A, FLAGS3						; Check pwm frequency flags
12D7    541F          6113     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
12D9    855A59        6114     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
12DC    F55A          6115     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
12DE    B559E2        6116     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      6117     
12E1    DAE2          6118     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      6119     
                      6120     	; Clear measure pwm frequency flag
12E3    C259          6121     CLR FLAGS0 . 1 
                      6122     	; Set up RC pulse interrupts after pwm frequency measurement
                      6123     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
12E5    53DACF        6123+1   ANL PCA0CPM0 , # 0CFH 
12E8    207603        6123+1   JB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
12EB    43DA20        6123+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
12EE    307603        6123+1   JNB FLAGS3 . 6 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
12F1    43DA10        6123+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      6124     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
12F4    C2D8          6124+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
12F6    C269          6125     CLR FLAGS2 . 1 
12F8    120767        6126     	CALL WAIT100MS						; Wait for new RC pulse
                      6127     
                      6128     	; Validate RC pulse
                      6129     VALIDATE_RCP_START: 	
12FB    12075B        6130     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
12FE    7802          6131     MOV R0 , # 2 
1300    741F          6132     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1302    552E          6133     	ANL	A, FLAGS3						; Check pwm frequency flags
1304    7002          6134     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      6135     
1306    7800          6136     MOV R0 , # 0 
                      6137     
1308    C3            6138     	CLR	C
1309    E558          6139     	MOV	A, NEW_RCP					; Load value
130B    98            6140     SUBB A , R0 
130C    40ED          6141     	JC	VALIDATE_RCP_START				; No - start over
                      6142     
                      6143     	; Beep arm sequence start signal
130E    C2AF          6144     	CLR 	EA							; Disable all interrupts
1310    12077A        6145     	CALL BEEP_F1						; Signal that RC pulse is ready
1313    12077A        6146     	CALL BEEP_F1
1316    12077A        6147     	CALL BEEP_F1
1319    D2AF          6148     	SETB	EA							; Enable all interrupts
131B    12076B        6149     	CALL WAIT200MS	
                      6150     
                      6151     	; Arming sequence start
131E    754700        6152     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      6153     ARMING_START: 
1321    12075B        6154     	CALL WAIT3MS
1324    788C          6155     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1326    E6            6156     MOV A , @ R0 
1327    C3            6157     	CLR	C
1328    9401          6158     	SUBB	A, #1				; Is TX programming enabled?
132A    5003          6159     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      6160     
132C    0213EA        6161     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      6162     
                      6163     ARMING_INITIAL_ARM_CHECK: 
132F    E530          6164     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
1331    C3            6165     	CLR	C
1332    9401          6166     	SUBB	A, #1				; Is it the initial arm sequence?
1334    5003          6167     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      6168     
1336    0213EA        6169     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      6170     
                      6171     ARMING_PPM_CHECK: 
1339    741F          6172     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
133B    552E          6173     	ANL	A, FLAGS3				; Check pwm frequency flags
133D    6035          6174     	JZ	THROTTLE_HIGH_CAL_START	; If no flag is set (PPM) - branch
                      6175     
                      6176     	; PWM tx program entry
133F    C3            6177     	CLR	C
1340    E558          6178     	MOV	A, NEW_RCP			; Load new RC pulse value
1342    94FF          6179     SUBB A , # 255 
1344    5003          6180     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      6181     
1346    0213EA        6182     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      6183     
                      6184     PROGRAM_BY_TX_ENTRY_PWM: 	
1349    C2AF          6185     	CLR	EA					; Disable all interrupts
134B    12078F        6186     	CALL BEEP_F4
134E    D2AF          6187     	SETB	EA					; Enable all interrupts
1350    120767        6188     	CALL WAIT100MS
1353    C3            6189     	CLR	C
1354    E558          6190     	MOV	A, NEW_RCP			; Load new RC pulse value
1356    9401          6191     SUBB A , # 1 
1358    50EF          6192     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      6193     
                      6194     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
135A    C2AF          6195     	CLR	EA					; Disable all interrupts
135C    12077A        6196     	CALL BEEP_F1
135F    12075F        6197     	CALL WAIT10MS
1362    12077A        6198     	CALL BEEP_F1
1365    D2AF          6199     	SETB	EA					; Enable all interrupts
1367    120767        6200     	CALL WAIT100MS
136A    C3            6201     	CLR	C
136B    E558          6202     	MOV	A, NEW_RCP			; Load new RC pulse value
136D    94FF          6203     SUBB A , # 255 
136F    40E9          6204     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      6205     
1371    021D6A        6206     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      6207     
                      6208     	; PPM throttle calibration and tx program entry
                      6209     THROTTLE_HIGH_CAL_START: 
1374    7F05          6210     MOV R7 , # 5 
                      6211     THROTTLE_HIGH_CAL: 			
1376    D277          6212     SETB FLAGS3 . 7 
1378    31CF          6213     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
137A    120767        6214     	CALL WAIT100MS				; Wait for new throttle value
137D    C2AF          6215     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
137F    C277          6216     CLR FLAGS3 . 7 
1381    31CF          6217     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1383    C3            6218     	CLR	C
1384    E558          6219     	MOV	A, NEW_RCP			; Load new RC pulse value
1386    947F          6220     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
1388    D2AF          6221     	SETB	EA					; Enable interrupts
138A    4068          6222     	JC	ARM_TARGET_UPDATED		; No - branch
                      6223     
138C    C2AF          6224     	CLR	EA					; Disable all interrupts
138E    12078F        6225     	CALL BEEP_F4
1391    D2AF          6226     	SETB	EA					; Enable all interrupts
1393    DFE1          6227     DJNZ R7 , THROTTLE_HIGH_CAL 
                      6228     
1395    C3            6229     	CLR	C
1396    E558          6230     	MOV	A, NEW_RCP			; Limit to max 250
1398    9405          6231     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
139A    7897          6232     MOV R0 , # PGM_PPM_MAX_THROTTLE 
139C    F6            6233     MOV @ R0 , A 
139D    12076B        6234     	CALL WAIT200MS				
13A0    121827        6235     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
13A3    121CED        6236     	CALL	SUCCESS_BEEP
                      6237     
                      6238     THROTTLE_LOW_CAL_START: 
13A6    7F0A          6239     MOV R7 , # 10 
                      6240     THROTTLE_LOW_CAL: 			
13A8    D277          6241     SETB FLAGS3 . 7 
13AA    31CF          6242     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13AC    120767        6243     	CALL WAIT100MS
13AF    C2AF          6244     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
13B1    C277          6245     CLR FLAGS3 . 7 
13B3    31CF          6246     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
13B5    C3            6247     	CLR	C
13B6    E558          6248     	MOV	A, NEW_RCP			; Load new RC pulse value
13B8    947F          6249     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
13BA    D2AF          6250     	SETB	EA					; Enable interrupts
13BC    50E8          6251     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      6252     
13BE    C2AF          6253     	CLR	EA					; Disable all interrupts
13C0    12077A        6254     	CALL BEEP_F1
13C3    12075F        6255     	CALL WAIT10MS
13C6    12077A        6256     	CALL BEEP_F1
13C9    D2AF          6257     	SETB	EA					; Enable all interrupts
13CB    DFDB          6258     DJNZ R7 , THROTTLE_LOW_CAL 
                      6259     
13CD    E558          6260     	MOV	A, NEW_RCP			
13CF    2405          6261     	ADD	A, #5				; Add about 2%
13D1    7896          6262     MOV R0 , # PGM_PPM_MIN_THROTTLE 
13D3    F6            6263     MOV @ R0 , A 
13D4    12076B        6264     	CALL WAIT200MS				
13D7    121827        6265     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
13DA    121D1C        6266     	CALL	SUCCESS_BEEP_INVERTED
                      6267     
                      6268     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
13DD    120767        6269     	CALL WAIT100MS
13E0    C3            6270     	CLR	C
13E1    E558          6271     	MOV	A, NEW_RCP			; Load new RC pulse value
13E3    94FF          6272     SUBB A , # 255 
13E5    40F6          6273     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      6274     
13E7    021D6A        6275     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      6276     
                      6277     PROGRAM_BY_TX_CHECKED: 
13EA    C3            6278     	CLR	C
13EB    E558          6279     	MOV	A, NEW_RCP			; Load new RC pulse value
13ED    9547          6280     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
13EF    4003          6281     	JC	ARM_TARGET_UPDATED		; No - do not update
                      6282     
13F1    855847        6283     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      6284     
                      6285     ARM_TARGET_UPDATED: 
13F4    120767        6286     	CALL WAIT100MS				; Wait for new throttle value
13F7    C3            6287     	CLR	C
13F8    E558          6288     	MOV	A, NEW_RCP			; Load new RC pulse value
13FA    9401          6289     SUBB A , # 1 
13FC    4002          6290     	JC	ARM_END_BEEP			; Yes - proceed
                      6291     
13FE    6121          6292     	JMP	ARMING_START			; No - start over
                      6293     
                      6294     ARM_END_BEEP: 
                      6295     	; Beep arm sequence end signal
1400    C2AF          6296     	CLR 	EA					; Disable all interrupts
1402    12078F        6297     	CALL BEEP_F4				; Signal that rcpulse is ready
1405    12078F        6298     	CALL BEEP_F4
1408    12078F        6299     	CALL BEEP_F4
140B    D2AF          6300     	SETB	EA					; Enable all interrupts
140D    12076B        6301     	CALL WAIT200MS
                      6302     
                      6303     	; Clear initial arm variable
1410    753000        6304     	MOV	INITIAL_ARM, #0
                      6305     
                      6306     	; Armed and waiting for power on
                      6307     WAIT_FOR_POWER_ON: 
1413    E4            6308     	CLR	A
1414    F531          6309     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
1416    F532          6310     	MOV	POWER_ON_WAIT_CNT_H, A	
                      6311     WAIT_FOR_POWER_ON_LOOP: 
1418    0531          6312     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
141A    E531          6313     	MOV	A, POWER_ON_WAIT_CNT_L
141C    F4            6314     	CPL	A
141D    7036          6315     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      6316     
141F    0532          6317     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
1421    789A          6318     MOV R0 , # PGM_BEACON_DELAY 
1423    E6            6319     MOV A , @ R0 
1424    7828          6320     MOV R0 , # 40 
1426    14            6321     	DEC	A
1427    6012          6322     	JZ	BEEP_DELAY_SET
                      6323     
1429    7850          6324     MOV R0 , # 80 
142B    14            6325     	DEC	A
142C    600D          6326     	JZ	BEEP_DELAY_SET
                      6327     
142E    78A0          6328     MOV R0 , # 160 
1430    14            6329     	DEC	A
1431    6008          6330     	JZ	BEEP_DELAY_SET
                      6331     
1433    78F0          6332     MOV R0 , # 240 
1435    14            6333     	DEC	A
1436    6003          6334     	JZ	BEEP_DELAY_SET
                      6335     
1438    753200        6336     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      6337     
                      6338     BEEP_DELAY_SET: 
143B    C3            6339     	CLR	C
143C    E532          6340     	MOV	A, POWER_ON_WAIT_CNT_H
143E    98            6341     SUBB A , R0 
143F    4014          6342     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      6343     
1441    1532          6344     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
1443    7899          6345     MOV R0 , # PGM_BEACON_STRENGTH 
1445    866D          6346     MOV BEEP_STRENGTH , @ R0 
1447    C2AF          6347     	CLR 	EA					; Disable all interrupts
1449    12078F        6348     	CALL BEEP_F4				; Signal that there is no signal
144C    D2AF          6349     	SETB	EA					; Enable all interrupts
144E    7898          6350     MOV R0 , # PGM_BEEP_STRENGTH 
1450    866D          6351     MOV BEEP_STRENGTH , @ R0 
1452    120767        6352     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      6353     
                      6354     WAIT_FOR_POWER_ON_NO_BEEP: 
1455    12075B        6355     	CALL WAIT3MS
1458    E528          6356     	MOV	A, RCP_TIMEOUT_CNT				; Load RC pulse timeout counter value
145A    7008          6357     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If it is not zero - proceed
                      6358     
145C    741F          6359     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
145E    552E          6360     	ANL	A, FLAGS3						; Check pwm frequency flags
1460    7002          6361     	JNZ	WAIT_FOR_POWER_ON_PPM_NOT_MISSING	; If a flag is set (PWM) - branch
                      6362     
1462    41C1          6363     	JMP	MEASURE_PWM_FREQ_INIT			; If ppm and pulses missing - go back to measure pwm frequency
                      6364     
                      6365     WAIT_FOR_POWER_ON_PPM_NOT_MISSING: 
1464    C3            6366     	CLR	C
1465    E558          6367     	MOV	A, NEW_RCP			; Load new RC pulse value
1467    9406          6368     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
1469    40AD          6369     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      6370     
146B    120767        6371     	CALL	WAIT100MS				; Wait to see if start pulse was only a glitch
146E    E528          6372     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
1470    7003          6373     	JNZ	($+5)				; If it is not zero - proceed
                      6374     
1472    0212C1        6375     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      6376     
                      6377     
                      6378     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6379     ;
                      6380     ; Start entry point
                      6381     ;
                      6382     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6383     INIT_START: 
1475    1104          6384     	CALL SWITCH_POWER_OFF
1477    E4            6385     	CLR	A
1478    F522          6386     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
147A    F523          6387     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
147C    F524          6388     	MOV	CURRENT_PWM, A			; Set current pwm to zero
147E    F525          6389     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
1480    755CFF        6390     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1483    7885          6391     MOV R0 , # PGM_MOTOR_IDLE 
1485    865F          6392     MOV PWM_MOTOR_IDLE , @ R0 
1487    F53F          6393     	MOV	GOV_TARGET_L, A		; Set target to zero
1489    F540          6394     	MOV	GOV_TARGET_H, A
148B    F541          6395     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
148D    F542          6396     	MOV	GOV_INTEGRAL_H, A
148F    F543          6397     	MOV	GOV_INTEGRAL_X, A
1491    F56A          6398     	MOV	ADC_CONVERSION_CNT, A
1493    F548          6399     	MOV	GOV_ACTIVE, A
1495    F52B          6400     	MOV	FLAGS0, A				; Clear flags0
1497    F52C          6401     	MOV	FLAGS1, A				; Clear flags1
1499    F55B          6402     	MOV	RCP_STOP_CNT, A		; Set RC pulse stop count to zero
149B    120BB4        6403     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      6404     	;**** **** **** **** ****
                      6405     	; Motor start beginning
                      6406     	;**** **** **** **** **** 
149E    756A08        6407     MOV ADC_CONVERSION_CNT , # 8 
                      6408     	SET_ADC_IP_TEMP
14A1    75BB10        6408+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
14A4    120757        6409     	CALL WAIT1MS
14A7    120AC8        6410     	CALL START_ADC_CONVERSION
                      6411     READ_INITIAL_TEMP: 
                      6412     	GET_ADC_STATUS 
14AA    E5E8          6412+1   MOV A , ADC0CN 
14AC    20ECFB        6413     	JB	AD0BUSY, READ_INITIAL_TEMP
                      6414     	READ_ADC_RESULT						; Read initial temperature
14AF    A8BD          6414+1   MOV R0 , ADC0L 
14B1    A9BE          6414+1   MOV R1 , ADC0H 
14B3    E9            6415     MOV A , R1 
14B4    7001          6416     	JNZ	($+3)							; Is reading below 256?
                      6417     
14B6    F8            6418     MOV R0 , A 
                      6419     
14B7    886B          6420     MOV CURRENT_AVERAGE_TEMP , R0 
14B9    120ACC        6421     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
14BC    756A08        6422     MOV ADC_CONVERSION_CNT , # 8 
                      6423     	SET_ADC_IP_TEMP
14BF    75BB10        6423+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      6424     
                      6425     	; Go to the desired startup mode
14C2    7895          6426     MOV R0 , # PGM_STARTUP_METHOD 
14C4    E6            6427     MOV A , @ R0 
14C5    30E003        6428     	JNB	ACC.0, DIRECT_METHOD_START
                      6429     
14C8    021507        6430     	JMP	STEPPER_METHOD_START
                      6431     
                      6432     DIRECT_METHOD_START: 
                      6433     	; Set up start operating conditions
14CB    7887          6434     MOV R0 , # PGM_PWM_FREQ 
14CD    E6            6435     MOV A , @ R0 
14CE    FE            6436     MOV R6 , A 
14CF    7602          6437     MOV @ R0 , # 2 
14D1    11E9          6438     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
14D3    7887          6439     MOV R0 , # PGM_PWM_FREQ 
14D5    EE            6440     MOV A , R6 
14D6    F6            6441     MOV @ R0 , A 
                      6442     	; Set max allowed power
14D7    D261          6443     SETB FLAGS1 . 1 
14D9    C2AF          6444     	CLR	EA					; Disable interrupts to avoid that Requested_Pwm is overwritten
14DB    120B84        6445     	CALL SET_STARTUP_PWM
14DE    85225C        6446     	MOV	PWM_LIMIT, REQUESTED_PWM
14E1    85225D        6447     	MOV	PWM_LIMIT_SPOOLUP, REQUESTED_PWM
14E4    D2AF          6448     	SETB	EA
14E6    C261          6449     CLR FLAGS1 . 1 
14E8    752500        6450     	MOV	CURRENT_PWM_LIMITED, #0		; Set low pwm again after calling set_startup_pwm
14EB    756200        6451     	MOV	SPOOLUP_LIMIT_CNT, #0
14EE    756301        6452     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      6453     	; Begin startup sequence
14F1    D260          6454     SETB FLAGS1 . 0 
14F3    D263          6455     SETB FLAGS1 . 3 
14F5    753800        6456     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
14F8    120F6F        6457     	CALL COMM5COMM6				; Initialize commutation
14FB    120FAA        6458     	CALL COMM6COMM1				
14FE    120C30        6459     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
1501    120BB4        6460     	CALL INITIALIZE_ALL_TIMINGS		; Initialize timing
1504    021630        6461     	JMP	RUN1
                      6462     
                      6463     
                      6464     STEPPER_METHOD_START: 
                      6465     	; Set up start operating conditions
1507    7887          6466     MOV R0 , # PGM_PWM_FREQ 
1509    E6            6467     MOV A , @ R0 
150A    FE            6468     MOV R6 , A 
150B    7603          6469     MOV @ R0 , # 3 
150D    7893          6470     MOV R0 , # PGM_DAMPING_FORCE 
150F    E6            6471     MOV A , @ R0 
1510    FD            6472     MOV R5 , A 
1511    7605          6473     MOV @ R0 , # 5 
1513    11E9          6474     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1515    7887          6475     MOV R0 , # PGM_PWM_FREQ 
1517    EE            6476     MOV A , R6 
1518    F6            6477     MOV @ R0 , A 
1519    7893          6478     MOV R0 , # PGM_DAMPING_FORCE 
151B    ED            6479     MOV A , R5 
151C    F6            6480     MOV @ R0 , A 
                      6481     	; Begin startup sequence
151D    D260          6482     SETB FLAGS1 . 0 
151F    D261          6483     SETB FLAGS1 . 1 
1521    D26E          6484     SETB FLAGS2 . 6 
1523    120F6F        6485     	CALL COMM5COMM6			; Initialize commutation
1526    120FAA        6486     	CALL COMM6COMM1			
1529    120B84        6487     	CALL SET_STARTUP_PWM
152C    120757        6488     	CALL WAIT1MS
152F    120E77        6489     	CALL COMM1COMM2
1532    120757        6490     	CALL WAIT1MS
1535    120757        6491     	CALL WAIT1MS
1538    120EA9        6492     	CALL COMM2COMM3
153B    12075B        6493     	CALL WAIT3MS			
153E    120EF3        6494     	CALL COMM3COMM4
1541    12075B        6495     	CALL WAIT3MS			
1544    12075B        6496     	CALL WAIT3MS			
1547    120F2E        6497     	CALL COMM4COMM5
154A    12075F        6498     	CALL WAIT10MS				; Settle rotor
154D    120F6F        6499     	CALL COMM5COMM6
1550    12075B        6500     	CALL WAIT3MS				
1553    120757        6501     	CALL WAIT1MS			
1556    C261          6502     CLR FLAGS1 . 1 
1558    D262          6503     SETB FLAGS1 . 2 
                      6504     
                      6505     	;**** **** **** **** ****
                      6506     	; Stepper phase beginning
                      6507     	;**** **** **** **** **** 
                      6508     STEPPER_ROT_BEG: 
155A    120AC8        6509     	CALL START_ADC_CONVERSION
155D    120ACC        6510     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
1560    120B84        6511     	CALL SET_STARTUP_PWM
1563    756A08        6512     MOV ADC_CONVERSION_CNT , # 8 
                      6513     	SET_ADC_IP_TEMP
1566    75BB10        6513+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      6514     
1569    120FAA        6515     	CALL COMM6COMM1				; Commutate
156C    120C29        6516     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
156F    120CA4        6517     	CALL CALC_NEW_WAIT_TIMES
1572    1114          6518     	CALL DECREMENT_STEPPER_STEP
1574    1179          6519     	CALL STEPPER_TIMER_WAIT
                      6520     
1576    120E77        6521     	CALL COMM1COMM2			
1579    120C29        6522     	CALL CALC_NEXT_COMM_TIMING_START	
157C    120CA4        6523     	CALL CALC_NEW_WAIT_TIMES
157F    1114          6524     	CALL DECREMENT_STEPPER_STEP
1581    1179          6525     	CALL STEPPER_TIMER_WAIT
                      6526     
1583    120EA9        6527     	CALL COMM2COMM3			
1586    120C29        6528     	CALL CALC_NEXT_COMM_TIMING_START	
1589    120CA4        6529     	CALL CALC_NEW_WAIT_TIMES
158C    1114          6530     	CALL DECREMENT_STEPPER_STEP
158E    1179          6531     	CALL STEPPER_TIMER_WAIT
                      6532     
1590    120EF3        6533     	CALL COMM3COMM4			
1593    120C29        6534     	CALL CALC_NEXT_COMM_TIMING_START	
1596    120CA4        6535     	CALL CALC_NEW_WAIT_TIMES
1599    1114          6536     	CALL DECREMENT_STEPPER_STEP
159B    1179          6537     	CALL STEPPER_TIMER_WAIT
                      6538     
159D    120F2E        6539     	CALL COMM4COMM5			
15A0    120C29        6540     	CALL CALC_NEXT_COMM_TIMING_START	
15A3    120CA4        6541     	CALL CALC_NEW_WAIT_TIMES
15A6    1114          6542     	CALL DECREMENT_STEPPER_STEP
15A8    1179          6543     	CALL STEPPER_TIMER_WAIT
                      6544     
15AA    120F6F        6545     	CALL COMM5COMM6			
15AD    120C29        6546     	CALL CALC_NEXT_COMM_TIMING_START	
15B0    120CA4        6547     	CALL CALC_NEW_WAIT_TIMES
15B3    1114          6548     	CALL DECREMENT_STEPPER_STEP	
                      6549     	; Check stepper step versus end criteria
15B5    C3            6550     	CLR	C
15B6    E54F          6551     	MOV	A, WT_STEPPER_STEP_L
15B8    9535          6552     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
15BA    E550          6553     	MOV	A, WT_STEPPER_STEP_H
15BC    9536          6554     	SUBB	A, STEPPER_STEP_END_H
15BE    400C          6555     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      6556     
                      6557     	; Wait for step
15C0    1179          6558     	CALL STEPPER_TIMER_WAIT
15C2    C3            6559     	CLR	C
15C3    E558          6560     	MOV	A, NEW_RCP				; Load new pulse value
15C5    9401          6561     SUBB A , # 1 
15C7    5091          6562     	JNC	STEPPER_ROT_BEG
                      6563     
15C9    02174A        6564     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6565     
                      6566     STEPPER_ROT_EXIT: 
                      6567     	; Wait for step
15CC    1179          6568     	CALL STEPPER_TIMER_WAIT
                      6569     	; Clear stepper phase
15CE    C262          6570     CLR FLAGS1 . 2 
                      6571     	; Set dondamped low pwm frequency
15D0    7887          6572     MOV R0 , # PGM_PWM_FREQ 
15D2    E6            6573     MOV A , @ R0 
15D3    FE            6574     MOV R6 , A 
15D4    7602          6575     MOV @ R0 , # 2 
15D6    11E9          6576     	CALL	DECODE_PARAMETERS			; (Decode_parameters uses Temp1 and Temp8)
15D8    7887          6577     MOV R0 , # PGM_PWM_FREQ 
15DA    EE            6578     MOV A , R6 
15DB    F6            6579     MOV @ R0 , A 
                      6580     	; Set spoolup power variables (power is now controlled from RCP)
15DC    85225C        6581     	MOV	PWM_LIMIT, REQUESTED_PWM
15DF    855E5D        6582     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG
15E2    855E25        6583     	MOV	CURRENT_PWM_LIMITED, PWM_SPOOLUP_BEG
15E5    756200        6584     	MOV	SPOOLUP_LIMIT_CNT, #0
15E8    756301        6585     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      6586     	; Set direct startup phase to aquire sync quickly
15EB    D263          6587     SETB FLAGS1 . 3 
15ED    753800        6588     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
15F0    C2AF          6589     	CLR	EA						; Disable interrupts
                      6590     	APFET_OFF						; Ap off. Turn off unused pfets (to turn off damping fets that might be on)
15F2    207502        6590+1   JB FLAGS3 . 5 , ( $+5 ) 
15F5    C293          6590+1   CLR P1 . 3 
15F7    307502        6590+1   JNB FLAGS3 . 5 , ( $+5 ) 
15FA    C297          6590+1   CLR P1 . 7 
                      6591     	CPFET_OFF						; Cp off
15FC    207502        6591+1   JB FLAGS3 . 5 , ( $+5 ) 
15FF    C297          6591+1   CLR P1 . 7 
1601    307502        6591+1   JNB FLAGS3 . 5 , ( $+5 ) 
1604    C293          6591+1   CLR P1 . 3 
1606    742D          6592     	MOV	A, #45					; 8us delay for pfets to go off
1608    D5E0FD        6593     	DJNZ	ACC, $
160B    D2AF          6594     	SETB	EA						; Enable interrupts
160D    120FAA        6595     	CALL COMM6COMM1				
1610    120C30        6596     	CALL CALC_NEXT_COMM_TIMING		; Calculate next timing and start advance timing wait
1613    120C8B        6597     	CALL WAIT_ADVANCE_TIMING			; Wait advance timing and start zero cross wait
1616    120CA4        6598     	CALL CALC_NEW_WAIT_TIMES
1619    120D28        6599     	CALL WAIT_BEFORE_ZC_SCAN			; Wait zero cross wait and start zero cross timeout
161C    756A00        6600     	MOV	ADC_CONVERSION_CNT, #0		; Make sure a voltage reading is done next time
                      6601     	SET_ADC_IP_VOLT				; Set adc measurement to voltage
161F    75BB09        6601+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
1622    021630        6602     	JMP	RUN1
                      6603     
                      6604     
                      6605     
                      6606     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6607     ;
                      6608     ; Run entry point
                      6609     ;
                      6610     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6611     DAMPED_TRANSITION: 
                      6612     	; Transition from nondamped to damped if applicable
1625    11E9          6613     	CALL	DECODE_PARAMETERS		; Set programmed parameters
1627    120FAA        6614     	CALL	COMM6COMM1
162A    756A00        6615     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      6616     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
162D    75BB09        6616+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      6617     
                      6618     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      6619     ; Out_cA changes from high to low
                      6620     RUN1: 
1630    120D4A        6621     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
1633    120DD4        6622     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
1636    120DFC        6623     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
1639    120879        6624     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
163C    120E10        6625     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
163F    120E77        6626     	CALL COMM1COMM2			; Commutate
1642    120C30        6627     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
1645    120C8B        6628     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
1648    120CA4        6629     	CALL CALC_NEW_WAIT_TIMES
164B    120D28        6630     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      6631     
                      6632     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      6633     ; Out_cB changes from low to high
                      6634     RUN2: 
164E    120D41        6635     	CALL WAIT_FOR_COMP_OUT_LOW
1651    120DD4        6636     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1654    120DFC        6637     	CALL SETUP_COMM_WAIT	
1657    1208D7        6638     	CALL CALC_GOVERNOR_PROP_ERROR
165A    120E10        6639     	CALL WAIT_FOR_COMM
165D    120EA9        6640     	CALL COMM2COMM3
1660    120C30        6641     	CALL CALC_NEXT_COMM_TIMING
1663    120C8B        6642     	CALL WAIT_ADVANCE_TIMING
1666    120CA4        6643     	CALL CALC_NEW_WAIT_TIMES
1669    120D28        6644     	CALL WAIT_BEFORE_ZC_SCAN	
                      6645     
                      6646     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      6647     ; Out_cC changes from high to low
                      6648     RUN3: 
166C    120D4A        6649     	CALL WAIT_FOR_COMP_OUT_HIGH
166F    120DD4        6650     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1672    120DFC        6651     	CALL SETUP_COMM_WAIT	
1675    120910        6652     	CALL CALC_GOVERNOR_INT_ERROR
1678    120E10        6653     	CALL WAIT_FOR_COMM
167B    120EF3        6654     	CALL COMM3COMM4
167E    120C30        6655     	CALL CALC_NEXT_COMM_TIMING
1681    120C8B        6656     	CALL WAIT_ADVANCE_TIMING
1684    120CA4        6657     	CALL CALC_NEW_WAIT_TIMES
1687    120D28        6658     	CALL WAIT_BEFORE_ZC_SCAN	
                      6659     
                      6660     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      6661     ; Out_cA changes from low to high
                      6662     RUN4: 
168A    120D41        6663     	CALL WAIT_FOR_COMP_OUT_LOW
168D    120DD4        6664     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1690    120DFC        6665     	CALL SETUP_COMM_WAIT	
1693    12096D        6666     	CALL CALC_GOVERNOR_PROP_CORRECTION
1696    120E10        6667     	CALL WAIT_FOR_COMM
1699    120F2E        6668     	CALL COMM4COMM5
169C    120C30        6669     	CALL CALC_NEXT_COMM_TIMING
169F    120C8B        6670     	CALL WAIT_ADVANCE_TIMING
16A2    120CA4        6671     	CALL CALC_NEW_WAIT_TIMES
16A5    120D28        6672     	CALL WAIT_BEFORE_ZC_SCAN	
                      6673     
                      6674     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      6675     ; Out_cB changes from high to low
                      6676     RUN5: 
16A8    120D4A        6677     	CALL WAIT_FOR_COMP_OUT_HIGH
16AB    120DD4        6678     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16AE    120DFC        6679     	CALL SETUP_COMM_WAIT	
16B1    1209D1        6680     	CALL CALC_GOVERNOR_INT_CORRECTION
16B4    120E10        6681     	CALL WAIT_FOR_COMM
16B7    120F6F        6682     	CALL COMM5COMM6
16BA    120C30        6683     	CALL CALC_NEXT_COMM_TIMING
16BD    120C8B        6684     	CALL WAIT_ADVANCE_TIMING
16C0    120CA4        6685     	CALL CALC_NEW_WAIT_TIMES
16C3    120D28        6686     	CALL WAIT_BEFORE_ZC_SCAN	
                      6687     
                      6688     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      6689     ; Out_cC changes from low to high
                      6690     RUN6: 
16C6    120D41        6691     	CALL WAIT_FOR_COMP_OUT_LOW
16C9    120AC8        6692     	CALL START_ADC_CONVERSION
16CC    120DD4        6693     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16CF    120DFC        6694     	CALL SETUP_COMM_WAIT	
16D2    120ACC        6695     	CALL CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER
16D5    120E10        6696     	CALL WAIT_FOR_COMM
16D8    120FAA        6697     	CALL COMM6COMM1
16DB    120C30        6698     	CALL CALC_NEXT_COMM_TIMING
16DE    120C8B        6699     	CALL WAIT_ADVANCE_TIMING
16E1    120CA4        6700     	CALL CALC_NEW_WAIT_TIMES
16E4    120D28        6701     	CALL WAIT_BEFORE_ZC_SCAN	
                      6702     
                      6703     	; Check if it is direct startup
16E7    30632A        6704     JNB FLAGS1 . 3 , NORMAL_RUN_CHECKS 
                      6705     
                      6706     	; Set spoolup power variables
                      6707     IF MODE == 0 OR MODE == 2
16EA    855E5C        6708     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG		; Set initial max power
16ED    855E5D        6709     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
                      6710     ENDIF
                      6711     IF MODE == 1
                               	MOV	PWM_LIMIT, #0FFH			; Allow full power
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH	
                               ENDIF
16F0    756200        6715     	MOV	SPOOLUP_LIMIT_CNT, #0
16F3    756301        6716     	MOV	SPOOLUP_LIMIT_SKIP, #1			
                      6717     	; Check startup ok counter
16F6    C3            6718     	CLR	C
16F7    E538          6719     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
16F9    9464          6720     	SUBB	A, #100					; Is counter above requirement?
16FB    400A          6721     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      6722     
16FD    C263          6723     CLR FLAGS1 . 3 
16FF    D264          6724     SETB FLAGS1 . 4 
1701    753714        6725     	MOV	STARTUP_ROT_CNT, #20		; Set startup rotation count
1704    021714        6726     	JMP	NORMAL_RUN_CHECKS
                      6727     
                      6728     DIRECT_START_CHECK_RCP: 
1707    C3            6729     	CLR	C
1708    E558          6730     	MOV	A, NEW_RCP				; Load new pulse value
170A    9401          6731     SUBB A , # 1 
170C    4003          6732     	JC	($+5)
                      6733     
170E    021630        6734     	LJMP	RUN1						; Continue to run 
                      6735     
1711    02174A        6736     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6737     
                      6738     
                      6739     NORMAL_RUN_CHECKS: 
                      6740     	; Check if it is initial run phase
1714    306419        6741     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      6742     
                      6743     	; Decrement startup rotaton count
1717    E537          6744     	MOV	A, STARTUP_ROT_CNT
1719    14            6745     	DEC	A
                      6746     	; Check number of nondamped rotations
171A    7005          6747     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      6748     
171C    C264          6749     CLR FLAGS1 . 4 
171E    021625        6750     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      6751     
                      6752     NORMAL_RUN_CHECK_STARTUP_ROT: 
1721    F537          6753     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      6754     
1723    C3            6755     	CLR	C
1724    E558          6756     	MOV	A, NEW_RCP				; Load new pulse value
1726    9401          6757     SUBB A , # 1 
1728    4003          6758     	JC	($+5)
                      6759     
172A    021630        6760     	LJMP	RUN1						; Continue to run 
                      6761     
172D    02174A        6762     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      6763     
                      6764     
                      6765     INITIAL_RUN_PHASE_DONE: 
                      6766     IF MODE == 0	; Main
                               	; Check if throttle is zeroed
                               	CLR	C
                               	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
                               	SUBB	A, #1					; Is number of stop RC pulses above limit?
                               	JC	RUN6_CHECK_RCP_STOP_COUNT	; If no - branch
                               
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; If yes - set initial max powers
                               	MOV	SPOOLUP_LIMIT_CNT, #255			; And set spoolup parameters
                               	MOV	SPOOLUP_LIMIT_SKIP, #1			
                               
                               RUN6_CHECK_RCP_STOP_COUNT:
                               ENDIF
                      6779     	; Exit run loop after a given time
1730    C3            6780     	CLR	C
1731    E55B          6781     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
1733    94FA          6782     SUBB A , # 250 
1735    5013          6783     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      6784     
                      6785     RUN6_CHECK_RCP_TIMEOUT: 
1737    741F          6786     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1739    552E          6787     	ANL	A, FLAGS3					; Check pwm frequency flags
173B    7004          6788     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      6789     
173D    E528          6790     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
173F    6009          6791     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      6792     
                      6793     RUN6_CHECK_SPEED: 
1741    C3            6794     	CLR	C
1742    E53C          6795     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1744    94F0          6796     	SUBB	A, #0F0H
1746    5002          6797     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
1748    C130          6798     	JMP	RUN1						; Go back to run 1
                      6799     
                      6800     
                      6801     RUN_TO_WAIT_FOR_POWER_ON: 	
174A    1104          6802     	CALL SWITCH_POWER_OFF
174C    7887          6803     MOV R0 , # PGM_PWM_FREQ 
174E    E6            6804     MOV A , @ R0 
174F    FE            6805     MOV R6 , A 
1750    7602          6806     MOV @ R0 , # 2 
1752    11E9          6807     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1754    7887          6808     MOV R0 , # PGM_PWM_FREQ 
1756    EE            6809     MOV A , R6 
1757    F6            6810     MOV @ R0 , A 
1758    E4            6811     	CLR	A
1759    F522          6812     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
175B    F523          6813     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
175D    F524          6814     	MOV	CURRENT_PWM, A			; Set current pwm to zero
175F    F525          6815     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
1761    F55F          6816     	MOV	PWM_MOTOR_IDLE, A		; Set motor idle to zero
1763    C260          6817     CLR FLAGS1 . 0 
1765    120757        6818     	CALL	WAIT1MS				; Wait for pwm to be stopped
1768    1104          6819     	CALL SWITCH_POWER_OFF
                      6820     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
                               	ANL	A, FLAGS3				; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN	; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN	; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	MOV	TEMP1, #PGM_STARTUP_METHOD	; Check if it is stepped startup
                               	MOV	A, @TEMP1
                               	JNB	ACC.0, RUN_TO_NEXT_STATE_MAIN_WAIT_DONE	; If direct startup - jump
                               
                               	CALL	WAIT1S					; 3 second delay before new startup (in stepped mode)
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               RUN_TO_NEXT_STATE_MAIN_WAIT_DONE:
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1				; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON	; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START		; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON		; Go back to wait for power on
                               ENDIF
                      6850     IF MODE >= 1	; Tail or multi
176A    741F          6851     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
176C    552E          6852     	ANL	A, FLAGS3				; Check pwm frequency flags
176E    7006          6853     	JNZ	JMP_WAIT_FOR_POWER_ON	; If a flag is set (PWM) - branch
                      6854     
1770    E528          6855     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
1772    7002          6856     	JNZ	JMP_WAIT_FOR_POWER_ON	; If it is not zero - go back to wait for poweron
                      6857     
1774    41C1          6858     	JMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      6859     
                      6860     JMP_WAIT_FOR_POWER_ON: 
1776    8113          6861     	JMP	WAIT_FOR_POWER_ON		; Go back to wait for power on
                      6862     ENDIF
                      6863     
                      6864     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      6865     
                      6866     $INCLUDE (BLHELITXPGM.INC)		; Include source code for programming the ESC with the TX
                      7930     
                      7931     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7932     
                      7933     
                      7934     
                      7935     
                      7936     END
MACRO ASSEMBLER BLHELI                                      06/18/13 19:58:16 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

NORMAL_RUN_CHECK_~  C ADDR   1721H   A 
COMP_WAIT_ON_COMP~  C ADDR   0D95H   A 
CALC_NEXT_COMM_SL~  C ADDR   0C84H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0ACCH   A 
GOVERNOR_LIMIT_IN~  C ADDR   09FEH   A 
GOVERNOR_CORR_NEG~  C ADDR   09C0H   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
PPM_THROTTLE_GAIN.  D ADDR   006CH   A 
LIPO_ADC_LIMIT_H .  D ADDR   0069H   A 
CURR_RCP_PWM_FREQ.  D ADDR   005AH   A 
RCP_EDGE_H . . . .  D ADDR   0054H   A 
FLAGS3 . . . . . .  D ADDR   002EH   A 
RCP_PREV_EDGE_L. .  D ADDR   0026H   A 
ADC_IP . . . . . .  N NUMB   0001h            
DUAL_BEC_VOLTAGE .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ACK1 . . . . . . .  B ADDR   00C0H.1 A 
SBUF0. . . . . . .  D ADDR   0099H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
POLARIS_THUNDER_4~  N NUMB   007Dh            
POLARIS_THUNDER_3~  N NUMB   007Bh            
POLARIS_THUNDER_1~  N NUMB   0075h            
FUNCTION_BEEP. . .  C ADDR   1D51H   A 
INIT_START . . . .  C ADDR   1475H   A 
PROGRAM_BY_TX_ENT~  C ADDR   1349H   A 
FIND_THROTTLE_GAI~  C ADDR   11DEH   A 
COMM45_NFET. . . .  C ADDR   0F53H   A 
COMM45_NONDAMP . .  C ADDR   0F50H   A 
COMM4COMM5 . . . .  C ADDR   0F2EH   A 
CHECK_VOLTAGE_SPO~  C ADDR   0B66H   A 
BEEP_RECHARGE_DONE  C ADDR   07E3H   A 
T2H_INT_RCP_STOP .  C ADDR   0515H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00CFH   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PGM_VOLT_COMP_DUM~  I ADDR   0091H   A 
PWM_MOTOR_IDLE . .  D ADDR   005FH   A 
PREV_RCP_PWM_FREQ.  D ADDR   0059H   A 
WT_COMM_L. . . . .  D ADDR   004DH   A 
COMM_PERIOD4X_H. .  D ADDR   003CH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_BEC_V~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
TXMODE0. . . . . .  B ADDR   00C0H.6 A 
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
SFRSTACK . . . . .  D ADDR   00D3H   A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
IPH. . . . . . . .  D ADDR   0084H   A 
CRC0DAT. . . . . .  D ADDR   009EH   A 
CRC0AUTO . . . . .  D ADDR   00DDH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
PLATINUM_PRO_30A_~  N NUMB   0088h            
POLARIS_THUNDER_4~  N NUMB   007Eh            
H_KING_35A_TAIL. .  N NUMB   006Eh            
PARAVAL_BEEP . . .  C ADDR   1D5FH   A 
STORE_MULTI_FUNC_~  C ADDR   1CADH   A 
DECODE_STARTUP_PO~  C ADDR   11A7H   A 
GOVERNOR_CHECK_PWM  C ADDR   094DH   A 
GOVERNOR_ACTIVATE.  C ADDR   089EH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0189H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
PGM_DEMAG_COMP_PO~  I ADDR   00A3H   A 
DAMPING_PERIOD . .  D ADDR   0064H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
TXMODE1. . . . . .  B ADDR   00C0H.6 A 
ACKRQ0 . . . . . .  B ADDR   00C0H.3 A 
P2 . . . . . . . .  D ADDR   00A0H   A 
P0MAT. . . . . . .  D ADDR   00FDH   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
B. . . . . . . . .  D ADDR   00F0H   A 
POLARIS_THUNDER_6~  N NUMB   0080h            
H_KING_35A_MULTI .  N NUMB   006Fh            
TURNIGY_AE_25A_MA~  N NUMB   0037h            
TURNIGY_AE_20A_TA~  N NUMB   0035h            
TURNIGY_PLUSH_10A~  N NUMB   001Ch            
STORE_MULTI_FUNC_~  C ADDR   1CB5H   A 
WRITE_EEPROM_SIGN~  C ADDR   1C30H   A 
WAIT_FOR_POWER_ON.  C ADDR   1413H   A 
THROTTLE_LOW_CAL_~  C ADDR   13A6H   A 
ERASE_AND_STORE_A~  C ADDR   1827H   A 
PROGRAM_BY_TX_CHE~  C ADDR   13EAH   A 
ARMING_INITIAL_AR~  C ADDR   132FH   A 
SET_DEFAULT_PARAM~  C ADDR   1080H   A 
COMM56_NONDAMP . .  C ADDR   0F96H   A 
COMM23_CP. . . . .  C ADDR   0EE1H   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0E29H   A 
CALC_NEXT_COMM_TI~  C ADDR   0C30H   A 
COMM5COMM6 . . . .  C ADDR   0F6FH   A 
CALC_GOVERNOR_INT~  C ADDR   09D8H   A 
CALC_GOVERNOR_TAR~  C ADDR   08D6H   A 
PCA_INT_STORE_DATA  C ADDR   064EH   A 
T2_INT_RCP_GAIN_P~  C ADDR   049AH   A 
T2_INT_RCP_UPDATE~  C ADDR   045BH   A 
RESET. . . . . . .  C ADDR   11FBH   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   009EH   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005DH   A 
RCP_PREPREV_EDGE_H  D ADDR   0052H   A 
WT_ADVANCE_H . . .  D ADDR   004AH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0002h            
ACKRQ1 . . . . . .  B ADDR   00C0H.3 A 
SP . . . . . . . .  D ADDR   0081H   A 
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
P1MAT. . . . . . .  D ADDR   00EDH   A 
POLARIS_THUNDER_6~  N NUMB   0081h            
SKYWALKER_20A_MAIN  N NUMB   0046h            
TURNIGY_AE_30A_TA~  N NUMB   003Bh            
TURNIGY_AE_20A_MU~  N NUMB   0036h            
XP_7A_MAIN . . . .  N NUMB   0004h            
FUNCTION_NEXT. . .  C ADDR   1DC8H   A 
STORE_MULTI_FUNC_~  C ADDR   1CBDH   A 
STEPPER_ROT_BEG. .  C ADDR   155AH   A 
THROTTLE_HIGH_CAL.  C ADDR   1376H   A 
DECODE_THROTTLE_R~  C ADDR   1199H   A 
WAIT_DEMAG_DEFAUL~  C ADDR   0E49H   A 
STEPPER_STEP_MED_~  C ADDR   0C00H   A 
INITIALIZE_ALL_TI~  C ADDR   0BB4H   A 
STARTUP_PWM_SET_P~  C ADDR   0BA8H   A 
PGM_THROTTLE_RATE.  I ADDR   009BH   A 
PGM_STARTUP_RPM. .  I ADDR   008FH   A 
PGM_PWM_FREQ . . .  I ADDR   0087H   A 
LIPO_ADC_LIMIT_L .  D ADDR   0068H   A 
RCP_EDGE_L . . . .  D ADDR   0053H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
MAIN_SPOOLUP_TIME.  N NUMB   000Ah            
PORT3_EXIST. . . .  N NUMB   0000h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
SMB1CN . . . . . .  D ADDR   00C0H   A 
SMB0ADM. . . . . .  D ADDR   00E7H   A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
POLARIS_THUNDER_8~  N NUMB   0083h            
TURNIGY_KFORCE_12~  N NUMB   0044h            
TURNIGY_AE_45A_MA~  N NUMB   003Dh            
TURNIGY_AE_30A_MU~  N NUMB   003Ch            
TURNIGY_PLUSH_30A~  N NUMB   0028h            
TURNIGY_PLUSH_12A~  N NUMB   001Fh            
XP_3A_TAIL . . . .  N NUMB   0002h            
PARAVAL_NEXT . . .  C ADDR   1DB3H   A 
STORE_MULTI_FUNC_~  C ADDR   1CC5H   A 
WRITE_EEPROM_BYTE.  C ADDR   1C04H   A 
MEASURE_PWM_FREQ_~  C ADDR   12C1H   A 
COMM61_CP. . . . .  C ADDR   0FF2H   A 
WAIT_FOR_COMM_POW~  C ADDR   0E54H   A 
SETUP_ZC_SCAN_WAIT  C ADDR   0C90H   A 
CALC_GOVERNOR_INT~  C ADDR   09D1H   A 
PCA_INT_LIMITED. .  C ADDR   0715H   A 
PCA_INT_PPM_CHECK~  C ADDR   06ACH   A 
PCA_INT_PWM_DIVIDE  C ADDR   06F2H   A 
T2_INT_PWM_UPDATE.  C ADDR   04AAH   A 
T0_INT_PWM_OFF_DA~  C ADDR   010DH   A 
EEP_DUMMY. . . . .  C ADDR   1A21H   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_GOV_SETUP_TAR~  I ADDR   008EH   A 
COMM_PERIOD4X_L. .  D ADDR   003BH   A 
PGM_RCP_PWM_POL. .  N NUMB   0006h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
SMB1ADM. . . . . .  D ADDR   00E7H   A 
PCA0CLR. . . . . .  D ADDR   00CEH   A 
EIE2 . . . . . . .  D ADDR   00AFH   A 
MODE . . . . . . .  N NUMB   0002h            
POLARIS_THUNDER_8~  N NUMB   0084h            
SKYWALKER_40A_MAIN  N NUMB   0049h            
TURNIGY_KFORCE_12~  N NUMB   0045h            
TURNIGY_PLUSH_40A~  N NUMB   002Bh            
SUPERMICRO_3P5A_M~  N NUMB   0016h            
XP_3A_MULTI. . . .  N NUMB   0003h            
FUNC_PARAVAL_WAIT.  C ADDR   1D7DH   A 
STORE_MULTI_FUNC_~  C ADDR   1CCDH   A 
WRITE_TAG. . . . .  C ADDR   1C59H   A 
READ_EEPROM_STORE~  C ADDR   1791H   A 
RUN1 . . . . . . .  C ADDR   1630H   A 
CLEAR_RAM. . . . .  C ADDR   123FH   A 
SET_BEC_VOLTAGE. .  C ADDR   11CEH   A 
DECODE_GOVERNOR_G~  C ADDR   1180H   A 
DEC_STEP_HIGH. . .  C ADDR   1042H   A 
WAIT_FOR_COMM. . .  C ADDR   0E10H   A 
CALC_NEW_WAIT_DIR~  C ADDR   0CB6H   A 
MEASURE_LIPO_ADD_~  C ADDR   0ABBH   A 
CALC_GOVERNOR_PRO~  C ADDR   090FH   A 
DIV_U16_BY_U16_DI~  C ADDR   07F2H   A 
WAIT100MS. . . . .  C ADDR   0767H   A 
WAIT1MS. . . . . .  C ADDR   0757H   A 
STARTUP_POWER_TAB~  C ADDR   009AH   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
TX_PGM_BEEP_NO . .  D ADDR   0070H   A 
SPOOLUP_LIMIT_SKIP  D ADDR   0063H   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MODF . . . . . . .  B ADDR   00F8H.5 A 
STO0 . . . . . . .  B ADDR   00C0H.4 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
PSCTL. . . . . . .  D ADDR   008FH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
PLATINUM_PRO_30A_~  N NUMB   0089h            
FUNCTION_PARAVAL_~  C ADDR   1D4BH   A 
STORE_MULTI_FUNC_~  C ADDR   1CD5H   A 
STORE_NEW_VALUE_I~  C ADDR   1C61H   A 
RUN2 . . . . . . .  C ADDR   164EH   A 
ARMING_PPM_CHECK .  C ADDR   1339H   A 
COMM45_CP. . . . .  C ADDR   0F66H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0D28H   A 
MEASURE_LIPO_UPDA~  C ADDR   0AC3H   A 
GOVERNOR_CORR_INT~  C ADDR   0A1DH   A 
GOVERNOR_STORE_PR~  C ADDR   090BH   A 
DIV_U16_BY_U16_DI~  C ADDR   07FCH   A 
WAIT200MS. . . . .  C ADDR   076BH   A 
T2_INT_CURRENT_PW~  C ADDR   04BFH   A 
T2_INT_RCP_GAIN_C~  C ADDR   0491H   A 
T2_INT_PULSES_ABS~  C ADDR   0403H   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0083H   A 
RCP_PREPREV_EDGE_L  D ADDR   0051H   A 
WT_ADVANCE_L . . .  D ADDR   0049H   A 
GOV_ACTIVE . . . .  D ADDR   0048H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
DEFAULT_PGM_MULTI~  N NUMB   0004h            
STO1 . . . . . . .  B ADDR   00C0H.4 A 
ARBLOST0 . . . . .  B ADDR   00C0H.2 A 
IT01CF . . . . . .  D ADDR   00E4H   A 
IDA1H. . . . . . .  D ADDR   0097H   A 
DERIVID. . . . . .  D ADDR   00ABH   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
PLATINUM_PRO_30A_~  N NUMB   008Ah            
TURNIGY_AE_25A_TA~  N NUMB   0038h            
TURNIGY_PLUSH_60A~  N NUMB   002Eh            
TURNIGY_PLUSH_10A~  N NUMB   001Dh            
STORE_MULTI_FUNC_~  C ADDR   1CDDH   A 
RUN3 . . . . . . .  C ADDR   166CH   A 
DIRECT_METHOD_STA~  C ADDR   14CBH   A 
DECODE_DAMPING_DO~  C ADDR   112EH   A 
PWM_WAIT . . . . .  C ADDR   0DBAH   A 
CHECK_VOLTAGE_EXIT  C ADDR   0B7AH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0A05H   A 
GOVERNOR_CHECK_IN~  C ADDR   0935H   A 
DIV_U16_BY_U16_DI~  C ADDR   0813H   A 
WAIT3MS. . . . . .  C ADDR   075BH   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_PGM_DEMAG_COMP  C ADDR   1A1FH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0096H   A 
INITIALIZED_H_DUM~  I ADDR   008BH   A 
GOV_INTEGRAL_H . .  D ADDR   0042H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
ARBLOST1 . . . . .  B ADDR   00C0H.2 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
TS0CN. . . . . . .  D ADDR   00D2H   A 
SFRPAGE. . . . . .  D ADDR   00A7H   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
POLARIS_THUNDER_1~  N NUMB   0085h            
SKYWALKER_20A_TAIL  N NUMB   0047h            
TURNIGY_AE_25A_MU~  N NUMB   0039h            
TURNIGY_PLUSH_25A~  N NUMB   0025h            
TURNIGY_PLUSH_10A~  N NUMB   001Eh            
XP_7A_TAIL . . . .  N NUMB   0005h            
BEEP_NO_ENTRY. . .  C ADDR   1D76H   A 
JMP_WAIT_FOR_POWE~  C ADDR   1776H   A 
DIRECT_START_CHEC~  C ADDR   1707H   A 
RUN4 . . . . . . .  C ADDR   168AH   A 
STORE_TIMES_UP_OR~  C ADDR   0D08H   A 
STORE_TIMES_DECRE~  C ADDR   0D1BH   A 
STEPPER_STEP_SET .  C ADDR   0C1CH   A 
TEMP_AVERAGE_INC .  C ADDR   0AFFH   A 
GOVERNOR_CORR_INT~  C ADDR   0A2EH   A 
MULT_S16_BY_U8_DI~  C ADDR   0822H   A 
PCA_INT_PPM_NEG_C~  C ADDR   06CAH   A 
T0_INT_PWM_OFF_CO~  C ADDR   016AH   A 
EEP_PGM_DIRECTION~  C ADDR   1A0BH   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_PWM_HIGH_OFF~  N NUMB   003Ch            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
SMB0ADR. . . . . .  D ADDR   00D7H   A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
SKYWALKER_20A_MUL~  N NUMB   0048h            
TURNIGY_AE_45A_TA~  N NUMB   003Eh            
TURNIGY_PLUSH_80A~  N NUMB   0031h            
TURNIGY_PLUSH_30A~  N NUMB   0029h            
TURNIGY_PLUSH_12A~  N NUMB   0020h            
XP_7A_MULTI. . . .  N NUMB   0006h            
READ_TAGS. . . . .  C ADDR   1C3FH   A 
RUN5 . . . . . . .  C ADDR   16A8H   A 
COMP_READ. . . . .  C ADDR   0DC5H   A 
COMP_WAIT_SET_RES~  C ADDR   0D81H   A 
DIVIDE_WAIT_TIMES.  C ADDR   0CBCH   A 
GOVERNOR_CORR_NEG~  C ADDR   0A22H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0900H   A 
GOVERNOR_TARGET_C~  C ADDR   0881H   A 
CALC_GOVERNOR_TAR~  C ADDR   0879H   A 
PCA_INT_PWM_DIVID~  C ADDR   06F9H   A 
T2_INT_CURRENT_PW~  C ADDR   04E0H   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_DEMAG_COMP_WA~  I ADDR   00A2H   A 
PGM_PPM_MAX_THROT~  I ADDR   0097H   A 
BEEP_STRENGTH. . .  D ADDR   006DH   A 
RCP_PREV_PERIOD_H.  D ADDR   0056H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
SMB1ADR. . . . . .  D ADDR   00D7H   A 
P2MDIN . . . . . .  D ADDR   00F3H   A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_TAIL  N NUMB   004Ah            
TURNIGY_AE_45A_MU~  N NUMB   003Fh            
TURNIGY_PLUSH_40A~  N NUMB   002Ch            
TURNIGY_PLUSH_30A~  N NUMB   002Ah            
TURNIGY_PLUSH_18A~  N NUMB   0022h            
TURNIGY_PLUSH_12A~  N NUMB   0021h            
SUPERMICRO_3P5A_T~  N NUMB   0017h            
RUN6 . . . . . . .  C ADDR   16C6H   A 
ARMING_START . . .  C ADDR   1321H   A 
MEASURE_PWM_FREQ_~  C ADDR   12C5H   A 
DECREMENT_STEP_EX~  C ADDR   106FH   A 
GOVERNOR_DEACTIVA~  C ADDR   088BH   A 
PCA_INT_CHECK_LEG~  C ADDR   070AH   A 
PWM_BNFET_APFET_O~  C ADDR   0302H   A 
PWM_ANFET_BPFET_O~  C ADDR   0237H   A 
PWM_NOFET_ON . . .  C ADDR   01D1H   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
PGM_THROTTLE_RATE~  I ADDR   00A0H   A 
PGM_MAIN_REARM_ST~  I ADDR   008DH   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
CURR_PWMOFF_COMP_~  N NUMB   0007h            
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
MUX_A1 . . . . . .  N NUMB   0002h            
COMP_PWM_HIGH_ON_~  N NUMB   001Eh            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
IDA1L. . . . . . .  D ADDR   0096H   A 
ALIGN_RCE_BL15P_M~  N NUMB   005Bh            
SKYWALKER_40A_MUL~  N NUMB   004Bh            
TURNIGY_PLUSH_40A~  N NUMB   002Dh            
SUPERMICRO_3P5A_M~  N NUMB   0018h            
DP_3A_MAIN . . . .  N NUMB   0013h            
ARM_TARGET_UPDATED  C ADDR   13F4H   A 
EVALUATE_COMPARAT~  C ADDR   0DD4H   A 
TEMP_CHECK_EXIT. .  C ADDR   0B30H   A 
GOVERNOR_APPLY_PR~  C ADDR   09A7H   A 
PWM_CNFET_APFET_O~  C ADDR   034BH   A 
PWM_ANFET_CPFET_O~  C ADDR   0280H   A 
EEP_PGM_GOV_MODE .  C ADDR   1A05H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008CH   A 
INITIALIZED_L_DUM~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0041H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
DEFAULT_PGM_PPM_M~  N NUMB   0025h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
MUX_B1 . . . . . .  N NUMB   0000h            
MUX_A2 . . . . . .  N NUMB   0003h            
SI0. . . . . . . .  B ADDR   00C0H.0 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
SMB1DAT. . . . . .  D ADDR   00C2H   A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
P0MASK . . . . . .  D ADDR   00FEH   A 
TURNIGY_PLUSH_60A~  N NUMB   002Fh            
NORMAL_RUN_CHECKS.  C ADDR   1714H   A 
DEC_STEP_MED_LOW .  C ADDR   105DH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D50H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0C8BH   A 
CALC_GOVERNOR_PRO~  C ADDR   08D7H   A 
T2_INT_PPM_TIMEOU~  C ADDR   0444H   A 
PWM_CNFET_BPFET_O~  C ADDR   03A4H   A 
PWM_BNFET_CPFET_O~  C ADDR   02C1H   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   0098H   A 
PGM_STARTUP_ACCEL.  I ADDR   0090H   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
MUX_C1 . . . . . .  N NUMB   0002h            
MUX_B2 . . . . . .  N NUMB   0001h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
SI1. . . . . . . .  B ADDR   00C0H.0 A 
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
TMR4RLH. . . . . .  D ADDR   0093H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
P1MASK . . . . . .  D ADDR   00EEH   A 
CRC0CNT. . . . . .  D ADDR   00DEH   A 
POLARIS_THUNDER_1~  N NUMB   0086h            
ALIGN_RCE_BL35P_M~  N NUMB   0061h            
TURNIGY_PLUSH_60A~  N NUMB   0030h            
TURNIGY_PLUSH_25A~  N NUMB   0026h            
PROGRAM_BY_TX_ENT~  C ADDR   13DDH   A 
READ_ALL_EEPROM_P~  C ADDR   1778H   A 
WAIT_FOR_COMM_BLI~  C ADDR   0E27H   A 
T0_INT_PWM_OFF_ST~  C ADDR   00E0H   A 
T0_INT . . . . . .  C ADDR   00C1H   A 
_EEP_PGM_VOLT_COMP  C ADDR   1A14H   A 
EEP_PGM_GOV_I_GAIN  C ADDR   1A04H   A 
PGM_STARTUP_PWR. .  I ADDR   0086H   A 
RCP_STOP_CNT . . .  D ADDR   005BH   A 
NEW_RCP. . . . . .  D ADDR   0058H   A 
RCP_PREV_PERIOD_L.  D ADDR   0055H   A 
PGM_DIR_REV. . . .  N NUMB   0005h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00D0h            
MUX_C2 . . . . . .  N NUMB   0003h            
DEBUGPIN . . . . .  N NUMB   0004h            
ANFET. . . . . . .  N NUMB   0002h            
TF5LEN . . . . . .  B ADDR   00C8H.5 A 
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
TMR5RLH. . . . . .  D ADDR   00CBH   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
POLARIS_THUNDER_1~  N NUMB   0087h            
TURNIGY_PLUSH_80A~  N NUMB   0032h            
TURNIGY_PLUSH_25A~  N NUMB   0027h            
DECODE_DEMAG_COMP.  C ADDR   11B5H   A 
EVAL_COMP_EXIT . .  C ADDR   0DFBH   A 
EVAL_COMP_NO_DEMAG  C ADDR   0DE3H   A 
STEPPER_STEP_LOW .  C ADDR   0C0EH   A 
MEASURE_LIPO_ADJU~  C ADDR   0A80H   A 
PCA_INT_SET_TIMEO~  C ADDR   0726H   A 
PWM_AFET_ON. . . .  C ADDR   01D3H   A 
T0_INT_PWM_ON_EXE~  C ADDR   00CDH   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
PGM_DEMAG_COMP . .  I ADDR   009CH   A 
WT_STEPPER_STEP_H.  D ADDR   0050H   A 
PREV_COMM_H. . . .  D ADDR   003AH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0028H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0004h            
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0004h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
TMR4H. . . . . . .  D ADDR   0095H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
REVISION . . . . .  D ADDR   00ACH   A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
TURNIGY_PLUSH_80A~  N NUMB   0033h            
TURNIGY_PLUSH_18A~  N NUMB   0023h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
STEPPER_ROT_EXIT .  C ADDR   15CCH   A 
STEPPER_METHOD_ST~  C ADDR   1507H   A 
COMM12_DAMP. . . .  C ADDR   0E81H   A 
SETUP_COMM_WAIT. .  C ADDR   0DFCH   A 
CALC_NEXT_COMM_TI~  C ADDR   0C29H   A 
CHECK_VOLTAGE_LIM.  C ADDR   0B5CH   A 
CALC_GOVERNOR_INT~  C ADDR   096CH   A 
T2_INT_SET_CURREN~  C ADDR   04DDH   A 
PWM_BFET_ON. . . .  C ADDR   01E5H   A 
T2_INT . . . . . .  C ADDR   03EBH   A 
PGM_DIRECTION_REV.  I ADDR   0088H   A 
LIPO_ADC_REFERENC~  D ADDR   0067H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0006h            
COMP1_USED . . . .  N NUMB   0000h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
TMR5H. . . . . . .  D ADDR   00CDH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
IDA1CN . . . . . .  D ADDR   00B9H   A 
EIP2 . . . . . . .  D ADDR   00BFH   A 
ALIGN_RCE_BL15P_T~  N NUMB   005Ch            
RCTIMER_6A_MAIN. .  N NUMB   0055h            
TURNIGY_PLUSH_18A~  N NUMB   0024h            
DP_3A_TAIL . . . .  N NUMB   0014h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
ARM_END_BEEP . . .  C ADDR   1400H   A 
THROTTLE_HIGH_CAL~  C ADDR   1374H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D41H   A 
LOAD_MIN_TIME. . .  C ADDR   0CD8H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0CA4H   A 
SET_STARTUP_PWM. .  C ADDR   0B84H   A 
GOVERNOR_STORE_IN~  C ADDR   0966H   A 
GOVERNOR_ACTIVATE~  C ADDR   08C8H   A 
PWM_CFET_ON. . . .  C ADDR   01F7H   A 
DEMAG_POWER_TABLE.  C ADDR   00ACH   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   0533H   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0085H   A 
TX_PGM_PARAVAL_NO.  D ADDR   006FH   A 
ADC_CONVERSION_CNT  D ADDR   006AH   A 
GOV_ARM_TARGET . .  D ADDR   0047H   A 
COMP_WAIT_READS. .  D ADDR   003EH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_TAIL_~  N NUMB   000Dh            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TMR4RLL. . . . . .  D ADDR   0092H   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
SN0. . . . . . . .  D ADDR   00ABH   A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
ALIGN_RCE_BL15P_M~  N NUMB   005Dh            
DP_3A_MULTI. . . .  N NUMB   0015h            
FUNC_PARAVAL . . .  C ADDR   1D79H   A 
WAIT1S_LOOP. . . .  C ADDR   1CE7H   A 
STORE_MULTI_FUNC_1  C ADDR   1C65H   A 
RUN6_CHECK_RCP_TI~  C ADDR   1737H   A 
DECREMENT_STEP . .  C ADDR   1020H   A 
COMM23_DAMP. . . .  C ADDR   0EB1H   A 
ADJUST_TIMING. . .  C ADDR   0CDCH   A 
STEPPER_STEP_MED_~  C ADDR   0BE4H   A 
MEASURE_LIPO_DIVI~  C ADDR   0AA0H   A 
MEASURE_LIPO_START  C ADDR   0A33H   A 
CALC_GOVERNOR_PRO~  C ADDR   09D0H   A 
GOVERNOR_INT_MIN_~  C ADDR   0961H   A 
GOVERNOR_LIMIT_PR~  C ADDR   0907H   A 
BEEP_F1. . . . . .  C ADDR   077AH   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0084H   A 
CURRENT_AVERAGE_T~  D ADDR   006BH   A 
PWM_OFF_CNT. . . .  D ADDR   0061H   A 
PWM_SPOOLUP_BEG. .  D ADDR   005EH   A 
PWM_LIMIT. . . . .  D ADDR   005CH   A 
WT_ZC_SCAN_H . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   000Dh            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0007h            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
TMR5RLL. . . . . .  D ADDR   00CAH   A 
TMR3L. . . . . . .  D ADDR   0094H   A 
SN1. . . . . . . .  D ADDR   00ACH   A 
ALIGN_RCE_BL35P_T~  N NUMB   0062h            
STORE_MULTI_FUNC_2  C ADDR   1C6DH   A 
INITIAL_RUN_PHASE~  C ADDR   1730H   A 
STEPPER_STEP_MED .  C ADDR   0BF2H   A 
GOVERNOR_STORE_PR~  C ADDR   09CEH   A 
GOVERNOR_CHECK_PR~  C ADDR   0992H   A 
MULT_S16_BY_U8_PO~  C ADDR   083CH   A 
DIV_U16_BY_U16 . .  C ADDR   07EAH   A 
BEEP_ONOFF . . . .  C ADDR   079DH   A 
BEEP_F2. . . . . .  C ADDR   0781H   A 
PCA_INT_CHECK_DIFF  C ADDR   0641H   A 
T2_INT_SKIP_START.  C ADDR   0448H   A 
T0_INT_PWM_OFF_FU~  C ADDR   01CAH   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   0010h            
PGM_GOV_MODE . . .  I ADDR   0082H   A 
WT_STEPPER_STEP_L.  D ADDR   004FH   A 
PREV_COMM_L. . . .  D ADDR   0039H   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
TMR4L. . . . . . .  D ADDR   0094H   A 
SN2. . . . . . . .  D ADDR   00ADH   A 
SFRPGCN. . . . . .  D ADDR   00CFH   A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
CRC0FLIP . . . . .  D ADDR   009AH   A 
ALIGN_RCE_BL35P_M~  N NUMB   0063h            
ALIGN_RCE_BL15X_M~  N NUMB   0058h            
TURNIGY_KFORCE_40~  N NUMB   0040h            
XP_25A_MAIN. . . .  N NUMB   0010h            
PARAVAL_NO_ENTRY .  C ADDR   1D73H   A 
STORE_MULTI_FUNC_3  C ADDR   1C75H   A 
SUCCESS_BEEP_INVE~  C ADDR   1D1CH   A 
SUCCESS_BEEP . . .  C ADDR   1CEDH   A 
FIND_THROTTLE_GAIN  C ADDR   11CFH   A 
DECREMENT_STEPPER~  C ADDR   1014H   A 
COMM61_DAMP. . . .  C ADDR   0FB2H   A 
COMM34_DAMP. . . .  C ADDR   0F05H   A 
TEMP_AVERAGE_INC_~  C ADDR   0AEFH   A 
GOVERNOR_INT_MAX_~  C ADDR   095AH   A 
GOVERNOR_LIMIT_IN~  C ADDR   093EH   A 
BEEP_F3. . . . . .  C ADDR   0788H   A 
PCA_INT_FAIL_MINI~  C ADDR   0574H   A 
T0_INT_PWM_ON_EXI~  C ADDR   03E4H   A 
T0_INT_PWM_OFF_EX~  C ADDR   01BAH   A 
LIPO_ADC_REFERENC~  D ADDR   0066H   A 
SPOOLUP_LIMIT_CNT.  D ADDR   0062H   A 
PWM_ON_CNT . . . .  D ADDR   0060H   A 
FULL_THROTTLE_RAN~  N NUMB   0007h            
RCP_PWM_FREQ_12KHZ  N NUMB   0004h            
CURR_PWMOFF_DAMPED  N NUMB   0006h            
COMM_TIME_RED. . .  N NUMB   0008h            
P1_INIT. . . . . .  N NUMB   0002h            
TEMP_LIMIT . . . .  N NUMB   0072h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
TMR5L. . . . . . .  D ADDR   00CCH   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
SN3. . . . . . . .  D ADDR   00AEH   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
XP_12A_TAIL. . . .  N NUMB   000Bh            
STORE_MULTI_FUNC_4  C ADDR   1C7DH   A 
DAMPED_TRANSITION.  C ADDR   1625H   A 
BEEP_DELAY_SET . .  C ADDR   143BH   A 
PROGRAM_BY_TX_ENT~  C ADDR   135AH   A 
DECODE_PWM_FREQ_L~  C ADDR   117AH   A 
DECODE_DAMPING_3 .  C ADDR   1100H   A 
BEEP_F4. . . . . .  C ADDR   078FH   A 
PCA_INT_PPM_MAX_C~  C ADDR   06D9H   A 
PCA_INT_RESTORE_E~  C ADDR   062DH   A 
T2H_INT_RCP_EXIT .  C ADDR   052AH   A 
EEP_PGM_GOV_P_GAIN  C ADDR   1A03H   A 
PGM_STARTUP_PWR_D~  I ADDR   00A1H   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEMAG_CUT_POWER. .  N NUMB   0004h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P2_INIT. . . . . .  N NUMB   00FFh            
DAMPED_MODE_ENABLE  N NUMB   0001h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
T5SPLIT. . . . . .  B ADDR   00C8H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
H_KING_10A_MAIN. .  N NUMB   0067h            
ALIGN_RCE_BL35X_M~  N NUMB   005Eh            
RCTIMER_6A_TAIL. .  N NUMB   0056h            
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   1DD7H   A 
STORE_MULTI_FUNC_5  C ADDR   1C85H   A 
READ_EEPROM_BYTE .  C ADDR   1C00H   A 
THROTTLE_LOW_CAL .  C ADDR   13A8H   A 
DECODE_DAMPING_4 .  C ADDR   110DH   A 
COMM45_DAMP. . . .  C ADDR   0F36H   A 
WAIT_FOR_COMM_SET~  C ADDR   0E62H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0B07H   A 
GOVERNOR_APPLY_IN~  C ADDR   0A09H   A 
GOVERNOR_LIMIT_PR~  C ADDR   099DH   A 
BEEP_OFF . . . . .  C ADDR   07DEH   A 
WAIT10MS . . . . .  C ADDR   075FH   A 
T2H_INT_RCP_NO_LI~  C ADDR   0528H   A 
T0_INT_PWM_ON_EXIT  C ADDR   03D7H   A 
EEP_PGM_BEC_VOLTA~  C ADDR   1A20H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   000Ah            
PGM_STARTUP_METHOD  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0092H   A 
TX_PGM_FUNC_NO . .  D ADDR   006EH   A 
WT_ZC_SCAN_L . . .  D ADDR   004BH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
P0_SKIP. . . . . .  N NUMB   FFFFFFDFh            
DEFAULT_PGM_MAIN_~  N NUMB   0009h            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
H_KING_20A_MAIN. .  N NUMB   006Ah            
RCTIMER_6A_MULTI .  N NUMB   0057h            
HIMODEL_COOL_22A_~  N NUMB   004Ch            
XP_7A_FAST_MULTI .  N NUMB   0009h            
STORE_MULTI_FUNC_6  C ADDR   1C8DH   A 
READ_TAG . . . . .  C ADDR   1C48H   A 
RESET_CAL_DONE . .  C ADDR   1217H   A 
DECODE_DAMPING_5 .  C ADDR   111AH   A 
DECODE_PARAMETERS.  C ADDR   10E9H   A 
STEPPER_TIMER_WAIT  C ADDR   1079H   A 
STORE_TIMES_INCRE~  C ADDR   0D0EH   A 
CHECK_VOLTAGE_GOOD  C ADDR   0B55H   A 
MEASURE_LIPO_CELLS  C ADDR   0A33H   A 
CALC_GOVERNOR_INT~  C ADDR   0910H   A 
PCA_INT_PPM_CALCU~  C ADDR   06B4H   A 
PCA_INT_EXIT . . .  C ADDR   0740H   A 
T2_INT_RCP_UPDATE~  C ADDR   0479H   A 
T0_INT_PWM_OFF_DO~  C ADDR   0131H   A 
RCP_PERIOD_DIFF_A~  D ADDR   0057H   A 
RCP_TIMEOUT_PPM. .  N NUMB   000Ah            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P1_SKIP. . . . . .  N NUMB   0002h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
TF5H . . . . . . .  B ADDR   00C8H.7 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
TMR3CN . . . . . .  D ADDR   0091H   A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
EIP1H. . . . . . .  D ADDR   0085H   A 
HIMODEL_COOL_41A_~  N NUMB   0052h            
TURNIGY_PLUSH_6A_~  N NUMB   0019h            
STORE_MULTI_FUNC_7  C ADDR   1C95H   A 
RUN6_CHECK_SPEED .  C ADDR   1741H   A 
WAIT_FOR_POWER_ON~  C ADDR   1464H   A 
DECODE_DAMPING_6 .  C ADDR   1124H   A 
DEC_STEP_LOW . . .  C ADDR   1066H   A 
COMM56_DAMP. . . .  C ADDR   0F81H   A 
SWITCH_POWER_OFF .  C ADDR   1004H   A 
WAIT30MS . . . . .  C ADDR   0763H   A 
PCA_INT_CHECK_1KHZ  C ADDR   061EH   A 
T2H_INT. . . . . .  C ADDR   04F9H   A 
T0_INT_PWM_OFF_CO~  C ADDR   017FH   A 
GOV_INTEGRAL_X . .  D ADDR   0043H   A 
DEFAULT_PGM_MULTI~  N NUMB   0009h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
NFETON_DELAY . . .  N NUMB   0006h            
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
STA0 . . . . . . .  B ADDR   00C0H.5 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
TS0DATH. . . . . .  D ADDR   00D3H   A 
TMR4CN . . . . . .  D ADDR   0091H   A 
PCA0PWM. . . . . .  D ADDR   00F7H   A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
EIP2H. . . . . . .  D ADDR   0086H   A 
ALIGN_RCE_BL15X_T~  N NUMB   0059h            
HIMODEL_COOL_33A_~  N NUMB   004Fh            
TURNIGY_KFORCE_40~  N NUMB   0041h            
XP_25A_TAIL. . . .  N NUMB   0011h            
FUNC_PARAVAL_CONT~  C ADDR   1DA6H   A 
STORE_MULTI_FUNC_8  C ADDR   1C9DH   A 
WRITE_TAGS . . . .  C ADDR   1C52H   A 
WAIT1S . . . . . .  C ADDR   1CE5H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   174AH   A 
EVAL_COMP_CHECK_T~  C ADDR   0DF1H   A 
ADJUST_TIMING_TWO~  C ADDR   0CFEH   A 
CALC_GOVERNOR_PRO~  C ADDR   0974H   A 
GOVERNOR_ACTIVATE~  C ADDR   08CFH   A 
WAITXMS_M. . . . .  C ADDR   0771H   A 
PCA_INT_CHECK_2KHZ  C ADDR   060DH   A 
T0_INT_PWM_OFF_ST~  C ADDR   0104H   A 
DEMAG_WAIT_TABLE .  C ADDR   00A7H   A 
PGM_BEACON_DELAY .  I ADDR   009AH   A 
PGM_BEACON_STRENG~  I ADDR   0099H   A 
GOV_TARGET_H . . .  D ADDR   0040H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
STA1 . . . . . . .  B ADDR   00C0H.5 A 
PX1. . . . . . . .  B ADDR   00B8H.2 A 
TMR5CN . . . . . .  D ADDR   00C8H   A 
SMBTC. . . . . . .  D ADDR   00C7H   A 
P2SKIP . . . . . .  D ADDR   00D6H   A 
IP . . . . . . . .  D ADDR   00B8H   A 
CRC0CN . . . . . .  D ADDR   00DFH   A 
POLARIS_THUNDER_2~  N NUMB   0076h            
H_KING_50A_MAIN. .  N NUMB   0070h            
GAUI_GE_183_18A_M~  N NUMB   0064h            
ALIGN_RCE_BL15X_M~  N NUMB   005Ah            
TURNIGY_KFORCE_40~  N NUMB   0042h            
XP_25A_MULTI . . .  N NUMB   0012h            
STORE_MULTI_FUNC_9  C ADDR   1CA5H   A 
READ_INITIAL_TEMP.  C ADDR   14AAH   A 
WAIT_FOR_POWER_ON~  C ADDR   1455H   A 
DECODE_PWM_FREQ_E~  C ADDR   117FH   A 
WAIT_FOR_COMM_WAIT  C ADDR   0E64H   A 
PWM_WAIT_STARTUP .  C ADDR   0DB5H   A 
START_ADC_CONVERS~  C ADDR   0AC8H   A 
MULT_S16_BY_U8_EX~  C ADDR   0870H   A 
PCA_INT_PPM_LIMIT~  C ADDR   06EBH   A 
T2H_INT_RCP_GOV_P~  C ADDR   051CH   A 
T2_INT_PWM_MIN_RUN  C ADDR   04A1H   A 
PWM_BNFET_APFET_O~  C ADDR   02E4H   A 
PWM_ANFET_BPFET_O~  C ADDR   0211H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0199H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
COMP_COMM. . . . .  N NUMB   0001h            
PFETON_DELAY . . .  N NUMB   0006h            
PSW. . . . . . . .  D ADDR   00D0H   A 
POLARIS_THUNDER_3~  N NUMB   0079h            
POLARIS_THUNDER_1~  N NUMB   0073h            
H_KING_10A_TAIL. .  N NUMB   0068h            
ALIGN_RCE_BL35X_T~  N NUMB   005Fh            
XP_18A_TAIL. . . .  N NUMB   000Eh            
STORE_IN_RAM_EXIT.  C ADDR   1CE2H   A 
VALIDATE_RCP_START  C ADDR   12FBH   A 
DEC_STEP_MED_HIGH.  C ADDR   104BH   A 
COMM12_NONDAMP . .  C ADDR   0E96H   A 
COMM1COMM2 . . . .  C ADDR   0E77H   A 
TEMP_AVERAGE_UPDA~  C ADDR   0B05H   A 
TEMP_AVERAGE_DEC .  C ADDR   0AFBH   A 
CALC_GOVERNOR_PRO~  C ADDR   096DH   A 
WAITXMS_O. . . . .  C ADDR   076FH   A 
PCA_INT_PPM_TIMEO~  C ADDR   0732H   A 
PCA_INT_CHECK_4KHZ  C ADDR   05FCH   A 
PWM_CNFET_APFET_O~  C ADDR   0325H   A 
PWM_ANFET_CPFET_O~  C ADDR   0262H   A 
T0_INT_PWM_OFF_CO~  C ADDR   01ABH   A 
T0_INT_PWM_ON_STO~  C ADDR   00D4H   A 
T0_INT_PWM_OFF . .  C ADDR   00D7H   A 
EEPROM_FW_SUB_REV~  N NUMB   0004h            
PGM_GOV_RANGE. . .  I ADDR   0094H   A 
GOV_PROPORTIONAL_H  D ADDR   0045H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
RCP_IN . . . . . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0009h            
COMP_PWM_LOW_OFF_~  N NUMB   0014h            
ONE_S_CAPABLE. . .  N NUMB   0000h            
T5XCLK . . . . . .  B ADDR   00C8H.0 A 
TR5. . . . . . . .  B ADDR   00C8H.2 A 
TF5L . . . . . . .  B ADDR   00C8H.6 A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
ADC0GTH. . . . . .  D ADDR   00C4H   A 
POLARIS_THUNDER_4~  N NUMB   007Ch            
H_KING_20A_TAIL. .  N NUMB   006Bh            
H_KING_10A_MULTI .  N NUMB   0069h            
ALIGN_RCE_BL35X_M~  N NUMB   0060h            
HIMODEL_COOL_22A_~  N NUMB   004Dh            
XP_18A_MULTI . . .  N NUMB   000Fh            
READ_EEPROM_EXIT .  C ADDR   1826H   A 
WAIT_FOR_POWER_ON~  C ADDR   1418H   A 
DEC_STEP_MED . . .  C ADDR   1054H   A 
READ_TIMER . . . .  C ADDR   0C34H   A 
CHECK_VOLTAGE_STA~  C ADDR   0B34H   A 
CALC_GOVERNOR_INT~  C ADDR   0A32H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0947H   A 
MULT_S16_BY_U8_DI~  C ADDR   0855H   A 
BEEP . . . . . . .  C ADDR   0796H   A 
PCA_INT_FALL . . .  C ADDR   065AH   A 
T2_INT_PWM_EXIT. .  C ADDR   04EDH   A 
T2_INT_SKIP_END. .  C ADDR   0450H   A 
PWM_CNFET_BPFET_O~  C ADDR   0376H   A 
PWM_BNFET_CPFET_O~  C ADDR   02A3H   A 
T0_INT_PWM_OFF_DA~  C ADDR   0148H   A 
TX_PGM_PARAMS_MUL~  C ADDR   00B1H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   009FH   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
DAMPING_ON . . . .  D ADDR   0065H   A 
COMM_PHASE . . . .  D ADDR   003DH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0027H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P0_PUSHPULL. . . .  N NUMB   0000h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
MASTER0. . . . . .  B ADDR   00C0H.7 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
TS0DATL. . . . . .  D ADDR   00D2H   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
SMB1CF . . . . . .  D ADDR   00C1H   A 
PFE0CN . . . . . .  D ADDR   00B5H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
H_KING_35A_MAIN. .  N NUMB   006Dh            
H_KING_20A_MULTI .  N NUMB   006Ch            
HIMODEL_COOL_41A_~  N NUMB   0053h            
HIMODEL_COOL_22A_~  N NUMB   004Eh            
TURNIGY_PLUSH_6A_~  N NUMB   001Ah            
ERASE_FLASH. . . .  C ADDR   1C19H   A 
PROGRAM_BY_TX. . .  C ADDR   1D6AH   A 
COMM23_NFET. . . .  C ADDR   0ECEH   A 
COMM23_NONDAMP . .  C ADDR   0ECBH   A 
COMM2COMM3 . . . .  C ADDR   0EA9H   A 
WAIT_FOR_COMM_SEC~  C ADDR   0E42H   A 
STEPPER_STEP_HIGH.  C ADDR   0BD6H   A 
MEASURE_LIPO_CELL~  C ADDR   0A65H   A 
GOVERNOR_STORE_IN~  C ADDR   0A30H   A 
GOVERNOR_CHECK_IN~  C ADDR   09F2H   A 
GOVERNOR_CORR_PRO~  C ADDR   09BBH   A 
GOVERNOR_ACTIVATE~  C ADDR   08BCH   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_BEC_VOLTAGE_H~  I ADDR   009DH   A 
PGM_INPUT_POL. . .  I ADDR   0089H   A 
WT_COMM_H. . . . .  D ADDR   004EH   A 
GOV_TARGET_L . . .  D ADDR   003FH   A 
DIRECT_STARTUP_PH~  N NUMB   0003h            
FLAGS0 . . . . . .  D ADDR   002BH   A 
RCP_EDGE_CNT . . .  D ADDR   002AH   A 
CURRENT_PWM_LIMIT~  D ADDR   0025H   A 
COMM_TIME_MIN. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFF0h            
COMP_PWM_LOW_ON_D~  N NUMB   000Ah            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
MASTER1. . . . . .  B ADDR   00C0H.7 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
POLARIS_THUNDER_6~  N NUMB   007Fh            
HIMODEL_COOL_41A_~  N NUMB   0054h            
HIMODEL_COOL_33A_~  N NUMB   0050h            
TURNIGY_AE_20A_MA~  N NUMB   0034h            
TURNIGY_PLUSH_6A_~  N NUMB   001Bh            
FUNC_PARAVAL_STORE  C ADDR   1D98H   A 
WRITE_EEPROM_BYTE~  C ADDR   1C05H   A 
READ_EEPROM_READ .  C ADDR   1799H   A 
TEST_GAIN. . . . .  C ADDR   11ECH   A 
MEASURE_LIPO_EXIT.  C ADDR   0AC7H   A 
GOVERNOR_LIMIT_PR~  C ADDR   09A3H   A 
GOVERNOR_CHECK_PR~  C ADDR   08F4H   A 
PCA_INT_SECOND_ME~  C ADDR   05A0H   A 
T2H_INT_RCP_STOP_~  C ADDR   0509H   A 
PCA_INT. . . . . .  C ADDR   053DH   A 
FLAGS1 . . . . . .  D ADDR   002CH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P2_PUSHPULL. . . .  N NUMB   0010h            
P1_DIGITAL . . . .  N NUMB   FFFFFFFDh            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
POLARIS_THUNDER_2~  N NUMB   0077h            
H_KING_50A_TAIL. .  N NUMB   0071h            
GAUI_GE_183_18A_T~  N NUMB   0065h            
HIMODEL_COOL_33A_~  N NUMB   0051h            
TURNIGY_AE_30A_MA~  N NUMB   003Ah            
MEASURE_PWM_FREQ_~  C ADDR   12C3H   A 
COMM61_NFET. . . .  C ADDR   0FD7H   A 
COMM61_NONDAMP . .  C ADDR   0FD4H   A 
COMM6COMM1 . . . .  C ADDR   0FAAH   A 
COMM34_NONDAMP . .  C ADDR   0F12H   A 
COMM3COMM4 . . . .  C ADDR   0EF3H   A 
WAIT_FOR_COMM_EXIT  C ADDR   0E76H   A 
COMP_WAIT_SET_MAX~  C ADDR   0D6EH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D4AH   A 
CALC_NEW_WAIT_CHE~  C ADDR   0CAFH   A 
STARTUP_PWM_EXIT .  C ADDR   0BB3H   A 
MEASURE_LIPO_LIMI~  C ADDR   0AB7H   A 
GOVERNOR_CORR_PRO~  C ADDR   09CCH   A 
PCA_INT_CHECK_8KHZ  C ADDR   05EBH   A 
T0_INT_PWM_OFF_CL~  C ADDR   012BH   A 
GOV_PROP_PWM . . .  D ADDR   0046H   A 
GOV_PROPORTIONAL_L  D ADDR   0044H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002DH   A 
DEMAG_DETECTED . .  N NUMB   0003h            
RCP_SKIP_CNT . . .  D ADDR   0029H   A 
DEFAULT_PGM_MULTI~  N NUMB   0006h            
DEFAULT_PGM_MULTI~  N NUMB   0009h            
P2_DIGITAL . . . .  N NUMB   FFFFFFF1h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
ACK0 . . . . . . .  B ADDR   00C0H.1 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
REG0CN . . . . . .  D ADDR   00C9H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
CRC0IN . . . . . .  D ADDR   009CH   A 
CKCON1 . . . . . .  D ADDR   00F4H   A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
POLARIS_THUNDER_8~  N NUMB   0082h            
POLARIS_THUNDER_3~  N NUMB   007Ah            
POLARIS_THUNDER_2~  N NUMB   0078h            
POLARIS_THUNDER_1~  N NUMB   0074h            
H_KING_50A_MULTI .  N NUMB   0072h            
GAUI_GE_183_18A_M~  N NUMB   0066h            
TURNIGY_KFORCE_12~  N NUMB   0043h            
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6812    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     80    ----
   IDATA SIZE       =     84    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
