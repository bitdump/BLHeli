MACRO ASSEMBLER BLHELI                                      09/20/12 17:22:46 PAGE     1


DOS MACRO ASSEMBLER MA51 V06.12.11.280
OBJECT MODULE PLACED IN OUTPUT\SKYWALKER_40_MULTI_REV7_0.OBJ
ASSEMBLER INVOKED BY: SET(BESC=57) OBJECT(OUTPUT\SKYWALKER_40_MULTI_REV7_0.OBJ) DEBUG EP QUIET PIN(C:\SILABS\MCU\INC;C:\RAISONANCE\RIDE\INC;C:\RAISONANCE\RIDE\INC\51) 

LOC     OBJ           LINE    SOURCE
                         1     $NOMOD51
                         2     ;**** **** **** **** ****
                         3     ;
                         4     ; BLHeli program for controlling brushless motors in helicopters
                         5     ;
                         6     ; Copyright 2011, 2012 Steffen Skaug
                         7     ; This program is distributed under the terms of the GNU General Public License
                         8     ;
                         9     ; This file is part of BLHeli.
                        10     ;
                        11     ; BLHeli is free software: you can redistribute it and/or modify
                        12     ; it under the terms of the GNU General Public License as published by
                        13     ; the Free Software Foundation, either version 3 of the License, or
                        14     ; (at your option) any later version.
                        15     ;
                        16     ; BLHeli is distributed in the hope that it will be useful,
                        17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        19     ; GNU General Public License for more details.
                        20     ;
                        21     ; You should have received a copy of the GNU General Public License
                        22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                        23     ;
                        24     ;**** **** **** **** ****
                        25     ;
                        26     ; This software is intended for SiLabs 8bit controllers in a micro heli environment.
                        27     ;
                        28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.versanet.de/~bkonze/blc_6a/blc_6a.htm
                        29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                        30     ;
                        31     ; This file is best viewed with tab width set to 5
                        32     ;
                        33     ; The input signal can be positive 1kHz, 2kHz, 4kHz or 8kHz PWM (taken from the "resistor tap" on mCPx)
                        34     ; And the input signal can be PPM (1-2ms) at rates up to several hundred Hz.
                        35     ; The code adapts itself to the various input modes/frequencies
                        36     ; The code ESC can also be programmed to accept inverted input signal.
                        37     ;
                        38     ; The first lines of the software must be modified according to the chosen environment:
                        39     ; Uncomment the selected ESC and main/tail/multi mode
                        40     ; BESC EQU "ESC"_"mode" 						
                        41     ; 
                        42     ;**** **** **** **** ****
                        43     ; Revision history:
                        44     ; - Rev1.0: Initial revision based upon BLHeli for AVR controllers
                        45     ; - Rev2.0: Changed "Eeprom" initialization, layout and defaults
                        46     ;           Various changes and improvements to comparator reading. Now using timer1 for time from pwm on/off
                        47     ;           Beeps are made louder
                        48     ;           Added programmable low voltage limit
                        49     ;           Added programmable damped tail mode (only for 1S ESCs)
                        50     ;           Added programmable motor rotation direction
                        51     ; - Rev2.1: (minor changes by 4712)
                        52     ;		  Added Disable TX Programming by PC Setup Application 
                        53     ;		  therfore changed EEPROM_LAYOUT_REVISION = 8					
                        54     ;		  Added Vdd Monitor as reset source when writing to "EEProm"
                        55     ;		  Changed for use of batch file to assemble, link and make hex files	
                        56     ; - Rev2.2: (minor changes by 4712)
                        57     ;           Added Disable Throttle Re-Arming every motor start by PC Setup Application 
                        58     ; - Rev2.3: (minor changes by 4712)
                        59     ;           Added bugfixed (2x CLR C before j(n)c operations)thx Steffen!			
                        60     ; - Rev2.4: Revisions 2.1 to 2.3 integrated
                        61     ; - Rev3.0: Added PPM (1050us-1866us) as accepted input signal
                        62     ;           Added startup rpm as a programming parameter
                        63     ;           Added startup acceleration as a programming parameter
                        64     ;           Added option for using voltage measurements to compensate motor power
                        65     ;           Added governor target by setup as a governor mode option
                        66     ;           Governor is kept active regardless of rpm
                        67     ;           Smooth governor spoolup/down in arm and setup modes
                        68     ;           Increased governor P and I gain programming ranges
                        69     ;           Increased and changed low voltage limit programming range
                        70     ;           Disabled tx programming entry for all but the first arming sequence after power on
                        71     ;           Made it possible to skip parameters in tx programming by setting throttle midstick
                        72     ;           Made it default not to rearm for every restart
                        73     ; - Rev3.1: Fixed bug that prevented chosen parameter to be set in tx programming
                        74     ; - Rev3.2: ...also updated the EEPROM revision parameter
                        75     ; - Rev3.3: Fixed negative number bug in voltage compensation
                        76     ;           Fixed bug in startup power calculation for non-default power
                        77     ;           Prevented possibility for voltage compensation fighting low voltage limiting
                        78     ;           Applied overall spoolup control to ensure soft spoolup in any mode
                        79     ;           Added a delay of 3 seconds from initiation of main motor stop until new startup is allowed
                        80     ;           Reduced beep power to reduce power consumption for very strong motors/ESCs
                        81     ; - Rev3.4: Fixed bug that prevented full power in governor arm and setup modes
                        82     ;           Increased NFETON_DELAY for XP_7A and XP_12A to allow for more powerful fets
                        83     ;           Increased initial spoolup power, and linked to startup power
                        84     ; - Rev4.0: Fixed bug that made tail tx program beeps very weak
                        85     ;           Added thermal protection feature
                        86     ;           Governor P and I gain ranges are extended up to 8.0x gain
                        87     ;           Startup sequence is aborted upon zero throttle
                        88     ;           Avoided voltage compensation function induced latency for tail when voltage compensation is not enabled
                        89     ;           Improved input signal frequency detection robustness
                        90     ; - Rev4.1: Increased thermal protection temperature limits
                        91     ; - Rev5.0: Added multi(copter) operating mode. TAIL define changed to MODE with three modes: MAIN, TAIL and MULTI
                        92     ;           Added programmable commutation timing
                        93     ;           Added a damped light mode that has less damping, but that can be used with all escs
                        94     ;           Added programmable damping force
                        95     ;           Added thermal protection for startup too
                        96     ;           Added wait beeps when waiting more than 30 sec for throttle above zero (after having been armed)
                        97     ;           Modified tail idling to provide option for very low speeds
                        98     ;           Changed PPM range to 1150-1830us
                        99     ;           Arming sequence is dropped for PPM input, unless it is governor arm mode
                       100     ;           Loss of input signal will immediately stop the motor for PPM input
                       101     ;           Bug corrected in Turnigy Plush 6A voltage measurement setup
                       102     ;           FET switching delays are set for original fets. Stronger/doubled/tripled etc fets may require faster pfet off switching
                       103     ;           Miscellaneous other changes
                       104     ; - Rev6.0: Reverted comparator reading routine to rev5.0 equivalent, in order to avoid tail motor stops
                       105     ;           Added governor range programmability
                       106     ;           Implemented startup retry sequence with varying startup power for multi mode
                       107     ;           In damped light mode, damping is now applied to the active nfet phase for fully damped capable ESCs
                       108     ; - Rev6.1: Added input signal qualification criteria for PPM, to avoid triggering on noise spikes (fix for plush hardware)
                       109     ;           Changed main and multi mode stop criteria. Will now be in run mode, even if RC pulse input is zero
                       110     ;           Fixed bug in commutation that caused rough running in damped light mode
                       111     ;           Miscellaneous other changes
                       112     ; - Rev7.0  Added direct startup mode programmability
                       113     ;           Added throttle calibration. Min>=1000us and Max<=2000us. Difference must be >520us, otherwise max is shifted so that difference=520us
                       114     ;           Added programmable throttle change rate
                       115     ;           Added programmable beep strength, beacon strength and beacon delay
                       116     ;           Reduced power step to full power significantly
                       117     ;           Miscellaneous other changes
                       118     ;
                       119     ;**** **** **** **** ****
                       120     ; Up to 8K Bytes of In-System Self-Programmable Flash
                       121     ; 768 Bytes Internal SRAM
                       122     ;
                       123     ;**** **** **** **** ****
                       124     ; Master clock is internal 24MHz oscillator
                       125     ; Timer 0 (167/500ns counts) always counts up and is used for
                       126     ; - PWM generation
                       127     ; Timer 1 (167/500ns counts) always counts up and is not used
                       128     ; - Time from pwm on/off event
                       129     ; Timer 2 (500ns counts) always counts up and is used for
                       130     ; - RC pulse timeout/skip counts and commutation times
                       131     ; Timer 3 (500ns counts) always counts up and is used for
                       132     ; - Commutation timeouts
                       133     ; PCA0 (500ns counts) always counts up and is used for
                       134     ; - RC pulse measurement
                       135     ;
                       136     ;**** **** **** **** ****
                       137     ; Interrupt handling
                       138     ; The F330/2 does not disable interrupts when entering an interrupt routine.
                       139     ; Also some interrupt flags need to be cleared by software
                       140     ; The code disables interrupts in interrupt routines, in order to avoid nested interrupts
                       141     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                       142     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm interrupts.
                       143     ;
                       144     ;**** **** **** **** ****
                       145     ; Motor control:
                       146     ; - Brushless motor control with 6 states for each electrical 360 degrees
                       147     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before the next
                       148     ; - Timing advance in this implementation is set to 15deg nominally
                       149     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is off. This will absorb energy from bemf and make step settling more damped.
                       150     ; Motor sequence starting from zero crossing:
                       151     ; - Timer wait: Wt_Comm			15deg	; Time to wait from zero cross to actual commutation
                       152     ; - Timer wait: Wt_Advance		15deg	; Time to wait for timing advance. Nominal commutation point is after this
                       153     ; - Timer wait: Wt_Zc_Scan		7.5deg	; Time to wait before looking for zero cross
                       154     ; - Scan for zero cross			22.5deg	, Nominal, with some motor variations
                       155     ;
                       156     ; Motor startup:
                       157     ; Initial motor rotations are done with the motor controlled as a stepper motor.
                       158     ; In this stepper motor mode comparator information is not used.
                       159     ; Settle phase is the first, where there are a few commutations with increasing step length, in order to settle the motor in a predefined position.
                       160     ; Stepper phase comes next, where there is a step length decrease sequence.
                       161     ; Aquisition phase is the final phase, for stabilisation before normal bemf commutation run begins.
                       162     ;
                       163     ;**** **** **** **** ****
                       164     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  0001                 165     XP_3A_MAIN 			EQU 1
  0002                 166     XP_3A_TAIL 			EQU 2
  0003                 167     XP_3A_MULTI 			EQU 3
  0004                 168     XP_7A_MAIN 			EQU 4
  0005                 169     XP_7A_TAIL 			EQU 5
  0006                 170     XP_7A_MULTI 			EQU 6
  0007                 171     XP_7A_FAST_MAIN 		EQU 7
  0008                 172     XP_7A_FAST_TAIL 		EQU 8
  0009                 173     XP_7A_FAST_MULTI 		EQU 9
  000A                 174     XP_12A_MAIN 			EQU 10
  000B                 175     XP_12A_TAIL 			EQU 11
  000C                 176     XP_12A_MULTI 			EQU 12
  000D                 177     XP_18A_MAIN 			EQU 13
  000E                 178     XP_18A_TAIL 			EQU 14
  000F                 179     XP_18A_MULTI 			EQU 15
  0010                 180     XP_25A_MAIN 			EQU 16
  0011                 181     XP_25A_TAIL 			EQU 17
  0012                 182     XP_25A_MULTI 			EQU 18
  0013                 183     DP_3A_MAIN 			EQU 19
  0014                 184     DP_3A_TAIL  			EQU 20
  0015                 185     DP_3A_MULTI  			EQU 21
  0016                 186     SUPERMICRO_3P5A_MAIN 	EQU 22
  0017                 187     SUPERMICRO_3P5A_TAIL 	EQU 23   
  0018                 188     SUPERMICRO_3P5A_MULTI 	EQU 24   
  0019                 189     TURNIGY_PLUSH_6A_MAIN 	EQU 25
  001A                 190     TURNIGY_PLUSH_6A_TAIL 	EQU 26   
  001B                 191     TURNIGY_PLUSH_6A_MULTI 	EQU 27   
  001C                 192     TURNIGY_PLUSH_10A_MAIN 	EQU 28
  001D                 193     TURNIGY_PLUSH_10A_TAIL 	EQU 29   
  001E                 194     TURNIGY_PLUSH_10A_MULTI 	EQU 30   
  001F                 195     TURNIGY_PLUSH_12A_MAIN 	EQU 31
  0020                 196     TURNIGY_PLUSH_12A_TAIL 	EQU 32   
  0021                 197     TURNIGY_PLUSH_12A_MULTI 	EQU 33   
  0022                 198     TURNIGY_PLUSH_18A_MAIN 	EQU 34
  0023                 199     TURNIGY_PLUSH_18A_TAIL 	EQU 35   
  0024                 200     TURNIGY_PLUSH_18A_MULTI 	EQU 36   
  0025                 201     TURNIGY_PLUSH_25A_MAIN 	EQU 37
  0026                 202     TURNIGY_PLUSH_25A_TAIL 	EQU 38   
  0027                 203     TURNIGY_PLUSH_25A_MULTI 	EQU 39   
  0028                 204     TURNIGY_PLUSH_30A_MAIN 	EQU 40
  0029                 205     TURNIGY_PLUSH_30A_TAIL 	EQU 41   
  002A                 206     TURNIGY_PLUSH_30A_MULTI 	EQU 42   
  002B                 207     TURNIGY_AE_20A_MAIN 	EQU 43
  002C                 208     TURNIGY_AE_20A_TAIL 	EQU 44   
  002D                 209     TURNIGY_AE_20A_MULTI 	EQU 45   
  002E                 210     TURNIGY_AE_25A_MAIN 	EQU 46
  002F                 211     TURNIGY_AE_25A_TAIL 	EQU 47   
  0030                 212     TURNIGY_AE_25A_MULTI 	EQU 48   
  0031                 213     TURNIGY_AE_30A_MAIN 	EQU 49
  0032                 214     TURNIGY_AE_30A_TAIL 	EQU 50   
  0033                 215     TURNIGY_AE_30A_MULTI 	EQU 51   
  0034                 216     SKYWALKER_20A_MAIN 		EQU 52
  0035                 217     SKYWALKER_20A_TAIL 		EQU 53   
  0036                 218     SKYWALKER_20A_MULTI 	EQU 54   
  0037                 219     SKYWALKER_40A_MAIN 		EQU 55
  0038                 220     SKYWALKER_40A_TAIL 		EQU 56   
  0039                 221     SKYWALKER_40A_MULTI 	EQU 57   
  003A                 222     HIMODEL_COOL_22A_MAIN 	EQU 58
  003B                 223     HIMODEL_COOL_22A_TAIL 	EQU 59   
  003C                 224     HIMODEL_COOL_22A_MULTI 	EQU 60   
                       225     
                       226     ;**** **** **** **** ****
                       227     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                       228     ;BESC EQU XP_3A_Main  
                       229     ;BESC EQU XP_3A_Tail
                       230     ;BESC EQU XP_3A_Multi
                       231     ;BESC EQU XP_7A_Main 
                       232     ;BESC EQU XP_7A_Tail
                       233     ;BESC EQU XP_7A_Multi 
                       234     ;BESC EQU XP_7A_Fast_Main
                       235     ;BESC EQU XP_7A_Fast_Tail
                       236     ;BESC EQU XP_7A_Fast_Multi 
                       237     ;BESC EQU XP_12A_Main 
                       238     ;BESC EQU XP_12A_Tail 
                       239     ;BESC EQU XP_12A_Multi
                       240     ;BESC EQU XP_18A_Main 
                       241     ;BESC EQU XP_18A_Tail 
                       242     ;BESC EQU XP_18A_Multi
                       243     ;BESC EQU XP_25A_Main 
                       244     ;BESC EQU XP_25A_Tail 
                       245     ;BESC EQU XP_25A_Multi
                       246     ;BESC EQU DP_3A_Main 						
                       247     ;BESC EQU DP_3A_Tail
                       248     ;BESC EQU DP_3A_Multi
                       249     ;BESC EQU Supermicro_3p5A_Main
                       250     ;BESC EQU Supermicro_3p5A_Tail 
                       251     ;BESC EQU Supermicro_3p5A_Multi
                       252     ;BESC EQU Turnigy_Plush_6A_Main 
                       253     ;BESC EQU Turnigy_Plush_6A_Tail 
                       254     ;BESC EQU Turnigy_Plush_6A_Multi
                       255     ;BESC EQU Turnigy_Plush_10A_Main 
                       256     ;BESC EQU Turnigy_Plush_10A_Tail 
                       257     ;BESC EQU Turnigy_Plush_10A_Multi
                       258     ;BESC EQU Turnigy_Plush_12A_Main 
                       259     ;BESC EQU Turnigy_Plush_12A_Tail 
                       260     ;BESC EQU Turnigy_Plush_12A_Multi
                       261     ;BESC EQU Turnigy_Plush_18A_Main 
                       262     ;BESC EQU Turnigy_Plush_18A_Tail 
                       263     ;BESC EQU Turnigy_Plush_18A_Multi
                       264     ;BESC EQU Turnigy_Plush_25A_Main 
                       265     ;BESC EQU Turnigy_Plush_25A_Tail 
                       266     ;BESC EQU Turnigy_Plush_25A_Multi
                       267     ;BESC EQU Turnigy_Plush_30A_Main 
                       268     ;BESC EQU Turnigy_Plush_30A_Tail 
                       269     ;BESC EQU Turnigy_Plush_30A_Multi
                       270     ;BESC EQU Turnigy_AE_20A_Main 
                       271     ;BESC EQU Turnigy_AE_20A_Tail 
                       272     ;BESC EQU Turnigy_AE_20A_Multi
                       273     ;BESC EQU Turnigy_AE_25A_Main 
                       274     ;BESC EQU Turnigy_AE_25A_Tail 
                       275     ;BESC EQU Turnigy_AE_25A_Multi
                       276     ;BESC EQU Turnigy_AE_30A_Main 
                       277     ;BESC EQU Turnigy_AE_30A_Tail 
                       278     ;BESC EQU Turnigy_AE_30A_Multi
                       279     ;BESC EQU Skywalker_20A_Main 
                       280     ;BESC EQU Skywalker_20A_Tail 
                       281     ;BESC EQU Skywalker_20A_Multi
                       282     ;BESC EQU Skywalker_40A_Main 
                       283     ;BESC EQU Skywalker_40A_Tail 
                       284     ;BESC EQU Skywalker_40A_Multi
                       285     ;BESC EQU HiModel_Cool_22A_Main
                       286     ;BESC EQU HiModel_Cool_22A_Tail
                       287     ;BESC EQU HiModel_Cool_22A_Multi
                       288     
                       289     ;**** **** **** **** ****
                       290     ; ESC selection statements
                       291     IF BESC == XP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       295     
                       296     IF BESC == XP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       300     
                       301     IF BESC == XP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_3A.INC)			; Select XP 3A pinout
                               ENDIF
                       305     
                       306     IF BESC == XP_7A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       310     
                       311     IF BESC == XP_7A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       315     
                       316     IF BESC == XP_7A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A.INC)			; Select XP 7A pinout
                               ENDIF
                       320     
                       321     IF BESC == XP_7A_FAST_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       325     
                       326     IF BESC == XP_7A_FAST_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       330     
                       331     IF BESC == XP_7A_FAST_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_7A_FAST.INC)		; Select XP 7A Fast pinout
                               ENDIF
                       335     
                       336     IF BESC == XP_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       340     
                       341     IF BESC == XP_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       345     
                       346     IF BESC == XP_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_12A.INC)			; Select XP 12A pinout
                               ENDIF
                       350     
                       351     IF BESC == XP_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       355     
                       356     IF BESC == XP_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       360     
                       361     IF BESC == XP_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_18A.INC)			; Select XP 18A pinout
                               ENDIF
                       365     
                       366     IF BESC == XP_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       370     
                       371     IF BESC == XP_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       375     
                       376     IF BESC == XP_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (XP_25A.INC)			; Select XP 25A pinout
                               ENDIF
                       380     
                       381     IF BESC == DP_3A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       385     
                       386     IF BESC == DP_3A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       390     
                       391     IF BESC == DP_3A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (DP_3A.INC)			; Select DP 3A pinout
                               ENDIF
                       395     
                       396     IF BESC == SUPERMICRO_3P5A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       400     
                       401     IF BESC == SUPERMICRO_3P5A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       405     
                       406     IF BESC == SUPERMICRO_3P5A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SUPERMICRO_3P5A.INC)	; Select Supermicro 3.5A pinout
                               ENDIF
                       410     
                       411     IF BESC == TURNIGY_PLUSH_6A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       415     
                       416     IF BESC == TURNIGY_PLUSH_6A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       420     
                       421     IF BESC == TURNIGY_PLUSH_6A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_6A.INC)	; Select Turnigy Plush 6A pinout
                               ENDIF
                       425     
                       426     IF BESC == TURNIGY_PLUSH_10A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       430     
                       431     IF BESC == TURNIGY_PLUSH_10A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       435     
                       436     IF BESC == TURNIGY_PLUSH_10A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_10A.INC)	; Select Turnigy Plush 10A pinout
                               ENDIF
                       440     
                       441     IF BESC == TURNIGY_PLUSH_12A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       445     
                       446     IF BESC == TURNIGY_PLUSH_12A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       450     
                       451     IF BESC == TURNIGY_PLUSH_12A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_12A.INC)	; Select Turnigy Plush 12A pinout
                               ENDIF
                       455     
                       456     IF BESC == TURNIGY_PLUSH_18A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       460     
                       461     IF BESC == TURNIGY_PLUSH_18A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       465     
                       466     IF BESC == TURNIGY_PLUSH_18A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_18A.INC)	; Select Turnigy Plush 18A pinout
                               ENDIF
                       470     
                       471     IF BESC == TURNIGY_PLUSH_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       475     
                       476     IF BESC == TURNIGY_PLUSH_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       480     
                       481     IF BESC == TURNIGY_PLUSH_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_25A.INC)	; Select Turnigy Plush 25A pinout
                               ENDIF
                       485     
                       486     IF BESC == TURNIGY_PLUSH_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       490     
                       491     IF BESC == TURNIGY_PLUSH_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       495     
                       496     IF BESC == TURNIGY_PLUSH_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_PLUSH_30A.INC)	; Select Turnigy Plush 30A pinout
                               ENDIF
                       500     
                       501     IF BESC == TURNIGY_AE_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                       505     
                       506     IF BESC == TURNIGY_AE_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                       510     
                       511     IF BESC == TURNIGY_AE_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_20A.INC)		; Select Turnigy AE-20A pinout
                               ENDIF
                       515     
                       516     IF BESC == TURNIGY_AE_25A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                       520     
                       521     IF BESC == TURNIGY_AE_25A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                       525     
                       526     IF BESC == TURNIGY_AE_25A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_25A.INC)		; Select Turnigy AE-25A pinout
                               ENDIF
                       530     
                       531     IF BESC == TURNIGY_AE_30A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                       535     
                       536     IF BESC == TURNIGY_AE_30A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                       540     
                       541     IF BESC == TURNIGY_AE_30A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (TURNIGY_AE_30A.INC)		; Select Turnigy AE-30A pinout
                               ENDIF
                       545     
                       546     IF BESC == SKYWALKER_20A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       550     
                       551     IF BESC == SKYWALKER_20A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       555     
                       556     IF BESC == SKYWALKER_20A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (SKYWALKER_20A.INC)		; Select Skywalker 20A pinout
                               ENDIF
                       560     
                       561     IF BESC == SKYWALKER_40A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       565     
                       566     IF BESC == SKYWALKER_40A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                               ENDIF
                       570     
                       571     IF BESC == SKYWALKER_40A_MULTI
  0002                 572     MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                       573     $INCLUDE (SKYWALKER_40A.INC)		; Select Skywalker 40A pinout
                      1053     ENDIF
                      1054     
                      1055     IF BESC == HIMODEL_COOL_22A_MAIN
                               MODE 	EQU 	0				; Choose mode. Set to 0 for main motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1059     
                      1060     IF BESC == HIMODEL_COOL_22A_TAIL
                               MODE 	EQU 	1				; Choose mode. Set to 1 for tail motor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1064     
                      1065     IF BESC == HIMODEL_COOL_22A_MULTI
                               MODE 	EQU 	2				; Choose mode. Set to 2 for multirotor
                               $INCLUDE (HIMODEL_COOL_22A.INC)	; Select HiModel Cool 22A pinout
                               ENDIF
                      1069     
                      1070     
                      1071     ;**** **** **** **** ****
                      1072     ; TX programming defaults
                      1073     ;
                      1074     ; Parameter dependencies:
                      1075     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is selected
                      1076     ; - Governor setup target is only used if Setup governor mode is selected
                      1077     ; - Startup rpm and startup accel is only used if stepped startup method is selected
                      1078     ; - Damping force is only used if DampedLight or Damped is selected
                      1079     ;
                      1080     ; Main
  0007                1081     DEFAULT_PGM_MAIN_P_GAIN 			EQU 7 ; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007                1082     DEFAULT_PGM_MAIN_I_GAIN 			EQU 7 ; 1=0.13		2=0.17		3=0.25		4=0.38 		5=0.50 	6=0.75 	7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001                1083     DEFAULT_PGM_MAIN_GOVERNOR_MODE 	EQU 1 ; 1=Tx 		2=Arm 		3=Setup		4=Off
  0001                1084     DEFAULT_PGM_MAIN_GOVERNOR_RANGE 	EQU 1 ; 1=High		2=Low
  0003                1085     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	EQU 3 ; 1=3.0V/c	2=3.1V/c		3=3.2V/c		4=3.3V/c		5=3.4V/c		
  0003                1086     DEFAULT_PGM_MAIN_STARTUP_PWR 		EQU 3 ; 1=0.50 	2=0.75 		3=1.00 		4=1.25 		5=1.50
  0003                1087     DEFAULT_PGM_MAIN_STARTUP_RPM		EQU 3 ; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0001                1088     DEFAULT_PGM_MAIN_STARTUP_ACCEL	EQU 1 ; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0001                1089     DEFAULT_PGM_MAIN_STARTUP_METHOD	EQU 1 ; 1=Stepped	2=Direct
  0003                1090     DEFAULT_PGM_MAIN_COMM_TIMING		EQU 3 ; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                1091     DEFAULT_PGM_MAIN_THROTTLE_RATE	EQU 13; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0001                1092     DEFAULT_PGM_MAIN_DAMPING_FORCE	EQU 1 ; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High
  0002                1093     DEFAULT_PGM_MAIN_PWM_FREQ 		EQU 2 ; 1=High 	2=Low		3=DampedLight
  0001                1094     DEFAULT_PGM_MAIN_VOLT_COMP 		EQU 1 ; 1=Disabled	2=Enabled
  0001                1095     DEFAULT_PGM_MAIN_DIRECTION_REV	EQU 1 ; 1=Normal 	2=Reversed
  0001                1096     DEFAULT_PGM_MAIN_RCP_PWM_POL 		EQU 1 ; 1=Positive 	2=Negative
  00B4                1097     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	EQU 180	; Target for governor in setup mode. Corresponds to 70% throttle
  0000                1098     DEFAULT_PGM_MAIN_REARM_START		EQU 0 ; 1=Enabled 	0=Disabled
  0078                1099     DEFAULT_PGM_MAIN_BEEP_STRENGTH	EQU 120	; Beep strength
  00C8                1100     DEFAULT_PGM_MAIN_BEACON_STRENGTH	EQU 200	; Beacon strength
  0001                1101     DEFAULT_PGM_MAIN_BEACON_DELAY		EQU 1 ; 1=30s		2=1m			3=2m			4=3m			5=Infinite
                      1102     ; Tail
  0003                1103     DEFAULT_PGM_TAIL_GAIN 			EQU 3 ; 1=0.75 	2=0.88 		3=1.00 		4=1.12 		5=1.25
  0004                1104     DEFAULT_PGM_TAIL_IDLE_SPEED 		EQU 4 ; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  0003                1105     DEFAULT_PGM_TAIL_STARTUP_PWR 		EQU 3 ; 1=0.50 	2=0.75 		3=1.00 		4=1.25 		5=1.50
  0003                1106     DEFAULT_PGM_TAIL_STARTUP_RPM		EQU 3 ; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                1107     DEFAULT_PGM_TAIL_STARTUP_ACCEL	EQU 5 ; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0001                1108     DEFAULT_PGM_TAIL_STARTUP_METHOD	EQU 1 ; 1=Stepped	2=Direct
  0003                1109     DEFAULT_PGM_TAIL_COMM_TIMING		EQU 3 ; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                1110     DEFAULT_PGM_TAIL_THROTTLE_RATE	EQU 13; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0005                1111     DEFAULT_PGM_TAIL_DAMPING_FORCE	EQU 5 ; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High
                      1112     IF DAMPED_MODE_ENABLE == 1
                               DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 4 ; 1=High 	2=Low 		3=DampedLight  4=Damped 	
                               ELSE
  0003                1115     DEFAULT_PGM_TAIL_PWM_FREQ	 	EQU 3 ; 1=High 	2=Low		3=DampedLight
                      1116     ENDIF
  0001                1117     DEFAULT_PGM_TAIL_VOLT_COMP 		EQU 1 ; 1=Disabled	2=Enabled
  0001                1118     DEFAULT_PGM_TAIL_DIRECTION_REV	EQU 1 ; 1=Normal 	2=Reversed
  0001                1119     DEFAULT_PGM_TAIL_RCP_PWM_POL 		EQU 1 ; 1=Positive 	2=Negative
  00FA                1120     DEFAULT_PGM_TAIL_BEEP_STRENGTH	EQU 250	; Beep strength
  00FA                1121     DEFAULT_PGM_TAIL_BEACON_STRENGTH	EQU 250	; Beacon strength
  0001                1122     DEFAULT_PGM_TAIL_BEACON_DELAY		EQU 1 ; 1=30s		2=1m			3=2m			4=3m			5=Infinite
                      1123     ; Multi
  0003                1124     DEFAULT_PGM_MULTI_GAIN 			EQU 3 ; 1=0.75 	2=0.88 		3=1.00 		4=1.12 		5=1.25
  0003                1125     DEFAULT_PGM_MULTI_LOW_VOLTAGE_LIM	EQU 3 ; 1=3.0V/c	2=3.1V/c		3=3.2V/c		4=3.3V/c		5=3.4V/c		
  0003                1126     DEFAULT_PGM_MULTI_STARTUP_PWR 	EQU 3 ; 1=0.50 	2=0.75 		3=1.00 		4=1.25 		5=1.50
  0001                1127     DEFAULT_PGM_MULTI_STARTUP_RPM		EQU 1 ; 1=0.67		2=0.8 		3=1.00 		4=1.25 		5=1.5
  0005                1128     DEFAULT_PGM_MULTI_STARTUP_ACCEL	EQU 5 ; 1=0.4 		2=0.7 		3=1.0 		4=1.5 		5=2.3
  0002                1129     DEFAULT_PGM_MULTI_STARTUP_METHOD	EQU 2 ; 1=Stepped	2=Direct
  0003                1130     DEFAULT_PGM_MULTI_COMM_TIMING		EQU 3 ; 1=Low 		2=MediumLow 	3=Medium 		4=MediumHigh 	5=High
  000D                1131     DEFAULT_PGM_MULTI_THROTTLE_RATE	EQU 13; 1=2		2=3			3=4			4=6 			5=8	 	6=12 	7=16	  8=24  9=32  10=48  11=64  12=128 13=255
  0002                1132     DEFAULT_PGM_MULTI_DAMPING_FORCE	EQU 2 ; 1=VeryLow 	2=Low 		3=MediumLow 	4=MediumHigh 	5=High
                      1133     IF DAMPED_MODE_ENABLE == 1
                               DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 ; 1=High 	2=Low 		3=DampedLight  4=Damped 	
                               ELSE
  0001                1136     DEFAULT_PGM_MULTI_PWM_FREQ	 	EQU 1 ; 1=High 	2=Low		3=DampedLight
                      1137     ENDIF
  0001                1138     DEFAULT_PGM_MULTI_VOLT_COMP 		EQU 1 ; 1=Disabled	2=Enabled
  0001                1139     DEFAULT_PGM_MULTI_DIRECTION_REV	EQU 1 ; 1=Normal 	2=Reversed
  0001                1140     DEFAULT_PGM_MULTI_RCP_PWM_POL 	EQU 1 ; 1=Positive 	2=Negative
  0028                1141     DEFAULT_PGM_MULTI_BEEP_STRENGTH	EQU 40	; Beep strength
  0050                1142     DEFAULT_PGM_MULTI_BEACON_STRENGTH	EQU 80	; Beacon strength
  0001                1143     DEFAULT_PGM_MULTI_BEACON_DELAY	EQU 1 ; 1=30s		2=1m			3=2m			4=3m			5=Infinite
                      1144     ; Common
  0001                1145     DEFAULT_PGM_ENABLE_TX_PROGRAM 	EQU 1 	; 1=Enabled 	0=Disabled
  0025                1146     DEFAULT_PGM_PPM_MIN_THROTTLE		EQU 37	; 4*37+1000=1148
  00D0                1147     DEFAULT_PGM_PPM_MAX_THROTTLE		EQU 208	; 4*208+1000=1832
                      1148     
                      1149     ;**** **** **** **** ****
                      1150     ; Constant definitions for main
                      1151     IF MODE == 0
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               
                               RCP_TIMEOUT		EQU	64	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	32	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	80 	; PWM used when in start stepper phase
                               PWM_AQUISITION		EQU 	80 	; PWM used when in start aquisition phase
                               
                               COMM_TIME_RED		EQU 	5	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	5	; Minimum time (in us) for commutation wait
                               
                               AQUISITION_ROTATIONS	EQU 	2	; Number of rotations to do in the aquisition phase
                               NONDAMPED_RUN_ROTATIONS	EQU 	10	; Number of rotations to do in the nondamped run phase
                               
                               TEMP_CHECK_RATE		EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      1176     ; Constant definitions for tail
                      1177     IF MODE == 1
                               
                               GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                               
                               RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
                               RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
                               RCP_MIN			EQU 	0	; This is minimum RC pulse length
                               RCP_MAX			EQU 	255	; This is maximum RC pulse length
                               RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
                               RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
                               RCP_STOP_LIMIT		EQU 	130	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                               
                               PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
                               PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
                               PWM_AQUISITION		EQU 	80 	; PWM used when in start aquisition phase
                               
                               COMM_TIME_RED		EQU 	5	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
                               COMM_TIME_MIN		EQU 	5	; Minimum time (in us) for commutation wait
                               
                               AQUISITION_ROTATIONS	EQU 	2	; Number of rotations to do in the aquisition phase
                               NONDAMPED_RUN_ROTATIONS	EQU 	10	; Number of rotations to do in the nondamped run phase
                               
                               TEMP_CHECK_RATE		EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                               
                               ENDIF
                      1202     ; Constant definitions for multi
                      1203     IF MODE == 2
                      1204     
  0001                1205     GOV_SPOOLRATE		EQU	1	; Number of steps for governor requested pwm per 32ms
                      1206     
  0018                1207     RCP_TIMEOUT		EQU 	24	; Number of timer2L overflows (about 128us) before considering rc pulse lost
  0006                1208     RCP_SKIP_RATE		EQU 	6	; Number of timer2L overflows (about 128us) before reenabling rc pulse detection
  0000                1209     RCP_MIN			EQU 	0	; This is minimum RC pulse length
  00FF                1210     RCP_MAX			EQU 	255	; This is maximum RC pulse length
  0002                1211     RCP_VALIDATE		EQU 	2	; Require minimum this pulse length to validate RC pulse
  0001                1212     RCP_STOP			EQU 	1	; Stop motor at or below this pulse length
  00FA                1213     RCP_STOP_LIMIT		EQU 	250	; Stop motor if this many timer2H overflows (~32ms) are below stop limit
                      1214     
  0032                1215     PWM_SETTLE		EQU 	50 	; PWM used when in start settling phase (also max power during direct start)
  0078                1216     PWM_STEPPER		EQU 	120 	; PWM used when in start stepper phase
  0050                1217     PWM_AQUISITION		EQU 	80 	; PWM used when in start aquisition phase
                      1218     
  0005                1219     COMM_TIME_RED		EQU 	5	; Fixed reduction (in us) for commutation wait (to account for fixed delays)
  0005                1220     COMM_TIME_MIN		EQU 	5	; Minimum time (in us) for commutation wait
                      1221     
  0002                1222     AQUISITION_ROTATIONS	EQU 	2	; Number of rotations to do in the aquisition phase
  000A                1223     NONDAMPED_RUN_ROTATIONS	EQU 	10	; Number of rotations to do in the nondamped run phase
                      1224     
  0008                1225     TEMP_CHECK_RATE		EQU 	8	; Number of adc conversions for each check of temperature (the other conversions are used for voltage)
                      1226     
                      1227     ENDIF
                      1228     
                      1229     ;**** **** **** **** ****
                      1230     ; Temporary register definitions
  REG                 1231     TEMP1		EQU	R0
  REG                 1232     TEMP2		EQU	R1
  REG                 1233     TEMP3		EQU	R2
  REG                 1234     TEMP4		EQU	R3
  REG                 1235     TEMP5		EQU	R4
  REG                 1236     TEMP6		EQU	R5
  REG                 1237     TEMP7		EQU	R6
  REG                 1238     TEMP8		EQU	R7
                      1239     
                      1240     ;**** **** **** **** ****
                      1241     ; Register definitions
------                1242     DSEG AT 20H					; Variables segment 
                      1243     
0020                  1244     BIT_ACCESS: 		DS	1		; Variable at bit accessible address (for non interrupt routines)
0021                  1245     BIT_ACCESS_INT: 	DS	1		; Variable at bit accessible address (for interrupts)
                      1246     
0022                  1247     REQUESTED_PWM: 		DS	1		; Requested pwm (from RC pulse value)
0023                  1248     GOVERNOR_REQ_PWM: 	DS	1		; Governor requested pwm (sets governor target)
0024                  1249     CURRENT_PWM: 		DS	1		; Current pwm
0025                  1250     CURRENT_PWM_COMP: 	DS	1		; Current pwm that is voltage compensated
0026                  1251     CURRENT_PWM_LIMITED: DS	1		; Current pwm that is limited (applied to the motor output)
0027                  1252     RCP_PREV_EDGE_L: 	DS	1		; RC pulse previous edge timer3 timestamp (lo byte)
0028                  1253     RCP_PREV_EDGE_H: 	DS	1		; RC pulse previous edge timer3 timestamp (hi byte)
0029                  1254     RCP_TIMEOUT_CNT: 	DS	1		; RC pulse timeout counter (decrementing) 
002A                  1255     RCP_SKIP_CNT: 		DS	1		; RC pulse skip counter (decrementing) 
002B                  1256     RCP_EDGE_CNT: 		DS	1		; RC pulse edge counter 
                      1257     
002C                  1258     FLAGS0: 			DS	1    	; State flags. Reset upon init_start
  0000                1259     T3_PENDING		EQU 	0		; Timer3 pending flag
  0001                1260     RCP_MEAS_PWM_FREQ	EQU	1		; Measure RC pulse pwm frequency
  0002                1261     PWM_ON			EQU	2		; Set in on part of pwm cycle
                      1262     ;				EQU 	3
                      1263     ;				EQU 	4
                      1264     ;				EQU 	5
                      1265     ;				EQU 	6
                      1266     ;				EQU 	7
                      1267     
002D                  1268     FLAGS1: 				DS	1    	; State flags. Reset upon init_start 
  0000                1269     MOTOR_SPINNING			EQU	0		; Set when in motor is spinning
  0001                1270     SETTLE_PHASE			EQU 	1		; Set when in motor start settling phase
  0002                1271     STEPPER_PHASE			EQU	2		; Set when in motor start stepper motor phase
  0003                1272     AQUISITION_PHASE		EQU	3		; Set when in motor start aquisition phase
  0004                1273     INITIAL_RUN_PHASE		EQU	4		; Set when in initial run phase, before synchronized run is achieved
  0005                1274     DIRECT_STARTUP_PHASE	EQU 	5		; Set when in direct startup phase
                      1275     ;					EQU 	6
                      1276     ;					EQU 	7
                      1277     
002E                  1278     FLAGS2: 				DS	1		; State flags. NOT reset upon init_start
  0000                1279     RCP_UPDATED			EQU 	0		; New RC pulse length value available
  0001                1280     RCP_EDGE_NO			EQU 	1		; RC pulse edge no. 0=rising, 1=falling
  0002                1281     PGM_PWMOFF_DAMPED		EQU	2		; Programmed pwm off damped mode. Set when fully damped or damped light mode is selected
  0003                1282     PGM_PWMOFF_DAMPED_FULL	EQU	3		; Programmed pwm off fully damped mode. Set when all pfets shall be on in pwm_off period
  0004                1283     PGM_PWMOFF_DAMPED_LIGHT	EQU	4		; Programmed pwm off damped light mode. Set when only 2 pfets shall be on in pwm_off period
  0005                1284     PGM_PWM_HIGH_FREQ		EQU	5		; Progremmed pwm high frequency
  0006                1285     CURR_PWMOFF_DAMPED		EQU	6		; Currently running pwm off cycle is damped
  0007                1286     CURR_PWMOFF_COMP_ABLE	EQU	7		; Currently running pwm off cycle is usable for comparator
                      1287     
002F                  1288     FLAGS3: 				DS	1		; State flags. NOT reset upon init_start
  0000                1289     RCP_PWM_FREQ_1KHZ		EQU 	0		; RC pulse pwm frequency is 1kHz
  0001                1290     RCP_PWM_FREQ_2KHZ		EQU 	1		; RC pulse pwm frequency is 2kHz
  0002                1291     RCP_PWM_FREQ_4KHZ		EQU 	2		; RC pulse pwm frequency is 4kHz
  0003                1292     RCP_PWM_FREQ_8KHZ		EQU 	3		; RC pulse pwm frequency is 8kHz
  0004                1293     PGM_DIR_REV			EQU 	4		; Programmed direction. 0=normal, 1=reversed
  0005                1294     PGM_RCP_PWM_POL		EQU	5		; Programmed RC pulse pwm polarity. 0=positive, 1=negative
  0006                1295     FULL_THROTTLE_RANGE		EQU 	6		; When set full throttle range is used (1000-2000us) and stored calibration values are ignored
                      1296     ;					EQU 	7
                      1297     
                      1298     ;**** **** **** **** ****
                      1299     ; RAM definitions
------                1300     DSEG AT 30H						; Ram data segment, direct addressing
                      1301     
0030                  1302     INITIAL_ARM: 			DS	1		; Variable that is set during the first arm sequence after power on
                      1303     
0031                  1304     POWER_ON_WAIT_CNT_L:  	DS	1		; Power on wait counter (lo byte)
0032                  1305     POWER_ON_WAIT_CNT_H:  	DS	1		; Power on wait counter (hi byte)
                      1306     
0033                  1307     STEPPER_STEP_BEG_L: 		DS	1		; Stepper phase step time at the beginning (lo byte)
0034                  1308     STEPPER_STEP_BEG_H: 		DS	1		; Stepper phase step time at the beginning (hi byte)
0035                  1309     STEPPER_STEP_END_L: 		DS	1		; Stepper phase step time at the end (lo byte)
0036                  1310     STEPPER_STEP_END_H: 		DS	1		; Stepper phase step time at the end (hi byte)
0037                  1311     STARTUP_ROT_CNT: 		DS	1		; Startup phase rotations counter
0038                  1312     DIRECT_STARTUP_OK_CNT: 	DS	1		; Direct startup phase ok comparator waits counter (incrementing)
0039                  1313     DIRECT_STARTUP_FAIL_CNT: 	DS	1		; Direct startup phase failing comparator waits counter (incrementing)
                      1314     
003A                  1315     PREV_COMM_L: 			DS	1		; Previous commutation timer3 timestamp (lo byte)
003B                  1316     PREV_COMM_H: 			DS	1		; Previous commutation timer3 timestamp (hi byte)
003C                  1317     COMM_PERIOD4X_L: 		DS	1		; Timer3 counts between the last 4 commutations (lo byte)
003D                  1318     COMM_PERIOD4X_H: 		DS	1		; Timer3 counts between the last 4 commutations (hi byte)
003E                  1319     COMM_PHASE: 			DS	1		; Current commutation phase
003F                  1320     COMP_WAIT_READS:  		DS	1		; Comparator wait comparator reads
                      1321     
0040                  1322     GOV_TARGET_L: 			DS	1		; Governor target (lo byte)
0041                  1323     GOV_TARGET_H: 			DS	1		; Governor target (hi byte)
0042                  1324     GOV_INTEGRAL_L: 		DS	1		; Governor integral error (lo byte)
0043                  1325     GOV_INTEGRAL_H: 		DS	1		; Governor integral error (hi byte)
0044                  1326     GOV_INTEGRAL_X: 		DS	1		; Governor integral error (ex byte)
0045                  1327     GOV_PROPORTIONAL_L: 		DS	1		; Governor proportional error (lo byte)
0046                  1328     GOV_PROPORTIONAL_H: 		DS	1		; Governor proportional error (hi byte)
0047                  1329     GOV_PROP_PWM: 			DS	1		; Governor calculated new pwm based upon proportional error
0048                  1330     GOV_ARM_TARGET: 		DS	1		; Governor arm target value
0049                  1331     GOV_ACTIVE: 			DS	1		; Governor active (enabled when speed is above minimum)
                      1332     
004A                  1333     WT_ADVANCE_L: 			DS	1		; Timer3 counts for commutation advance timing (lo byte)
004B                  1334     WT_ADVANCE_H: 			DS	1		; Timer3 counts for commutation advance timing (hi byte)
004C                  1335     WT_ZC_SCAN_L: 			DS	1		; Timer3 counts from commutation to zero cross scan (lo byte)
004D                  1336     WT_ZC_SCAN_H: 			DS	1		; Timer3 counts from commutation to zero cross scan (hi byte)
004E                  1337     WT_COMM_L: 			DS	1		; Timer3 counts from zero cross to commutation (lo byte)
004F                  1338     WT_COMM_H: 			DS	1		; Timer3 counts from zero cross to commutation (hi byte)
0050                  1339     WT_STEPPER_STEP_L: 		DS	1		; Timer3 counts for stepper step (lo byte)
0051                  1340     WT_STEPPER_STEP_H: 		DS	1		; Timer3 counts for stepper step (hi byte)
                      1341     
0052                  1342     RCP_PREPREV_EDGE_L: 		DS	1		; RC pulse pre previous edge pca timestamp (lo byte)
0053                  1343     RCP_PREPREV_EDGE_H: 		DS	1		; RC pulse pre previous edge pca timestamp (hi byte)
0054                  1344     RCP_EDGE_L: 			DS	1		; RC pulse edge pca timestamp (lo byte)
0055                  1345     RCP_EDGE_H: 			DS	1		; RC pulse edge pca timestamp (hi byte)
0056                  1346     RCP_PREV_PERIOD_L: 		DS	1		; RC pulse previous period (lo byte)
0057                  1347     RCP_PREV_PERIOD_H: 		DS	1		; RC pulse previous period (hi byte)
0058                  1348     RCP_PERIOD_DIFF_ACCEPTED: DS	1		; RC pulse period difference acceptable
0059                  1349     NEW_RCP: 				DS	1		; New RC pulse value in pca counts
005A                  1350     PREV_RCP_PWM_FREQ: 		DS	1		; Previous RC pulse pwm frequency (used during pwm frequency measurement)
005B                  1351     CURR_RCP_PWM_FREQ: 		DS	1		; Current RC pulse pwm frequency (used during pwm frequency measurement)
005C                  1352     RCP_STOP_CNT: 			DS	1		; Counter for RC pulses below stop value 
                      1353     
005D                  1354     PWM_LIMIT: 			DS	1		; Maximum allowed pwm 
005E                  1355     PWM_LIMIT_SPOOLUP: 		DS	1		; Maximum allowed pwm during spoolup of main
005F                  1356     PWM_SPOOLUP_BEG: 		DS	1		; Pwm to begin main spoolup with
0060                  1357     PWM_MOTOR_IDLE: 		DS	1		; Motor idle speed pwm
0061                  1358     PWM_ON_CNT: 			DS	1		; Pwm on event counter (used to increase pwm off time for low pwm)
0062                  1359     PWM_OFF_CNT: 			DS	1		; Pwm off event counter (used to run some pwm cycles without damping)
                      1360     
0063                  1361     DAMPING_PERIOD: 		DS	1		; Damping on/off period
0064                  1362     DAMPING_ON: 			DS	1		; Damping on part of damping period
                      1363     
0065                  1364     LIPO_ADC_REFERENCE_L: 	DS	1		; Voltage reference adc value (lo byte)
0066                  1365     LIPO_ADC_REFERENCE_H: 	DS	1		; Voltage reference adc value (hi byte)
0067                  1366     LIPO_ADC_LIMIT_L: 		DS	1		; Low voltage limit adc value (lo byte)
0068                  1367     LIPO_ADC_LIMIT_H: 		DS	1		; Low voltage limit adc value (hi byte)
0069                  1368     VOLTAGE_COMP_FACTOR: 	DS	1		; Voltage compensation factor for pwm
006A                  1369     ADC_CONVERSION_CNT: 		DS	1		; Adc conversion counter
                      1370     
006B                  1371     PPM_THROTTLE_GAIN: 		DS	1		; Gain to be applied to RCP value for PPM input
006C                  1372     BEEP_STRENGTH: 			DS	1		; Strength of beeps
                      1373     
006D                  1374     TX_PGM_FUNC_NO: 		DS	1		; Function number when doing programming by tx
006E                  1375     TX_PGM_PARAVAL_NO: 		DS	1		; Parameter value number when doing programming by tx
006F                  1376     TX_PGM_BEEP_NO: 		DS	1		; Beep number when doing programming by tx
                      1377     
                      1378     ; Indirect addressing data segment
------                1379     ISEG AT 080H					
0080                  1380     PGM_GOV_P_GAIN: 		DS	1		; Programmed governor P gain
0081                  1381     PGM_GOV_I_GAIN: 		DS	1		; Programmed governor I gain
0082                  1382     PGM_GOV_P_GAIN_DECODED: 	DS	1		; Programmed governor decoded P gain
0083                  1383     PGM_GOV_I_GAIN_DECODED: 	DS	1		; Programmed governor decoded I gain
0084                  1384     PGM_GOV_MODE: 			DS	1		; Programmed governor mode
0085                  1385     PGM_GOV_RANGE: 			DS	1		; Programmed governor range
0086                  1386     PGM_LOW_VOLTAGE_LIM: 	DS	1		; Programmed low voltage limit
0087                  1387     PGM_MOTOR_GAIN: 		DS	1		; Programmed motor gain
0088                  1388     PGM_MOTOR_IDLE: 		DS	1		; Programmed motor idle speed
0089                  1389     PGM_STARTUP_PWR: 		DS	1		; Programmed startup power
                      1390     
008A                  1391     PGM_ENABLE_TX_PROGRAM: 	DS 	1		; Programmed enable/disable value for TX programming
008B                  1392     PGM_MAIN_REARM_START: 	DS 	1		; Programmed enable/disable re-arming main every start 
008C                  1393     PGM_GOV_SETUP_TARGET: 	DS 	1		; Programmed main governor setup target
008D                  1394     PGM_STARTUP_RPM: 		DS	1		; Programmed startup rpm
008E                  1395     PGM_STARTUP_ACCEL: 		DS	1		; Programmed startup acceleration
008F                  1396     PGM_STARTUP_METHOD: 		DS	1		; Programmed startup method
0090                  1397     PGM_COMM_TIMING: 		DS	1		; Programmed commutation timing
0091                  1398     PGM_THROTTLE_RATE: 		DS	1		; Programmed throttle rate
0092                  1399     PGM_THROTTLE_RATE_DECODED: DS	1		; Programmed throttle rate decoded
0093                  1400     PGM_DAMPING_FORCE: 		DS	1		; Programmed damping force
0094                  1401     PGM_PWM_FREQ: 			DS	1		; Programmed pwm frequency
0095                  1402     PGM_VOLT_COMP: 			DS	1		; Programmed voltage compensation
0096                  1403     PGM_DIRECTION_REV: 		DS	1		; Programmed rotation direction
0097                  1404     PGM_INPUT_POL: 			DS	1		; Programmed input pwm polarity
                      1405     
0098                  1406     PGM_PPM_MIN_THROTTLE: 	DS	1		; Programmed throttle minimum
0099                  1407     PGM_PPM_MAX_THROTTLE: 	DS	1		; Programmed throttle maximum
                      1408     
009A                  1409     PGM_BEEP_STRENGTH: 		DS	1		; Programmed beep strength
009B                  1410     PGM_BEACON_STRENGTH: 	DS	1		; Programmed beacon strength
009C                  1411     PGM_BEACON_DELAY: 		DS	1		; Programmed beacon delay
                      1412     
                      1413     ; Indirect addressing data segment
------                1414     ISEG AT 0D0H					
00D0                  1415     TAG_TEMPORARY_STORAGE: 	DS	48		; Temporary storage for tags when updating "Eeprom"
                      1416     
                      1417     
                      1418     ;**** **** **** **** ****
------                1419     CSEG AT 1A00H            ; "Eeprom" segment
  0007                1420     EEPROM_FW_MAIN_REVISION	EQU	7		; Main revision of the firmware
  0000                1421     EEPROM_FW_SUB_REVISION	EQU	0		; Sub revision of the firmware
  000D                1422     EEPROM_LAYOUT_REVISION	EQU	13		; Revision of the EEPROM layout
                      1423     
1A00    07            1424     EEP_FW_MAIN_REVISION:  DB 7 
1A01    00            1425     EEP_FW_SUB_REVISION:  DB 0 
1A02    0D            1426     EEP_LAYOUT_REVISION:  DB 13 
                      1427     
                      1428     IF MODE == 0
                               EEP_PGM_GOV_P_GAIN:		DB	DEFAULT_PGM_MAIN_P_GAIN			; EEPROM copy of programmed governor P gain
                               EEP_PGM_GOV_I_GAIN:		DB	DEFAULT_PGM_MAIN_I_GAIN			; EEPROM copy of programmed governor I gain
                               EEP_PGM_GOV_MODE:		DB	DEFAULT_PGM_MAIN_GOVERNOR_MODE	; EEPROM copy of programmed governor mode
                               
                               EEP_PGM_LOW_VOLTAGE_LIM:	DB	DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM	; EEPROM copy of programmed low voltage limit
                               _EEP_PGM_MOTOR_GAIN:	DB	0FFH							
                               _EEP_PGM_MOTOR_IDLE:	DB	0FFH							
                               EEP_PGM_STARTUP_PWR:	DB	DEFAULT_PGM_MAIN_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:		DB	DEFAULT_PGM_MAIN_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION_REV:	DB	DEFAULT_PGM_MAIN_DIRECTION_REV	; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:		DB	DEFAULT_PGM_MAIN_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:		DB	0A5H							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:		DB	05AH							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:	DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               EEP_MAIN_REARM_START:	DB	DEFAULT_PGM_MAIN_REARM_START		; EEPROM re-arming main enable
                               EEP_PGM_GOV_SETUP_TARGET:DB	DEFAULT_PGM_MAIN_GOV_SETUP_TARGET	; EEPROM main governor setup target
                               EEP_PGM_STARTUP_RPM:	DB	DEFAULT_PGM_MAIN_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:	DB	DEFAULT_PGM_MAIN_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               EEP_PGM_VOLT_COMP:		DB	DEFAULT_PGM_MAIN_VOLT_COMP		; EEPROM copy of programmed voltage compensation
                               EEP_PGM_COMM_TIMING:	DB	DEFAULT_PGM_MAIN_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:	DB	DEFAULT_PGM_MAIN_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               EEP_PGM_GOV_RANGE:		DB	DEFAULT_PGM_MAIN_GOVERNOR_RANGE	; EEPROM copy of programmed governor range
                               EEP_PGM_STARTUP_METHOD:	DB	DEFAULT_PGM_MAIN_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:	DB	DEFAULT_PGM_MAIN_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:	DB	DEFAULT_PGM_MAIN_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:	DB	DEFAULT_PGM_MAIN_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:	DB	DEFAULT_PGM_MAIN_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               ENDIF
                      1459     
                      1460     IF MODE == 1
                               _EEP_PGM_GOV_P_GAIN:	DB	0FFH							
                               _EEP_PGM_GOV_I_GAIN:	DB	0FFH							
                               _EEP_PGM_GOV_MODE:		DB 	0FFH							
                               
                               _EEP_PGM_LOW_VOLTAGE_LIM:DB	0FFH							
                               EEP_PGM_MOTOR_GAIN:		DB	DEFAULT_PGM_TAIL_GAIN			; EEPROM copy of programmed tail gain
                               EEP_PGM_MOTOR_IDLE:		DB	DEFAULT_PGM_TAIL_IDLE_SPEED		; EEPROM copy of programmed tail idle speed
                               EEP_PGM_STARTUP_PWR:	DB	DEFAULT_PGM_TAIL_STARTUP_PWR		; EEPROM copy of programmed startup power
                               EEP_PGM_PWM_FREQ:		DB	DEFAULT_PGM_TAIL_PWM_FREQ		; EEPROM copy of programmed pwm frequency
                               EEP_PGM_DIRECTION_REV:	DB	DEFAULT_PGM_TAIL_DIRECTION_REV	; EEPROM copy of programmed rotation direction
                               EEP_PGM_INPUT_POL:		DB	DEFAULT_PGM_TAIL_RCP_PWM_POL		; EEPROM copy of programmed input polarity
                               EEP_INITIALIZED_L:		DB	05AH							; EEPROM initialized signature low byte
                               EEP_INITIALIZED_H:		DB	0A5H							; EEPROM initialized signature high byte
                               EEP_ENABLE_TX_PROGRAM:	DB	DEFAULT_PGM_ENABLE_TX_PROGRAM		; EEPROM TX programming enable
                               _EEP_MAIN_REARM_START:	DB	0FFH							
                               _EEP_PGM_GOV_SETUP_TARGET:DB	0FFH							
                               EEP_PGM_STARTUP_RPM:	DB	DEFAULT_PGM_TAIL_STARTUP_RPM		; EEPROM copy of programmed startup rpm
                               EEP_PGM_STARTUP_ACCEL:	DB	DEFAULT_PGM_TAIL_STARTUP_ACCEL	; EEPROM copy of programmed startup acceleration
                               EEP_PGM_VOLT_COMP:		DB	DEFAULT_PGM_TAIL_VOLT_COMP		; EEPROM copy of programmed voltage compensation
                               EEP_PGM_COMM_TIMING:	DB	DEFAULT_PGM_TAIL_COMM_TIMING		; EEPROM copy of programmed commutation timing
                               EEP_PGM_DAMPING_FORCE:	DB	DEFAULT_PGM_TAIL_DAMPING_FORCE	; EEPROM copy of programmed damping force
                               _EEP_PGM_GOV_RANGE:		DB	0FFH	
                               EEP_PGM_STARTUP_METHOD:	DB	DEFAULT_PGM_TAIL_STARTUP_METHOD	; EEPROM copy of programmed startup method
                               EEP_PGM_PPM_MIN_THROTTLE:DB	DEFAULT_PGM_PPM_MIN_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1148)
                               EEP_PGM_PPM_MAX_THROTTLE:DB	DEFAULT_PGM_PPM_MAX_THROTTLE		; EEPROM copy of programmed minimum throttle (final value is 4x+1000=1832)
                               EEP_PGM_BEEP_STRENGTH:	DB	DEFAULT_PGM_TAIL_BEEP_STRENGTH	; EEPROM copy of programmed beep strength
                               EEP_PGM_BEACON_STRENGTH:	DB	DEFAULT_PGM_TAIL_BEACON_STRENGTH	; EEPROM copy of programmed beacon strength
                               EEP_PGM_BEACON_DELAY:	DB	DEFAULT_PGM_TAIL_BEACON_DELAY		; EEPROM copy of programmed beacon delay
                               EEP_PGM_THROTTLE_RATE:	DB	DEFAULT_PGM_TAIL_THROTTLE_RATE	; EEPROM copy of programmed throttle rate
                               ENDIF
                      1491     
                      1492     IF MODE == 2
1A03    FF            1493     _EEP_PGM_GOV_P_GAIN: 	DB	0FFH							
1A04    FF            1494     _EEP_PGM_GOV_I_GAIN: 	DB	0FFH							
1A05    FF            1495     _EEP_PGM_GOV_MODE: 		DB	0FFH							
                      1496     
1A06    03            1497     EEP_PGM_LOW_VOLTAGE_LIM:  DB 3 
1A07    03            1498     EEP_PGM_MOTOR_GAIN:  DB 3 
1A08    FF            1499     _EEP_PGM_MOTOR_IDLE: 	DB	0FFH							; EEPROM copy of programmed tail idle speed
1A09    03            1500     EEP_PGM_STARTUP_PWR:  DB 3 
1A0A    01            1501     EEP_PGM_PWM_FREQ:  DB 1 
1A0B    01            1502     EEP_PGM_DIRECTION_REV:  DB 1 
1A0C    01            1503     EEP_PGM_INPUT_POL:  DB 1 
1A0D    55            1504     EEP_INITIALIZED_L: 		DB	055H							; EEPROM initialized signature low byte
1A0E    AA            1505     EEP_INITIALIZED_H: 		DB	0AAH							; EEPROM initialized signature high byte
1A0F    01            1506     EEP_ENABLE_TX_PROGRAM:  DB 1 
1A10    FF            1507     _EEP_MAIN_REARM_START: 	DB	0FFH							
1A11    FF            1508     _EEP_PGM_GOV_SETUP_TARGET: DB	0FFH							
1A12    01            1509     EEP_PGM_STARTUP_RPM:  DB 1 
1A13    05            1510     EEP_PGM_STARTUP_ACCEL:  DB 5 
1A14    01            1511     EEP_PGM_VOLT_COMP:  DB 1 
1A15    03            1512     EEP_PGM_COMM_TIMING:  DB 3 
1A16    02            1513     EEP_PGM_DAMPING_FORCE:  DB 2 
1A17    FF            1514     _EEP_PGM_GOV_RANGE: 		DB	0FFH	
1A18    02            1515     EEP_PGM_STARTUP_METHOD:  DB 2 
1A19    25            1516     EEP_PGM_PPM_MIN_THROTTLE:  DB 37 
1A1A    D0            1517     EEP_PGM_PPM_MAX_THROTTLE:  DB 208 
1A1B    28            1518     EEP_PGM_BEEP_STRENGTH:  DB 40 
1A1C    50            1519     EEP_PGM_BEACON_STRENGTH:  DB 80 
1A1D    01            1520     EEP_PGM_BEACON_DELAY:  DB 1 
1A1E    0D            1521     EEP_PGM_THROTTLE_RATE:  DB 13 
                      1522     ENDIF
                      1523     
                      1524     
1A1F    FF            1525     EEP_DUMMY: 			DB	0FFH							; EEPROM address for safety reason
                      1526     
------                1527     CSEG AT 1A50H
1A50    23424C48      1528     EEP_ESC_MCU: 			DB	"#BLHELI#F330#   "				; Project and MCU tag (16 Bytes)
1A54    454C4923
1A58    46333330
1A5C    23202020
                      1529     
------                1530     CSEG AT 1A60H
1A60    20202020      1531     EEP_NAME: 				DB	"                "				; Name tag (16 Bytes)
1A64    20202020
1A68    20202020
1A6C    20202020
                      1532     
                      1533     ;**** **** **** **** ****
                      1534     	INTERRUPT_TABLE_DEFINITION		; SiLabs interrupts
------                1534+1   CSEG AT 0  ; CODE SEGMENT START
0000    0211A6        1534+1   JMP RESET 
------                1534+1   CSEG AT 0BH  ; TIMER0 INTERRUPT	
000B    02009A        1534+1   JMP T0_INT 
------                1534+1   CSEG AT 2BH  ; TIMER2 INTERRUPT	
002B    020394        1534+1   JMP T2_INT 
------                1534+1   CSEG AT 5BH  ; PCA INTERRUPT	
005B    0204EE        1534+1   JMP PCA_INT 
------                1534+1   CSEG AT 73H  ; TIMER3 INTERRUPT	
0073    0204E4        1534+1   JMP T3_INT 
------                1535     CSEG AT 80H			; Code segment after interrupt vectors 
                      1536     
                      1537     ;**** **** **** **** ****
                      1538     
                      1539     ; Table definitions
0080    02030406      1540     GOV_GAIN_TABLE:    		DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 60H, 80H
0084    080C1018
0088    20304060
008C    80
008D    02030406      1541     THROTTLE_RATE_TABLE:   	DB 	02H, 03H, 04H, 06H, 08H, 0CH, 10H, 18H, 20H, 30H, 40H, 80H, 0FFH
0091    080C1018
0095    20304080
0099    FF
                      1542     
                      1543     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1544     ;
                      1545     ; Timer0 interrupt routine
                      1546     ;
                      1547     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                      1548     ; Requirements: Temp variables can NOT be used since PWSW.3 is not set
                      1549     ;
                      1550     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1551     T0_INT: 	; Used for pwm control
009A    C2AF          1552     	CLR 	EA			; Disable all interrupts
009C    C0D0          1553     	PUSH	PSW			; Preserve registers through interrupt
009E    C0E0          1554     	PUSH	ACC		
                      1555     	; Check if pwm is on
00A0    20620D        1556     JB FLAGS0 . 2 , T0_INT_PWM_OFF 
                      1557     
                      1558     	; Pwm on cycle. 
00A3    303702        1559     	JNB	CURRENT_PWM_LIMITED.7, T0_INT_PWM_ON_LOW_PWM	; Jump for low pwm (<50%)
                      1560     
                      1561     T0_INT_PWM_ON_EXECUTE: 
00A6    E4            1562     	CLR	A					
00A7    73            1563     	JMP	@A+DPTR					; No - jump to pwm on routines. DPTR should be set to one of the pwm_nfet_on labels
                      1564     
                      1565     T0_INT_PWM_ON_LOW_PWM: 
                      1566     	; Do not execute pwm when stopped
00A8    306802        1567     JNB FLAGS1 . 0 , T0_INT_PWM_ON_STOPPED 
                      1568     
                      1569     IF MODE == 0 OR MODE == 2	; Main or multi
00AB    80F9          1570     	JMP	T0_INT_PWM_ON_EXECUTE
                      1571     ENDIF
                      1572     IF MODE == 1				; Tail
                               	; Skip pwm on cycles for very low pwm
                               	INC	PWM_ON_CNT				; Increment event counter
                               	CLR	C
                               	MOV	A, #5					; Only skip for very low pwm
                               	SUBB	A, CURRENT_PWM_LIMITED		; Check skipping shall be done (for low pwm only)
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	SUBB	A, PWM_ON_CNT				; Check if on cycle is to be skipped
                               	JC	T0_INT_PWM_ON_EXECUTE
                               
                               	MOV	TL0, #120					; Write start point for timer
                               	MOV	A, CURRENT_PWM_LIMITED
                               	JNZ	($+5)
                               	MOV	TL0, #0					; Write start point for timer (long time for zero pwm)
                               	JMP	T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE
                               ENDIF
                      1589     
                      1590     T0_INT_PWM_ON_STOPPED: 
00AD    020380        1591     	JMP	T0_INT_PWM_ON_EXIT
                      1592     
                      1593     
                      1594     T0_INT_PWM_OFF: 
                      1595     	; Pwm off cycle
00B0    85268A        1596     	MOV	TL0, CURRENT_PWM_LIMITED		; Load new timer setting
                      1597     	; Clear pwm on flag
00B3    C262          1598     CLR FLAGS0 . 2 
                      1599     	; Set full PWM (on all the time) if current PWM near max. This will give full power, but at the cost of a small "jump" in power
00B5    E526          1600     	MOV	A, CURRENT_PWM_LIMITED		; Load current pwm
00B7    F4            1601     	CPL	A						; Full pwm?
00B8    7002          1602     	JNZ	($+4)					; No - branch
00BA    2173          1603     	AJMP	T0_INT_PWM_OFF_FULLPOWER_EXIT	; Yes - exit
                      1604     
00BC    0562          1605     	INC	PWM_OFF_CNT				; Increment event counter
                      1606     	; Do not execute pwm when stopped
00BE    306813        1607     JNB FLAGS1 . 0 , T0_INT_PWM_OFF_STOPPED 
                      1608     
                      1609     	; If damped operation, set pFETs on in pwm_off
00C1    207219        1610     JB FLAGS2 . 2 , T0_INT_PWM_OFF_DAMPED 
                      1611     
                      1612     	; Separate exit commands here for minimum delay
00C4    758B00        1613     	MOV	TL1, #0		; Reset timer1	
00C7    D0E0          1614     	POP	ACC			; Restore preserved registers
00C9    D0D0          1615     	POP	PSW
                      1616     	ALL_NFETS_OFF 		; Switch off all nfets
00CB    D297          1616+1   SETB P1 . 7 
00CD    D295          1616+1   SETB P1 . 5 
00CF    D293          1616+1   SETB P1 . 3 
00D1    D2AF          1617     	SETB	EA			; Enable all interrupts
00D3    32            1618     	RETI
                      1619     
                      1620     T0_INT_PWM_OFF_STOPPED: 
                      1621     	ALL_NFETS_OFF 					; Switch off all nfets
00D4    D297          1621+1   SETB P1 . 7 
00D6    D295          1621+1   SETB P1 . 5 
00D8    D293          1621+1   SETB P1 . 3 
00DA    020163        1622     	JMP	T0_INT_PWM_OFF_EXIT
                      1623     
                      1624     T0_INT_PWM_OFF_DAMPED: 
00DD    D276          1625     SETB FLAGS2 . 6 
00DF    C277          1626     CLR FLAGS2 . 7 
00E1    C3            1627     	CLR	C
00E2    E562          1628     	MOV	A, PWM_OFF_CNT				; Is damped on number reached?
00E4    14            1629     	DEC	A
00E5    9564          1630     	SUBB	A, DAMPING_ON
00E7    4011          1631     	JC	T0_INT_PWM_OFF_DO_DAMPED		; No - apply damping
                      1632     
00E9    C276          1633     CLR FLAGS2 . 6 
00EB    D277          1634     SETB FLAGS2 . 7 
00ED    C3            1635     	CLR	C
00EE    E562          1636     	MOV	A, PWM_OFF_CNT					
00F0    9563          1637     	SUBB	A, DAMPING_PERIOD			; Is damped period number reached?
00F2    406F          1638     	JC	T0_INT_PWM_OFF_EXIT			; No - Branch
                      1639     
00F4    756200        1640     	MOV	PWM_OFF_CNT, #0			; Yes - clear counter
00F7    020163        1641     	JMP	T0_INT_PWM_OFF_EXIT			; Not damped cycle - exit	
                      1642     
                      1643     T0_INT_PWM_OFF_DO_DAMPED: 
                      1644     	; Delay to allow nFETs to go off before pFETs are turned on (only in full damped mode)
00FA    207414        1645     JB FLAGS2 . 4 , T0_INT_PWM_OFF_DAMPED_LIGHT 
                      1646     
                      1647     	ALL_NFETS_OFF 					; Switch off all nfets
00FD    D297          1647+1   SETB P1 . 7 
00FF    D295          1647+1   SETB P1 . 5 
0101    D293          1647+1   SETB P1 . 3 
0103    7401          1648     MOV A , # 1 
0105    D5E0FD        1649     	DJNZ	ACC, $	
                      1650     	ALL_PFETS_ON 					; Switch on all pfets
0108    D296          1650+1   SETB P1 . 6 
010A    D294          1650+1   SETB P1 . 4 
010C    D292          1650+1   SETB P1 . 2 
010E    020163        1651     	JMP	T0_INT_PWM_OFF_EXIT
                      1652     
                      1653     T0_INT_PWM_OFF_DAMPED_LIGHT: 
                      1654     IF DAMPED_MODE_ENABLE == 1
                               	SETB	FLAGS2.CURR_PWMOFF_COMP_ABLE	; Set comparator usable status always for damped light mode on fully damped capable escs
                               ENDIF
                      1657     	ALL_NFETS_OFF 					; Switch off all nfets
0111    D297          1657+1   SETB P1 . 7 
0113    D295          1657+1   SETB P1 . 5 
0115    D293          1657+1   SETB P1 . 3 
0117    E53E          1658     	MOV	A, COMM_PHASE				; Turn on pfets according to commutation phase
0119    20E225        1659     	JB	ACC.2, T0_INT_PWM_OFF_COMM_4_5_6
011C    20E10D        1660     	JB	ACC.1, T0_INT_PWM_OFF_COMM_2_3
                      1661     
                      1662     IF DAMPED_MODE_ENABLE == 0
                      1663     	APFET_ON			; Comm phase 1 - turn on A
011F    207C02        1663+1   JB FLAGS3 . 4 , ( $+5 ) 
0122    D296          1663+1   SETB P1 . 6 
0124    307C02        1663+1   JNB FLAGS3 . 4 , ( $+5 ) 
0127    D292          1663+1   SETB P1 . 2 
                      1664     ELSE
                               	CPFET_ON			; Comm phase 1 - turn on C
                               ENDIF
0129    020163        1667     	JMP	T0_INT_PWM_OFF_EXIT
                      1668     
                      1669     T0_INT_PWM_OFF_COMM_2_3: 
012C    20E005        1670     	JB	ACC.0, T0_INT_PWM_OFF_COMM_3
                      1671     IF DAMPED_MODE_ENABLE == 0
                      1672     	BPFET_ON			; Comm phase 2 - turn on B
012F    D294          1672+1   SETB P1 . 4 
                      1673     ELSE
                               	CPFET_ON			; Comm phase 2 - turn on C
                               ENDIF
0131    020163        1676     	JMP	T0_INT_PWM_OFF_EXIT
                      1677     
                      1678     T0_INT_PWM_OFF_COMM_3: 
                      1679     IF DAMPED_MODE_ENABLE == 0
                      1680     	CPFET_ON			; Comm phase 3 - turn on C
0134    207C02        1680+1   JB FLAGS3 . 4 , ( $+5 ) 
0137    D292          1680+1   SETB P1 . 2 
0139    307C02        1680+1   JNB FLAGS3 . 4 , ( $+5 ) 
013C    D296          1680+1   SETB P1 . 6 
                      1681     ELSE
                               	BPFET_ON			; Comm phase 3 - turn on B
                               ENDIF
013E    020163        1684     	JMP	T0_INT_PWM_OFF_EXIT
                      1685     
                      1686     T0_INT_PWM_OFF_COMM_4_5_6: 
0141    20E115        1687     	JB	ACC.1, T0_INT_PWM_OFF_COMM_6
0144    20E00D        1688     	JB	ACC.0, T0_INT_PWM_OFF_COMM_5
                      1689     
                      1690     IF DAMPED_MODE_ENABLE == 0
                      1691     	APFET_ON			; Comm phase 4 - turn on A
0147    207C02        1691+1   JB FLAGS3 . 4 , ( $+5 ) 
014A    D296          1691+1   SETB P1 . 6 
014C    307C02        1691+1   JNB FLAGS3 . 4 , ( $+5 ) 
014F    D292          1691+1   SETB P1 . 2 
                      1692     ELSE
                               	BPFET_ON			; Comm phase 4 - turn on B
                               ENDIF
0151    020163        1695     	JMP	T0_INT_PWM_OFF_EXIT
                      1696     
                      1697     T0_INT_PWM_OFF_COMM_5: 
                      1698     IF DAMPED_MODE_ENABLE == 0
                      1699     	BPFET_ON			; Comm phase 5 - turn on B
0154    D294          1699+1   SETB P1 . 4 
                      1700     ELSE
                               	APFET_ON			; Comm phase 5 - turn on A
                               ENDIF
0156    020163        1703     	JMP	T0_INT_PWM_OFF_EXIT
                      1704     
                      1705     T0_INT_PWM_OFF_COMM_6: 
                      1706     IF DAMPED_MODE_ENABLE == 0
                      1707     	CPFET_ON			; Comm phase 6 - turn on C
0159    207C02        1707+1   JB FLAGS3 . 4 , ( $+5 ) 
015C    D292          1707+1   SETB P1 . 2 
015E    307C02        1707+1   JNB FLAGS3 . 4 , ( $+5 ) 
0161    D296          1707+1   SETB P1 . 6 
                      1708     ELSE
                               	APFET_ON			; Comm phase 6 - turn on A
                               ENDIF
                      1711     
                      1712     T0_INT_PWM_OFF_EXIT: 	; Exit from pwm off cycle
0163    758B00        1713     	MOV	TL1, #0		; Reset timer1	
0166    D0E0          1714     	POP	ACC			; Restore preserved registers
0168    D0D0          1715     	POP	PSW
                      1716     	ALL_NFETS_OFF 		; Switch off all nfets
016A    D297          1716+1   SETB P1 . 7 
016C    D295          1716+1   SETB P1 . 5 
016E    D293          1716+1   SETB P1 . 3 
0170    D2AF          1717     	SETB	EA			; Enable all interrupts
0172    32            1718     	RETI
                      1719     
                      1720     T0_INT_PWM_OFF_FULLPOWER_EXIT: 	; Exit from pwm off cycle, leaving power on
0173    D0E0          1721     	POP	ACC			; Restore preserved registers
0175    D0D0          1722     	POP	PSW
0177    D2AF          1723     	SETB	EA			; Enable all interrupts
0179    32            1724     	RETI
                      1725     
                      1726     
                      1727     
                      1728     PWM_NOFET_ON: 	; Dummy pwm on cycle
017A    6180          1729     	AJMP	T0_INT_PWM_ON_EXIT
                      1730     
                      1731     PWM_AFET_ON: 	; Pwm on cycle afet on (bfet off)
                      1732     	ANFET_ON	
017C    E526          1732+1   MOV A , CURRENT_PWM_LIMITED 
017E    600A          1732+1   JZ ( $+12 ) 
0180    207C02        1732+1   JB FLAGS3 . 4 , ( $+5 ) 
0183    C297          1732+1   CLR P1 . 7 
0185    307C02        1732+1   JNB FLAGS3 . 4 , ( $+5 ) 
0188    C293          1732+1   CLR P1 . 3 
                      1733     	BNFET_OFF
018A    D295          1733+1   SETB P1 . 5 
018C    6180          1734     	AJMP	T0_INT_PWM_ON_EXIT
                      1735     
                      1736     PWM_BFET_ON: 	; Pwm on cycle bfet on (cfet off)
                      1737     	BNFET_ON
018E    E526          1737+1   MOV A , CURRENT_PWM_LIMITED 
0190    6002          1737+1   JZ ( $+4 ) 
0192    C295          1737+1   CLR P1 . 5 
                      1738     	CNFET_OFF
0194    207C02        1738+1   JB FLAGS3 . 4 , ( $+5 ) 
0197    D293          1738+1   SETB P1 . 3 
0199    307C02        1738+1   JNB FLAGS3 . 4 , ( $+5 ) 
019C    D297          1738+1   SETB P1 . 7 
019E    6180          1739     	AJMP	T0_INT_PWM_ON_EXIT
                      1740     
                      1741     PWM_CFET_ON: 	; Pwm on cycle cfet on (afet off)
                      1742     	CNFET_ON
01A0    E526          1742+1   MOV A , CURRENT_PWM_LIMITED 
01A2    600A          1742+1   JZ ( $+12 ) 
01A4    207C02        1742+1   JB FLAGS3 . 4 , ( $+5 ) 
01A7    C293          1742+1   CLR P1 . 3 
01A9    307C02        1742+1   JNB FLAGS3 . 4 , ( $+5 ) 
01AC    C297          1742+1   CLR P1 . 7 
                      1743     	ANFET_OFF
01AE    207C02        1743+1   JB FLAGS3 . 4 , ( $+5 ) 
01B1    D297          1743+1   SETB P1 . 7 
01B3    307C02        1743+1   JNB FLAGS3 . 4 , ( $+5 ) 
01B6    D293          1743+1   SETB P1 . 3 
01B8    6180          1744     	AJMP	T0_INT_PWM_ON_EXIT
                      1745     
                      1746     PWM_ANFET_BPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1747     	APFET_OFF
01BA    207C02        1747+1   JB FLAGS3 . 4 , ( $+5 ) 
01BD    C296          1747+1   CLR P1 . 6 
01BF    307C02        1747+1   JNB FLAGS3 . 4 , ( $+5 ) 
01C2    C292          1747+1   CLR P1 . 2 
                      1748     	ANFET_ON								; Switch nFETs
01C4    E526          1748+1   MOV A , CURRENT_PWM_LIMITED 
01C6    600A          1748+1   JZ ( $+12 ) 
01C8    207C02        1748+1   JB FLAGS3 . 4 , ( $+5 ) 
01CB    C297          1748+1   CLR P1 . 7 
01CD    307C02        1748+1   JNB FLAGS3 . 4 , ( $+5 ) 
01D0    C293          1748+1   CLR P1 . 3 
                      1749     	CPFET_OFF
01D2    207C02        1749+1   JB FLAGS3 . 4 , ( $+5 ) 
01D5    C292          1749+1   CLR P1 . 2 
01D7    307C02        1749+1   JNB FLAGS3 . 4 , ( $+5 ) 
01DA    C296          1749+1   CLR P1 . 6 
                      1750     	BNFET_OFF 							
01DC    D295          1750+1   SETB P1 . 5 
01DE    6180          1751     	AJMP	T0_INT_PWM_ON_EXIT
                      1752     PWM_ANFET_BPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and bpfet on (used in damped state 6)
                      1753     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1754     	APFET_OFF
01E0    207C02        1754+1   JB FLAGS3 . 4 , ( $+5 ) 
01E3    C296          1754+1   CLR P1 . 6 
01E5    307C02        1754+1   JNB FLAGS3 . 4 , ( $+5 ) 
01E8    C292          1754+1   CLR P1 . 2 
                      1755     	CPFET_OFF
01EA    207C02        1755+1   JB FLAGS3 . 4 , ( $+5 ) 
01ED    C292          1755+1   CLR P1 . 2 
01EF    307C02        1755+1   JNB FLAGS3 . 4 , ( $+5 ) 
01F2    C296          1755+1   CLR P1 . 6 
01F4    7419          1756     MOV A , # 25 
01F6    D5E0FD        1757     	DJNZ ACC,	$
                      1758     	ANFET_ON								; Switch nFETs
01F9    E526          1758+1   MOV A , CURRENT_PWM_LIMITED 
01FB    600A          1758+1   JZ ( $+12 ) 
01FD    207C02        1758+1   JB FLAGS3 . 4 , ( $+5 ) 
0200    C297          1758+1   CLR P1 . 7 
0202    307C02        1758+1   JNB FLAGS3 . 4 , ( $+5 ) 
0205    C293          1758+1   CLR P1 . 3 
                      1759     	BNFET_OFF 							
0207    D295          1759+1   SETB P1 . 5 
0209    6180          1760     	AJMP	T0_INT_PWM_ON_EXIT
                      1761     
                      1762     PWM_ANFET_CPFET_ON_FAST: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1763     	APFET_OFF
020B    207C02        1763+1   JB FLAGS3 . 4 , ( $+5 ) 
020E    C296          1763+1   CLR P1 . 6 
0210    307C02        1763+1   JNB FLAGS3 . 4 , ( $+5 ) 
0213    C292          1763+1   CLR P1 . 2 
                      1764     	ANFET_ON								; Switch nFETs
0215    E526          1764+1   MOV A , CURRENT_PWM_LIMITED 
0217    600A          1764+1   JZ ( $+12 ) 
0219    207C02        1764+1   JB FLAGS3 . 4 , ( $+5 ) 
021C    C297          1764+1   CLR P1 . 7 
021E    307C02        1764+1   JNB FLAGS3 . 4 , ( $+5 ) 
0221    C293          1764+1   CLR P1 . 3 
                      1765     	BPFET_OFF
0223    C294          1765+1   CLR P1 . 4 
                      1766     	BNFET_OFF								
0225    D295          1766+1   SETB P1 . 5 
0227    6180          1767     	AJMP	T0_INT_PWM_ON_EXIT
                      1768     PWM_ANFET_CPFET_ON_SAFE: 	; Pwm on cycle anfet on (bnfet off) and cpfet on (used in damped state 5)
                      1769     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1770     	APFET_OFF
0229    207C02        1770+1   JB FLAGS3 . 4 , ( $+5 ) 
022C    C296          1770+1   CLR P1 . 6 
022E    307C02        1770+1   JNB FLAGS3 . 4 , ( $+5 ) 
0231    C292          1770+1   CLR P1 . 2 
                      1771     	BPFET_OFF
0233    C294          1771+1   CLR P1 . 4 
0235    7419          1772     MOV A , # 25 
0237    D5E0FD        1773     	DJNZ ACC,	$
                      1774     	ANFET_ON								; Switch nFETs
023A    E526          1774+1   MOV A , CURRENT_PWM_LIMITED 
023C    600A          1774+1   JZ ( $+12 ) 
023E    207C02        1774+1   JB FLAGS3 . 4 , ( $+5 ) 
0241    C297          1774+1   CLR P1 . 7 
0243    307C02        1774+1   JNB FLAGS3 . 4 , ( $+5 ) 
0246    C293          1774+1   CLR P1 . 3 
                      1775     	BNFET_OFF								
0248    D295          1775+1   SETB P1 . 5 
024A    6180          1776     	AJMP	T0_INT_PWM_ON_EXIT
                      1777     
                      1778     PWM_BNFET_CPFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1779     	BPFET_OFF
024C    C294          1779+1   CLR P1 . 4 
                      1780     	BNFET_ON								; Switch nFETs
024E    E526          1780+1   MOV A , CURRENT_PWM_LIMITED 
0250    6002          1780+1   JZ ( $+4 ) 
0252    C295          1780+1   CLR P1 . 5 
                      1781     	APFET_OFF
0254    207C02        1781+1   JB FLAGS3 . 4 , ( $+5 ) 
0257    C296          1781+1   CLR P1 . 6 
0259    307C02        1781+1   JNB FLAGS3 . 4 , ( $+5 ) 
025C    C292          1781+1   CLR P1 . 2 
                      1782     	CNFET_OFF								
025E    207C02        1782+1   JB FLAGS3 . 4 , ( $+5 ) 
0261    D293          1782+1   SETB P1 . 3 
0263    307C02        1782+1   JNB FLAGS3 . 4 , ( $+5 ) 
0266    D297          1782+1   SETB P1 . 7 
0268    6180          1783     	AJMP	T0_INT_PWM_ON_EXIT
                      1784     PWM_BNFET_CPFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and cpfet on (used in damped state 4)
                      1785     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1786     	BPFET_OFF
026A    C294          1786+1   CLR P1 . 4 
                      1787     	APFET_OFF
026C    207C02        1787+1   JB FLAGS3 . 4 , ( $+5 ) 
026F    C296          1787+1   CLR P1 . 6 
0271    307C02        1787+1   JNB FLAGS3 . 4 , ( $+5 ) 
0274    C292          1787+1   CLR P1 . 2 
0276    7419          1788     MOV A , # 25 
0278    D5E0FD        1789     	DJNZ ACC,	$
                      1790     	BNFET_ON								; Switch nFETs
027B    E526          1790+1   MOV A , CURRENT_PWM_LIMITED 
027D    6002          1790+1   JZ ( $+4 ) 
027F    C295          1790+1   CLR P1 . 5 
                      1791     	CNFET_OFF								
0281    207C02        1791+1   JB FLAGS3 . 4 , ( $+5 ) 
0284    D293          1791+1   SETB P1 . 3 
0286    307C02        1791+1   JNB FLAGS3 . 4 , ( $+5 ) 
0289    D297          1791+1   SETB P1 . 7 
028B    6180          1792     	AJMP	T0_INT_PWM_ON_EXIT
                      1793     
                      1794     PWM_BNFET_APFET_ON_FAST: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1795     	BPFET_OFF
028D    C294          1795+1   CLR P1 . 4 
                      1796     	BNFET_ON								; Switch nFETs
028F    E526          1796+1   MOV A , CURRENT_PWM_LIMITED 
0291    6002          1796+1   JZ ( $+4 ) 
0293    C295          1796+1   CLR P1 . 5 
                      1797     	CPFET_OFF
0295    207C02        1797+1   JB FLAGS3 . 4 , ( $+5 ) 
0298    C292          1797+1   CLR P1 . 2 
029A    307C02        1797+1   JNB FLAGS3 . 4 , ( $+5 ) 
029D    C296          1797+1   CLR P1 . 6 
                      1798     	CNFET_OFF								
029F    207C02        1798+1   JB FLAGS3 . 4 , ( $+5 ) 
02A2    D293          1798+1   SETB P1 . 3 
02A4    307C02        1798+1   JNB FLAGS3 . 4 , ( $+5 ) 
02A7    D297          1798+1   SETB P1 . 7 
02A9    6180          1799     	AJMP	T0_INT_PWM_ON_EXIT
                      1800     PWM_BNFET_APFET_ON_SAFE: 	; Pwm on cycle bnfet on (cnfet off) and apfet on (used in damped state 3)
                      1801     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1802     	BPFET_OFF
02AB    C294          1802+1   CLR P1 . 4 
                      1803     	CPFET_OFF
02AD    207C02        1803+1   JB FLAGS3 . 4 , ( $+5 ) 
02B0    C292          1803+1   CLR P1 . 2 
02B2    307C02        1803+1   JNB FLAGS3 . 4 , ( $+5 ) 
02B5    C296          1803+1   CLR P1 . 6 
02B7    7419          1804     MOV A , # 25 
02B9    D5E0FD        1805     	DJNZ ACC,	$
                      1806     	BNFET_ON								; Switch nFETs
02BC    E526          1806+1   MOV A , CURRENT_PWM_LIMITED 
02BE    6002          1806+1   JZ ( $+4 ) 
02C0    C295          1806+1   CLR P1 . 5 
                      1807     	CNFET_OFF								
02C2    207C02        1807+1   JB FLAGS3 . 4 , ( $+5 ) 
02C5    D293          1807+1   SETB P1 . 3 
02C7    307C02        1807+1   JNB FLAGS3 . 4 , ( $+5 ) 
02CA    D297          1807+1   SETB P1 . 7 
02CC    6180          1808     	AJMP	T0_INT_PWM_ON_EXIT
                      1809     
                      1810     PWM_CNFET_APFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1811     	CPFET_OFF
02CE    207C02        1811+1   JB FLAGS3 . 4 , ( $+5 ) 
02D1    C292          1811+1   CLR P1 . 2 
02D3    307C02        1811+1   JNB FLAGS3 . 4 , ( $+5 ) 
02D6    C296          1811+1   CLR P1 . 6 
                      1812     	CNFET_ON								; Switch nFETs
02D8    E526          1812+1   MOV A , CURRENT_PWM_LIMITED 
02DA    600A          1812+1   JZ ( $+12 ) 
02DC    207C02        1812+1   JB FLAGS3 . 4 , ( $+5 ) 
02DF    C293          1812+1   CLR P1 . 3 
02E1    307C02        1812+1   JNB FLAGS3 . 4 , ( $+5 ) 
02E4    C297          1812+1   CLR P1 . 7 
                      1813     	BPFET_OFF
02E6    C294          1813+1   CLR P1 . 4 
                      1814     	ANFET_OFF								
02E8    207C02        1814+1   JB FLAGS3 . 4 , ( $+5 ) 
02EB    D297          1814+1   SETB P1 . 7 
02ED    307C02        1814+1   JNB FLAGS3 . 4 , ( $+5 ) 
02F0    D293          1814+1   SETB P1 . 3 
02F2    6180          1815     	AJMP	T0_INT_PWM_ON_EXIT
                      1816     PWM_CNFET_APFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and apfet on (used in damped state 2)
                      1817     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1818     	CPFET_OFF
02F4    207C02        1818+1   JB FLAGS3 . 4 , ( $+5 ) 
02F7    C292          1818+1   CLR P1 . 2 
02F9    307C02        1818+1   JNB FLAGS3 . 4 , ( $+5 ) 
02FC    C296          1818+1   CLR P1 . 6 
                      1819     	BPFET_OFF
02FE    C294          1819+1   CLR P1 . 4 
0300    7419          1820     MOV A , # 25 
0302    D5E0FD        1821     	DJNZ ACC,	$
                      1822     	CNFET_ON								; Switch nFETs
0305    E526          1822+1   MOV A , CURRENT_PWM_LIMITED 
0307    600A          1822+1   JZ ( $+12 ) 
0309    207C02        1822+1   JB FLAGS3 . 4 , ( $+5 ) 
030C    C293          1822+1   CLR P1 . 3 
030E    307C02        1822+1   JNB FLAGS3 . 4 , ( $+5 ) 
0311    C297          1822+1   CLR P1 . 7 
                      1823     	ANFET_OFF								
0313    207C02        1823+1   JB FLAGS3 . 4 , ( $+5 ) 
0316    D297          1823+1   SETB P1 . 7 
0318    307C02        1823+1   JNB FLAGS3 . 4 , ( $+5 ) 
031B    D293          1823+1   SETB P1 . 3 
031D    6180          1824     	AJMP	T0_INT_PWM_ON_EXIT
                      1825     
                      1826     PWM_CNFET_BPFET_ON_FAST: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1827     	CPFET_OFF
031F    207C02        1827+1   JB FLAGS3 . 4 , ( $+5 ) 
0322    C292          1827+1   CLR P1 . 2 
0324    307C02        1827+1   JNB FLAGS3 . 4 , ( $+5 ) 
0327    C296          1827+1   CLR P1 . 6 
                      1828     	CNFET_ON								; Switch nFETs
0329    E526          1828+1   MOV A , CURRENT_PWM_LIMITED 
032B    600A          1828+1   JZ ( $+12 ) 
032D    207C02        1828+1   JB FLAGS3 . 4 , ( $+5 ) 
0330    C293          1828+1   CLR P1 . 3 
0332    307C02        1828+1   JNB FLAGS3 . 4 , ( $+5 ) 
0335    C297          1828+1   CLR P1 . 7 
                      1829     	APFET_OFF
0337    207C02        1829+1   JB FLAGS3 . 4 , ( $+5 ) 
033A    C296          1829+1   CLR P1 . 6 
033C    307C02        1829+1   JNB FLAGS3 . 4 , ( $+5 ) 
033F    C292          1829+1   CLR P1 . 2 
                      1830     	ANFET_OFF								
0341    207C02        1830+1   JB FLAGS3 . 4 , ( $+5 ) 
0344    D297          1830+1   SETB P1 . 7 
0346    307C02        1830+1   JNB FLAGS3 . 4 , ( $+5 ) 
0349    D293          1830+1   SETB P1 . 3 
034B    6180          1831     	AJMP	T0_INT_PWM_ON_EXIT
                      1832     PWM_CNFET_BPFET_ON_SAFE: 	; Pwm on cycle cnfet on (anfet off) and bpfet on (used in damped state 1)
                      1833     	; Delay from pFETs are turned off (only in damped mode) until nFET is turned on (pFETs are slow)
                      1834     	CPFET_OFF
034D    207C02        1834+1   JB FLAGS3 . 4 , ( $+5 ) 
0350    C292          1834+1   CLR P1 . 2 
0352    307C02        1834+1   JNB FLAGS3 . 4 , ( $+5 ) 
0355    C296          1834+1   CLR P1 . 6 
                      1835     	APFET_OFF
0357    207C02        1835+1   JB FLAGS3 . 4 , ( $+5 ) 
035A    C296          1835+1   CLR P1 . 6 
035C    307C02        1835+1   JNB FLAGS3 . 4 , ( $+5 ) 
035F    C292          1835+1   CLR P1 . 2 
0361    7419          1836     MOV A , # 25 
0363    D5E0FD        1837     	DJNZ ACC,	$
                      1838     	CNFET_ON								; Switch nFETs
0366    E526          1838+1   MOV A , CURRENT_PWM_LIMITED 
0368    600A          1838+1   JZ ( $+12 ) 
036A    207C02        1838+1   JB FLAGS3 . 4 , ( $+5 ) 
036D    C293          1838+1   CLR P1 . 3 
036F    307C02        1838+1   JNB FLAGS3 . 4 , ( $+5 ) 
0372    C297          1838+1   CLR P1 . 7 
                      1839     	ANFET_OFF								
0374    207C02        1839+1   JB FLAGS3 . 4 , ( $+5 ) 
0377    D297          1839+1   SETB P1 . 7 
0379    307C02        1839+1   JNB FLAGS3 . 4 , ( $+5 ) 
037C    D293          1839+1   SETB P1 . 3 
037E    6180          1840     	AJMP	T0_INT_PWM_ON_EXIT
                      1841     
                      1842     T0_INT_PWM_ON_EXIT: 
                      1843     	; Set timer for coming on cycle length
0380    E526          1844     	MOV 	A, CURRENT_PWM_LIMITED		; Load current pwm
0382    F4            1845     	CPL	A						; cpl is 255-x
0383    F58A          1846     	MOV	TL0, A					; Write start point for timer
                      1847     	; Set other variables
0385    758B00        1848     	MOV	TL1, #0					; Reset timer1	
0388    756100        1849     	MOV	PWM_ON_CNT, #0				; Reset pwm on event counter
038B    D262          1850     SETB FLAGS0 . 2 
                      1851     T0_INT_PWM_ON_EXIT_NO_TIMER_UPDATE: 
                      1852     	; Exit interrupt
038D    D0E0          1853     	POP	ACC			; Restore preserved registers
038F    D0D0          1854     	POP	PSW
0391    D2AF          1855     	SETB	EA			; Enable all interrupts
0393    32            1856     	RETI
                      1857     
                      1858     
                      1859     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1860     ;
                      1861     ; Timer2 interrupt routine
                      1862     ;
                      1863     ; No assumptions
                      1864     ;
                      1865     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      1866     T2_INT: 	; Happens every 128us for low byte and every 32ms for high byte
0394    C2AF          1867     	CLR 	EA			; Disable all interrupts
0396    C0D0          1868     	PUSH	PSW			; Preserve registers through interrupt
0398    C0E0          1869     	PUSH	ACC
039A    D2D3          1870     	SETB	PSW.3		; Select register bank 1 for interrupt routines
                      1871     	; Clear low byte interrupt flag
039C    C2CE          1872     	CLR	TF2L						; Clear interrupt flag
                      1873     	; Check RC pulse timeout counter
039E    E529          1874     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
03A0    600A          1875     	JZ	T2_INT_PULSES_ABSENT		; Yes - pulses are absent
                      1876     
                      1877     	; Decrement timeout counter (if PWM)
03A2    740F          1878     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
03A4    552F          1879     	ANL	A, FLAGS3					; Check pwm frequency flags
03A6    6049          1880     	JZ	T2_INT_SKIP_START			; If no flag is set (PPM) - branch
                      1881     
03A8    1529          1882     	DEC	RCP_TIMEOUT_CNT			; No - decrement
03AA    61F1          1883     	AJMP	T2_INT_SKIP_START
                      1884     
                      1885     T2_INT_PULSES_ABSENT: 
                      1886     	; Timeout counter has reached zero, pulses are absent
03AC    7800          1887     MOV R0 , # 0 
03AE    7900          1888     MOV R1 , # 0 
                      1889     	READ_RCP_INT 					; Look at value of Rcp_In
03B0    E580          1889+1   MOV A , P0 
03B2    307D01        1889+1   JNB FLAGS3 . 5 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03B5    F4            1889+1   CPL A  ; YES - INVERT
03B6    30E502        1890     JNB ACC . 5 , ( $+5 ) 
03B9    78FF          1891     MOV R0 , # 255 
                      1892     	RCP_INT_FIRST 					; Set interrupt trig to first again
03BB    53DACF        1892+1   ANL PCA0CPM0 , # 0CFH 
03BE    207D03        1892+1   JB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
03C1    43DA20        1892+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
03C4    307D03        1892+1   JNB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
03C7    43DA10        1892+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      1893     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
03CA    C2D8          1893+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
03CC    C271          1894     CLR FLAGS2 . 1 
                      1895     	READ_RCP_INT 					; Look once more at value of Rcp_In
03CE    E580          1895+1   MOV A , P0 
03D0    307D01        1895+1   JNB FLAGS3 . 5 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
03D3    F4            1895+1   CPL A  ; YES - INVERT
03D4    30E502        1896     JNB ACC . 5 , ( $+5 ) 
03D7    79FF          1897     MOV R1 , # 255 
03D9    C3            1898     	CLR	C
03DA    E8            1899     MOV A , R0 
03DB    99            1900     SUBB A , R1 
03DC    70CE          1901     	JNZ 	T2_INT_PULSES_ABSENT		; Go back if they are not equal
                      1902     
03DE    306103        1903     JNB FLAGS0 . 1 , ( $+6 ) 
                      1904     
03E1    752918        1905     MOV RCP_TIMEOUT_CNT , # 24 
                      1906     
03E4    740F          1907     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
03E6    552F          1908     	ANL	A, FLAGS3					; Check pwm frequency flags
03E8    6003          1909     	JZ	T2_INT_PPM_TIMEOUT_SET		; If no flag is set (PPM) - branch
                      1910     
03EA    752918        1911     MOV RCP_TIMEOUT_CNT , # 24 
                      1912     
                      1913     T2_INT_PPM_TIMEOUT_SET: 
03ED    8859          1914     MOV NEW_RCP , R0 
03EF    D270          1915     SETB FLAGS2 . 0 
                      1916     
                      1917     
                      1918     T2_INT_SKIP_START: 
                      1919     	; Check RC pulse skip counter
03F1    E52A          1920     	MOV	A, RCP_SKIP_CNT			
03F3    6004          1921     	JZ 	T2_INT_SKIP_END			; If RC pulse skip count is zero - end skipping RC pulse detection
                      1922     	
                      1923     	; Decrement skip counter (only if edge counter is zero)
03F5    152A          1924     	DEC	RCP_SKIP_CNT				; Decrement
03F7    8104          1925     	AJMP	T2_INT_RCP_UPDATE_START
                      1926     
                      1927     T2_INT_SKIP_END: 
03F9    740F          1928     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
03FB    552F          1929     	ANL	A, FLAGS3					; Check pwm frequency flags
03FD    6005          1930     	JZ	T2_INT_RCP_UPDATE_START		; If no flag is set (PPM) - branch
                      1931     
                      1932     	; Skip counter has reached zero, start looking for RC pulses again
                      1933     	RCP_INT_ENABLE 				; Enable RC pulse interrupt
03FF    43DA01        1933+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      1934     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0402    C2D8          1934+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      1935     	
                      1936     T2_INT_RCP_UPDATE_START: 
                      1937     	; Process updated RC pulse
0404    207002        1938     JB FLAGS2 . 0 , ( $+5 ) 
0407    819E          1939     	AJMP	T2_INT_PWM_EXIT			; No - exit
                      1940     
0409    E559          1941     	MOV	A, NEW_RCP				; Load new pulse value
040B    F8            1942     MOV R0 , A 
040C    C270          1943     CLR FLAGS2 . 0 
                      1944     	; Use a gain of 1.0625x for pwm input if not governor mode
040E    740F          1945     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
0410    552F          1946     	ANL	A, FLAGS3					; Check pwm frequency flags
0412    6036          1947     	JZ	T2_INT_PWM_MIN_RUN			; If no flag is set (PPM) - branch
                      1948     
0414    7984          1949     MOV R1 , # PGM_GOV_MODE 
0416    B70431        1950     CJNE @ R1 , # 4 , T2_INT_PWM_MIN_RUN 
                      1951     
                      1952     	; Limit the maximum value to avoid wrap when scaled to pwm range
0419    C3            1953     	CLR	C
041A    E8            1954     MOV A , R0 
041B    94F0          1955     	SUBB	A, #240			; 240 = (255/1.0625) Needs to be updated according to multiplication factor below		
041D    4003          1956     	JC	T2_INT_RCP_UPDATE_MULT
                      1957     
041F    74F0          1958     	MOV	A, #240			; Set requested pwm to max
0421    F8            1959     MOV R0 , A 
                      1960     
                      1961     T2_INT_RCP_UPDATE_MULT: 	
                      1962     	; Multiply by 1.0625 (optional adjustment gyro gain)
0422    E8            1963     MOV A , R0 
0423    C4            1964     	SWAP	A			; After this "0.0625"
0424    540F          1965     	ANL	A, #0FH
0426    28            1966     ADD A , R0 
0427    F8            1967     MOV R0 , A 
                      1968     	; Adjust tail gain
0428    7987          1969     MOV R1 , # PGM_MOTOR_GAIN 
042A    B70302        1970     CJNE @ R1 , # 3 , ( $+5 ) 
042D    814A          1971     	AJMP	T2_INT_PWM_MIN_RUN			; Yes - skip adjustment
                      1972     
042F    C3            1973     	CLR	C
0430    13            1974     	RRC	A			; After this "0.5"
0431    C3            1975     	CLR	C
0432    13            1976     	RRC	A			; After this "0.25"
0433    8721          1977     MOV BIT_ACCESS_INT , @ R1 
0435    200802        1978     	JB	BIT_ACCESS_INT.0, T2_INT_RCP_GAIN_CORR	; Branch if bit 0 in gain is set
                      1979     
0438    C3            1980     	CLR	C
0439    13            1981     	RRC	A			; After this "0.125"
                      1982     
                      1983     T2_INT_RCP_GAIN_CORR: 
043A    200A06        1984     	JB	BIT_ACCESS_INT.2, T2_INT_RCP_GAIN_POS	; Branch if bit 2 in gain is set
                      1985     
043D    C8            1986     XCH A , R0 
043E    C3            1987     	CLR	C
043F    98            1988     SUBB A , R0 
0440    F8            1989     MOV R0 , A 
0441    814A          1990     	AJMP	T2_INT_PWM_MIN_RUN
                      1991     
                      1992     T2_INT_RCP_GAIN_POS: 
0443    28            1993     ADD A , R0 
0444    F8            1994     MOV R0 , A 
0445    5003          1995     	JNC	T2_INT_PWM_MIN_RUN			; Above max?
                      1996     
0447    74FF          1997     	MOV	A, #0FFH					; Yes - limit
0449    F8            1998     MOV R0 , A 
                      1999     
                      2000     T2_INT_PWM_MIN_RUN:  
                      2001     	; Limit minimum pwm
044A    C3            2002     	CLR	C
044B    E8            2003     MOV A , R0 
044C    9560          2004     	SUBB	A, PWM_MOTOR_IDLE			; Is requested pwm lower than minimum?
044E    5003          2005     	JNC	T2_INT_PWM_UPDATE			; No - branch
                      2006     
0450    E560          2007     	MOV	A, PWM_MOTOR_IDLE			; Yes - limit pwm to Pwm_Motor_Idle	
0452    F8            2008     MOV R0 , A 
                      2009     
                      2010     T2_INT_PWM_UPDATE:  
                      2011     	; Check if any startup phase flags are set
0453    E52D          2012     	MOV	A, FLAGS1
0455    540E          2013     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE)+(1 SHL AQUISITION_PHASE))
0457    7045          2014     	JNZ	T2_INT_PWM_EXIT			; Exit if any startup phase set (pwm controlled by set_startup_pwm)
                      2015     
                      2016     	; Update requested_pwm
0459    8822          2017     MOV REQUESTED_PWM , R0 
                      2018     	; Add a minimum pwm during direct start
045B    306D0A        2019     JNB FLAGS1 . 5 , T2_INT_CURRENT_PWM_UPDATE 
                      2020     
045E    C3            2021     	CLR	C
045F    E522          2022     	MOV	A, REQUESTED_PWM			; Limit pwm during direct start
0461    955D          2023     	SUBB	A, PWM_LIMIT
0463    4003          2024     	JC	T2_INT_CURRENT_PWM_UPDATE
                      2025     
0465    855D22        2026     	MOV	REQUESTED_PWM, PWM_LIMIT
                      2027     
                      2028     T2_INT_CURRENT_PWM_UPDATE:  
0468    7884          2029     MOV R0 , # PGM_GOV_MODE 
046A    B60431        2030     CJNE @ R0 , # 4 , T2_INT_PWM_EXIT 
                      2031     
                      2032     	; Update current pwm, with limited throttle change rate
046D    C3            2033     	CLR	C
046E    E522          2034     	MOV	A, REQUESTED_PWM	
0470    9524          2035     	SUBB	A, CURRENT_PWM				; Is requested pwm larger than current pwm?
0472    4012          2036     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      2037     
0474    7892          2038     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
0476    96            2039     SUBB A , @ R0 
0477    400D          2040     	JC	T2_INT_SET_CURRENT_PWM		; No - proceed
                      2041     
0479    E524          2042     	MOV	A, CURRENT_PWM				; Increase current pwm by throttle change rate
047B    26            2043     ADD A , @ R0 
047C    F524          2044     	MOV	CURRENT_PWM, A
047E    5009          2045     	JNC	T2_INT_CURRENT_PWM_DONE		; Is result above max?
                      2046     
0480    7524FF        2047     	MOV	CURRENT_PWM, #0FFH			; Yes - limit
0483    020489        2048     	JMP	T2_INT_CURRENT_PWM_DONE
                      2049     
                      2050     T2_INT_SET_CURRENT_PWM: 
0486    852224        2051     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set equal as default
                      2052     T2_INT_CURRENT_PWM_DONE: 
                      2053     IF MODE >= 1	; Tail or multi
                      2054     	; If tail/multi and voltage compensation is not enabled, then set current_pwm_limited
0489    C3            2055     	CLR	C
048A    7895          2056     MOV R0 , # PGM_VOLT_COMP 
048C    E6            2057     MOV A , @ R0 
048D    9402          2058     	SUBB	A, #2
048F    500D          2059     	JNC	T2_INT_PWM_EXIT
                      2060     
0491    852426        2061     	MOV	CURRENT_PWM_LIMITED, CURRENT_PWM	; Default not limited
0494    C3            2062     	CLR	C
0495    E524          2063     	MOV	A, CURRENT_PWM					; Check against limit
0497    955D          2064     	SUBB	A, PWM_LIMIT
0499    4003          2065     	JC	($+5)						; If current pwm below limit - branch
                      2066     
049B    855D26        2067     	MOV	CURRENT_PWM_LIMITED, PWM_LIMIT	; Limit pwm
                      2068     ENDIF
                      2069     
                      2070     T2_INT_PWM_EXIT: 	
                      2071     	; Check if high byte flag is set
049E    20CF09        2072     	JB	TF2H, T2H_INT		
04A1    D0E0          2073     	POP	ACC			; Restore preserved registers
04A3    D0D0          2074     	POP	PSW
04A5    C2D3          2075     	CLR	PSW.3		; Select register bank 0 for main program routines	
04A7    D2AF          2076     	SETB	EA			; Enable all interrupts
04A9    32            2077     	RETI
                      2078     
                      2079     T2H_INT: 
                      2080     	; High byte interrupt (happens every 32ms)
04AA    C2CF          2081     	CLR	TF2H					; Clear interrupt flag
04AC    7801          2082     MOV R0 , # 1 
                      2083     	; Check RC pulse timeout counter (used here for PPM only)
04AE    E529          2084     	MOV	A, RCP_TIMEOUT_CNT			; RC pulse timeout count zero?
04B0    6008          2085     	JZ	T2H_INT_RCP_STOP_CHECK		; Yes - do not decrement
                      2086     
                      2087     	; Decrement timeout counter (if PPM)
04B2    740F          2088     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
04B4    552F          2089     	ANL	A, FLAGS3					; Check pwm frequency flags
04B6    7002          2090     	JNZ	T2H_INT_RCP_STOP_CHECK		; If a flag is set (PWM) - branch
                      2091     
04B8    1529          2092     	DEC	RCP_TIMEOUT_CNT			; No flag set (PPM) - decrement
                      2093     
                      2094     T2H_INT_RCP_STOP_CHECK: 
                      2095     	; Check RC pulse against stop value
04BA    E559          2096     	MOV	A, NEW_RCP			; Load new pulse value
04BC    C3            2097     	CLR	C
04BD    9401          2098     SUBB A , # 1 
04BF    4005          2099     	JC	T2H_INT_RCP_STOP
                      2100     
                      2101     	; RC pulse higher than stop value, reset stop counter
04C1    755C00        2102     	MOV	RCP_STOP_CNT, #0		; Reset rcp stop counter
04C4    81CD          2103     	AJMP	T2H_INT_RCP_GOV_PWM
                      2104     
                      2105     T2H_INT_RCP_STOP: 	
                      2106     	; RC pulse less than stop value, increment stop counter
04C6    E55C          2107     	MOV	A, RCP_STOP_CNT		; Load rcp stop counter
04C8    04            2108     	INC	A					; Check if counter is max
04C9    6002          2109     	JZ	T2H_INT_RCP_GOV_PWM		; Branch if counter is equal to max
                      2110     
04CB    055C          2111     	INC	RCP_STOP_CNT			; Increment stop counter 
                      2112     
                      2113     T2H_INT_RCP_GOV_PWM: 
                      2114     IF MODE == 0	; Main
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by arm mode?
                               	MOV	A, @TEMP2
                               	CJNE	A, #2, T2H_INT_RCP_GOV_BY_SETUP	; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	REQUESTED_PWM, GOV_ARM_TARGET		; Yes - load arm target
                               
                               T2H_INT_RCP_GOV_BY_SETUP:
                               	MOV	TEMP2, #PGM_GOV_MODE			; Governor target by setup mode?
                               	MOV	A, @TEMP2
                               	CJNE	A, #3, T2H_INT_RCP_GOV_BY_TX		; No - branch
                               
                               	MOV	A, GOV_ACTIVE					; Is governor active?
                               	JZ	T2H_INT_RCP_GOV_BY_TX			; No - branch (this ensures soft spoolup by tx)
                               
                               	CLR	C
                               	MOV	A, REQUESTED_PWM
                               	SUBB	A, #50						; Is requested pwm below 20%?
                               	JC	T2H_INT_RCP_GOV_BY_TX			; Yes - branch (this enables a soft spooldown)
                               
                               	MOV	TEMP2, #PGM_GOV_SETUP_TARGET		; Gov by setup - load setup target
                               	MOV	REQUESTED_PWM, @TEMP2
                               
                               T2H_INT_RCP_GOV_BY_TX:
                               	CLR	C
                               	MOV	A, GOVERNOR_REQ_PWM
                               	SUBB	A, REQUESTED_PWM				; Is governor requested pwm equal to requested pwm?
                               	JZ	T2H_INT_RCP_GOV_PWM_DONE			; Yes - branch
                               
                               	JC	T2H_INT_RCP_GOV_PWM_INC			; No - if lower, then increment
                               
                               	DEC	GOVERNOR_REQ_PWM				; No - if higher, then decrement
                               	AJMP	T2H_INT_RCP_GOV_PWM_DONE
                               
                               T2H_INT_RCP_GOV_PWM_INC:
                               	INC	GOVERNOR_REQ_PWM				; Increment
                               
                               T2H_INT_RCP_GOV_PWM_DONE:
                               	DJNZ	TEMP1, T2H_INT_RCP_GOV_PWM		; If not number of steps processed - go back
                               	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 8 seconds spoolup
                               	INC	A
                               	JNZ	($+3)						; Limit to 255
                               
                               	DEC	A
                               
                               	MOV	PWM_LIMIT_SPOOLUP, A
                               ENDIF
                      2169     IF MODE == 2	; Multi
04CD    E55E          2170     	MOV	A, PWM_LIMIT_SPOOLUP			; Increment spoolup pwm, for a 0.8 seconds spoolup
04CF    C3            2171     	CLR	C
04D0    240A          2172     	ADD	A, #10
04D2    5005          2173     	JNC	T2H_INT_RCP_NO_LIMIT			; If below 255 - branch
                      2174     
04D4    755EFF        2175     	MOV	PWM_LIMIT_SPOOLUP, #0FFH
04D7    81DB          2176     	AJMP	T2H_INT_RCP_EXIT
                      2177     
                      2178     T2H_INT_RCP_NO_LIMIT: 
04D9    F55E          2179     	MOV	PWM_LIMIT_SPOOLUP, A
                      2180     ENDIF
                      2181     
                      2182     T2H_INT_RCP_EXIT: 
04DB    D0E0          2183     	POP	ACC			; Restore preserved registers
04DD    D0D0          2184     	POP	PSW
04DF    C2D3          2185     	CLR	PSW.3		; Select register bank 0 for main program routines	
04E1    D2AF          2186     	SETB	EA			; Enable all interrupts
04E3    32            2187     	RETI
                      2188     
                      2189     
                      2190     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2191     ;
                      2192     ; Timer3 interrupt routine
                      2193     ;
                      2194     ; No assumptions
                      2195     ;
                      2196     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2197     T3_INT: 	; Used for commutation timing
04E4    C2AF          2198     	CLR 	EA			; Disable all interrupts
04E6    53917F        2199     	ANL	TMR3CN, #07FH		; Clear interrupt flag
04E9    C260          2200     CLR FLAGS0 . 0 
04EB    D2AF          2201     	SETB	EA			; Enable all interrupts
04ED    32            2202     	RETI
                      2203     
                      2204     
                      2205     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2206     ;
                      2207     ; PCA interrupt routine
                      2208     ;
                      2209     ; No assumptions
                      2210     ;
                      2211     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2212     PCA_INT: 	; Used for RC pulse timing
04EE    C2AF          2213     	CLR 	EA			; Disable all interrupts
04F0    C0D0          2214     	PUSH	PSW			; Preserve registers through interrupt
04F2    C0E0          2215     	PUSH	ACC
04F4    C0F0          2216     	PUSH	B
04F6    D2D3          2217     	SETB	PSW.3		; Select register bank 1 for interrupt routines
                      2218     	; Get PCA0 capture values
04F8    A8FB          2219     MOV R0 , PCA0CPL0 
04FA    A9FC          2220     MOV R1 , PCA0CPH0 
                      2221     	; Clear interrupt flag
                      2222     	RCP_CLEAR_INT_FLAG 				
04FC    C2D8          2222+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
                      2223     	; Check which edge it is
04FE    307102        2224     JNB FLAGS2 . 1 , ( $+5 ) 
0501    A151          2225     	AJMP PCA_INT_SECOND_MEAS_PWM_FREQ	; No - branch to second
                      2226     
                      2227     	RCP_INT_SECOND					; Yes - set second edge trig
0503    53DACF        2227+1   ANL PCA0CPM0 , # 0CFH 
0506    207D03        2227+1   JB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0509    43DA10        2227+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
050C    307D03        2227+1   JNB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
050F    43DA20        2227+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
0512    D271          2228     SETB FLAGS2 . 1 
                      2229     	; Read RC signal level
                      2230     	READ_RCP_INT			
0514    E580          2230+1   MOV A , P0 
0516    307D01        2230+1   JNB FLAGS3 . 5 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0519    F4            2230+1   CPL A  ; YES - INVERT
                      2231     	; Test RC signal level
051A    20E502        2232     JB ACC . 5 , ( $+5 ) 
051D    A125          2233     	AJMP	PCA_INT_FAIL_MINIMUM		; No - jump to fail minimum
                      2234     
                      2235     	; RC pulse was high, store RC pulse start timestamp
051F    8827          2236     MOV RCP_PREV_EDGE_L , R0 
0521    8928          2237     MOV RCP_PREV_EDGE_H , R1 
0523    C1AC          2238     	AJMP	PCA_INT_EXIT				; Exit
                      2239     
                      2240     PCA_INT_FAIL_MINIMUM: 
                      2241     	; Prepare for next interrupt
                      2242     	RCP_INT_FIRST					; Set interrupt trig to first again
0525    53DACF        2242+1   ANL PCA0CPM0 , # 0CFH 
0528    207D03        2242+1   JB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
052B    43DA20        2242+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
052E    307D03        2242+1   JNB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0531    43DA10        2242+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      2243     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0534    C2D8          2243+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0536    C271          2244     CLR FLAGS2 . 1 
0538    740F          2245     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
053A    552F          2246     	ANL	A, FLAGS3					; Check pwm frequency flags
053C    7002          2247     	JNZ	($+4)					; If a flag is set (PWM) - proceed
                      2248     
053E    C190          2249     	AJMP	PCA_INT_SET_TIMEOUT			; If PPM - ignore trig as noise
                      2250     
0540    7800          2251     MOV R0 , # 0 
                      2252     	READ_RCP_INT 					; Test RC signal level again
0542    E580          2252+1   MOV A , P0 
0544    307D01        2252+1   JNB FLAGS3 . 5 , ( $+4 )  ; IS PWM POLARITY NEGATIVE?
0547    F4            2252+1   CPL A  ; YES - INVERT
0548    30E502        2253     JNB ACC . 5 , ( $+5 ) 
054B    C190          2254     	AJMP	PCA_INT_SET_TIMEOUT			; Yes - set new timeout and exit
                      2255     
054D    8859          2256     MOV NEW_RCP , R0 
054F    C190          2257     	AJMP	PCA_INT_SET_TIMEOUT			; Set new timeout and exit
                      2258     
                      2259     PCA_INT_SECOND_MEAS_PWM_FREQ: 
                      2260     	; Prepare for next interrupt
                      2261     	RCP_INT_FIRST 					; Set first edge trig
0551    53DACF        2261+1   ANL PCA0CPM0 , # 0CFH 
0554    207D03        2261+1   JB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
0557    43DA20        2261+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
055A    307D03        2261+1   JNB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
055D    43DA10        2261+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
0560    C271          2262     CLR FLAGS2 . 1 
                      2263     	; Check if pwm frequency shall be measured
0562    206102        2264     JB FLAGS0 . 1 , ( $+5 ) 
0565    A1F1          2265     	AJMP	PCA_INT_FALL				; No - skip measurements
                      2266     
                      2267     	; Set second edge trig only during pwm frequency measurement
                      2268     	RCP_INT_SECOND 				; Set second edge trig
0567    53DACF        2268+1   ANL PCA0CPM0 , # 0CFH 
056A    207D03        2268+1   JB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
056D    43DA10        2268+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
0570    307D03        2268+1   JNB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
0573    43DA20        2268+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
                      2269     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
0576    C2D8          2269+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
0578    D271          2270     SETB FLAGS2 . 1 
                      2271     	; Store edge data to RAM
057A    8854          2272     MOV RCP_EDGE_L , R0 
057C    8955          2273     MOV RCP_EDGE_H , R1 
                      2274     	; Calculate pwm frequency
057E    C3            2275     	CLR	C
057F    E8            2276     MOV A , R0 
0580    9552          2277     	SUBB	A, RCP_PREPREV_EDGE_L	
0582    F8            2278     MOV R0 , A 
0583    E9            2279     MOV A , R1 
0584    9553          2280     	SUBB	A, RCP_PREPREV_EDGE_H
0586    F9            2281     MOV R1 , A 
0587    E4            2282     	CLR	A
0588    FB            2283     MOV R3 , A 
                      2284     	; Check if pwm frequency is 8kHz
0589    C3            2285     	CLR	C
058A    E8            2286     MOV A , R0 
058B    9468          2287     	SUBB	A, #LOW(360)				; If below 180us, 8kHz pwm is assumed
058D    E9            2288     MOV A , R1 
058E    9401          2289     	SUBB	A, #HIGH(360)
0590    5006          2290     	JNC	PCA_INT_CHECK_4KHZ
                      2291     
0592    E4            2292     	CLR	A
0593    D2E3          2293     SETB ACC . 3 
0595    FB            2294     MOV R3 , A 
0596    A1C3          2295     	AJMP	PCA_INT_RESTORE_EDGE
                      2296     
                      2297     PCA_INT_CHECK_4KHZ: 
                      2298     	; Check if pwm frequency is 4kHz
0598    C3            2299     	CLR	C
0599    E8            2300     MOV A , R0 
059A    94D0          2301     	SUBB	A, #LOW(720)				; If below 360us, 4kHz pwm is assumed
059C    E9            2302     MOV A , R1 
059D    9402          2303     	SUBB	A, #HIGH(720)
059F    5006          2304     	JNC	PCA_INT_CHECK_2KHZ
                      2305     
05A1    E4            2306     	CLR	A
05A2    D2E2          2307     SETB ACC . 2 
05A4    FB            2308     MOV R3 , A 
05A5    A1C3          2309     	AJMP	PCA_INT_RESTORE_EDGE
                      2310     
                      2311     PCA_INT_CHECK_2KHZ: 
                      2312     	; Check if pwm frequency is 2kHz
05A7    C3            2313     	CLR	C
05A8    E8            2314     MOV A , R0 
05A9    94A0          2315     	SUBB	A, #LOW(1440)				; If below 720us, 2kHz pwm is assumed
05AB    E9            2316     MOV A , R1 
05AC    9405          2317     	SUBB	A, #HIGH(1440)
05AE    5006          2318     	JNC	PCA_INT_CHECK_1KHZ
                      2319     
05B0    E4            2320     	CLR	A
05B1    D2E1          2321     SETB ACC . 1 
05B3    FB            2322     MOV R3 , A 
05B4    A1C3          2323     	AJMP	PCA_INT_RESTORE_EDGE
                      2324     
                      2325     PCA_INT_CHECK_1KHZ: 
                      2326     	; Check if pwm frequency is 1kHz
05B6    C3            2327     	CLR	C
05B7    E8            2328     MOV A , R0 
05B8    9498          2329     	SUBB	A, #LOW(2200)				; If below 1100us, 1kHz pwm is assumed
05BA    E9            2330     MOV A , R1 
05BB    9408          2331     	SUBB	A, #HIGH(2200)
05BD    5004          2332     	JNC	PCA_INT_RESTORE_EDGE
                      2333     
05BF    E4            2334     	CLR	A
05C0    D2E0          2335     SETB ACC . 0 
05C2    FB            2336     MOV R3 , A 
                      2337     
                      2338     PCA_INT_RESTORE_EDGE: 
                      2339     	; Calculate difference between this period and previous period
05C3    C3            2340     	CLR	C
05C4    E8            2341     MOV A , R0 
05C5    9556          2342     	SUBB	A, RCP_PREV_PERIOD_L
05C7    FC            2343     MOV R4 , A 
05C8    E9            2344     MOV A , R1 
05C9    9557          2345     	SUBB	A, RCP_PREV_PERIOD_H
05CB    FD            2346     MOV R5 , A 
                      2347     	; Make positive
05CC    30E708        2348     	JNB	ACC.7, PCA_INT_CHECK_DIFF
05CF    EC            2349     MOV A , R4 
05D0    F4            2350     	CPL	A
05D1    2401          2351     	ADD	A, #1
05D3    FC            2352     MOV R4 , A 
05D4    ED            2353     MOV A , R5 
05D5    F4            2354     	CPL	A
05D6    FD            2355     MOV R5 , A 
                      2356     
                      2357     PCA_INT_CHECK_DIFF: 
                      2358     	; Check difference
05D7    755800        2359     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #0		; Set not accepted as default
05DA    7009          2360     	JNZ	PCA_INT_STORE_DATA				; Check if high byte is zero
                      2361     
05DC    C3            2362     	CLR	C
05DD    EC            2363     MOV A , R4 
05DE    940A          2364     	SUBB	A, #10						; Check difference
05E0    5003          2365     	JNC	PCA_INT_STORE_DATA
                      2366     
05E2    755801        2367     	MOV	RCP_PERIOD_DIFF_ACCEPTED, #1		; Set accepted
                      2368     
                      2369     PCA_INT_STORE_DATA: 
                      2370     	; Store previous period
05E5    8856          2371     MOV RCP_PREV_PERIOD_L , R0 
05E7    8957          2372     MOV RCP_PREV_PERIOD_H , R1 
                      2373     	; Restore edge data from RAM
05E9    A854          2374     MOV R0 , RCP_EDGE_L 
05EB    A955          2375     MOV R1 , RCP_EDGE_H 
                      2376     	; Store pre previous edge
05ED    8852          2377     MOV RCP_PREPREV_EDGE_L , R0 
05EF    8953          2378     MOV RCP_PREPREV_EDGE_H , R1 
                      2379     
                      2380     PCA_INT_FALL: 
                      2381     	; RC pulse edge was second, calculate new pulse length
05F1    C3            2382     	CLR	C
05F2    E8            2383     MOV A , R0 
05F3    9527          2384     	SUBB	A, RCP_PREV_EDGE_L	
05F5    F8            2385     MOV R0 , A 
05F6    E9            2386     MOV A , R1 
05F7    9528          2387     	SUBB	A, RCP_PREV_EDGE_H
05F9    F9            2388     MOV R1 , A 
05FA    307B02        2389     JNB FLAGS3 . 3 , ( $+5 ) 
05FD    C176          2390     	AJMP	PCA_INT_PWM_DIVIDE_DONE			; Yes - branch forward
                      2391     
05FF    307A02        2392     JNB FLAGS3 . 2 , ( $+5 ) 
0602    C16F          2393     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2394     
0604    E9            2395     MOV A , R1 
0605    C3            2396     	CLR	C
0606    13            2397     	RRC	A
0607    F9            2398     MOV R1 , A 
0608    E8            2399     MOV A , R0 
0609    13            2400     	RRC	A
060A    F8            2401     MOV R0 , A 
                      2402     
060B    307902        2403     JNB FLAGS3 . 1 , ( $+5 ) 
060E    C16F          2404     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2405     
0610    E9            2406     MOV A , R1 
0611    C3            2407     	CLR	C
0612    13            2408     	RRC	A
0613    F9            2409     MOV R1 , A 
0614    E8            2410     MOV A , R0 
0615    13            2411     	RRC	A
0616    F8            2412     MOV R0 , A 
                      2413     
0617    307802        2414     JNB FLAGS3 . 0 , ( $+5 ) 
061A    C16F          2415     	AJMP	PCA_INT_PWM_DIVIDE				; Yes - branch forward
                      2416     
061C    E9            2417     MOV A , R1 
061D    C3            2418     	CLR	C
061E    13            2419     	RRC	A
061F    FD            2420     MOV R5 , A 
0620    E8            2421     MOV A , R0 
0621    13            2422     	RRC	A
0622    FC            2423     MOV R4 , A 
                      2424     ; Check if full range is chosen
0623    7400          2425     MOV	A, #0						; Set 1000us as default minimum
0625    207E04        2426     JB FLAGS3 . 6 , PCA_INT_PPM_CALCULATE 
                      2427     
0628    C3            2428     	CLR	C							; Calculate "1000us" plus throttle minimum
0629    7898          2429     MOV R0 , # PGM_PPM_MIN_THROTTLE 
062B    E6            2430     MOV A , @ R0 
                      2431     
                      2432     PCA_INT_PPM_CALCULATE: 
062C    34FA          2433     	ADDC	A, #250
062E    FE            2434     MOV R6 , A 
062F    E4            2435     	CLR	A
0630    3400          2436     	ADDC	A, #0
0632    FF            2437     MOV R7 , A 
                      2438     
0633    EC            2439     MOV A , R4 
0634    C3            2440     	CLR	C
0635    9E            2441     SUBB A , R6 
0636    FC            2442     MOV R4 , A 
0637    ED            2443     MOV A , R5 
0638    9F            2444     SUBB A , R7 
0639    FD            2445     MOV R5 , A 
063A    5006          2446     	JNC	PCA_INT_PPM_NEG_CHECKED			; Is result negative?
                      2447     
063C    7800          2448     MOV R0 , # 0 
063E    7900          2449     MOV R1 , # 0 
0640    C176          2450     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2451     
                      2452     PCA_INT_PPM_NEG_CHECKED: 
0642    C3            2453     	CLR	C							; Check that RC pulse is within legal range (1000+4*250=2000)
0643    EC            2454     MOV A , R4 
0644    94FF          2455     SUBB A , # 255 
0646    ED            2456     MOV A , R5 
0647    9400          2457     	SUBB	A, #0
0649    4006          2458     	JC	PCA_INT_PPM_MAX_CHECKED
                      2459     
064B    78FF          2460     MOV R0 , # 255 
064D    7900          2461     MOV R1 , # 0 
064F    C176          2462     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2463     
                      2464     PCA_INT_PPM_MAX_CHECKED: 
0651    EC            2465     MOV A , R4 
0652    856BF0        2466     	MOV	B, PPM_THROTTLE_GAIN
0655    A4            2467     	MUL	AB
0656    C5F0          2468     	XCH	A, B
0658    A2F7          2469     	MOV	C, B.7						; Multiply result by 2 (unity gain is 128)
065A    33            2470     	RLC	A
065B    F8            2471     MOV R0 , A 
065C    7900          2472     MOV R1 , # 0 
065E    4009          2473     	JC	PCA_INT_PPM_LIMIT_AFTER_MULT
0660    C3            2474     	CLR	C							; Check that RC pulse is within legal range
0661    E8            2475     MOV A , R0 
0662    94FF          2476     SUBB A , # 255 
0664    E9            2477     MOV A , R1 
0665    9400          2478     	SUBB	A, #0
0667    400D          2479     	JC	PCA_INT_PWM_DIVIDE_DONE			
                      2480     
                      2481     PCA_INT_PPM_LIMIT_AFTER_MULT: 
0669    78FF          2482     MOV R0 , # 255 
066B    7900          2483     MOV R1 , # 0 
066D    C176          2484     	AJMP	PCA_INT_PWM_DIVIDE_DONE
                      2485     
                      2486     PCA_INT_PWM_DIVIDE: 
066F    E9            2487     MOV A , R1 
0670    C3            2488     	CLR	C
0671    13            2489     	RRC	A
0672    F9            2490     MOV R1 , A 
0673    E8            2491     MOV A , R0 
0674    13            2492     	RRC	A
0675    F8            2493     MOV R0 , A 
                      2494     
                      2495     PCA_INT_PWM_DIVIDE_DONE: 
                      2496     	; Check that RC pulse is within legal range
0676    C3            2497     	CLR	C
0677    E8            2498     MOV A , R0 
0678    94FF          2499     SUBB A , # 255 
067A    E9            2500     MOV A , R1 
067B    9400          2501     	SUBB	A, #0
067D    4002          2502     	JC	PCA_INT_LIMITED
                      2503     
067F    78FF          2504     MOV R0 , # 255 
                      2505     
                      2506     PCA_INT_LIMITED: 
                      2507     	; RC pulse value accepted
0681    8859          2508     MOV NEW_RCP , R0 
0683    206102        2509     JB FLAGS0 . 1 , ( $+5 ) 
0686    C190          2510     	AJMP	PCA_INT_SET_TIMEOUT			; No - skip measurements
                      2511     
0688    740F          2512     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
068A    F4            2513     	CPL	A
068B    552F          2514     	ANL	A, FLAGS3					; Clear all pwm frequency flags
068D    4B            2515     ORL A , R3 
068E    F52F          2516     	MOV	FLAGS3, A
                      2517     
                      2518     PCA_INT_SET_TIMEOUT: 
0690    752918        2519     MOV RCP_TIMEOUT_CNT , # 24 
0693    740F          2520     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
0695    552F          2521     	ANL	A, FLAGS3					; Check pwm frequency flags
0697    7003          2522     	JNZ	PCA_INT_PPM_TIMEOUT_SET		; If a flag is set - branch
                      2523     
0699    752903        2524     	MOV	RCP_TIMEOUT_CNT, #3			; No flag set means PPM. Set timeout count
                      2525     
                      2526     PCA_INT_PPM_TIMEOUT_SET: 
069C    D270          2527     SETB FLAGS2 . 0 
069E    306102        2528     JNB FLAGS0 . 1 , ( $+5 ) 
06A1    C1AC          2529     	AJMP PCA_INT_EXIT				; Yes - exit
                      2530     
06A3    740F          2531     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
06A5    552F          2532     	ANL	A, FLAGS3					; Check pwm frequency flags
06A7    6003          2533     	JZ	PCA_INT_EXIT				; If no flag is set (PPM) - branch
                      2534     
                      2535     	RCP_INT_DISABLE 				; Disable RC pulse interrupt
06A9    53DAFE        2535+1   ANL PCA0CPM0 , # 0FEH  ; INTERRUPT DISABLED
                      2536     
                      2537     PCA_INT_EXIT: 	; Exit interrupt routine	
06AC    752A06        2538     MOV RCP_SKIP_CNT , # 6 
06AF    740F          2539     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
06B1    552F          2540     	ANL	A, FLAGS3					; Check pwm frequency flags
06B3    7003          2541     	JNZ	($+5)					; If a flag is set (PWM) - branch
                      2542     
06B5    752A0A        2543     	MOV	RCP_SKIP_CNT, #10			; Load number of skips
                      2544     
06B8    D0F0          2545     	POP	B			; Restore preserved registers
06BA    D0E0          2546     	POP	ACC			
06BC    D0D0          2547     	POP	PSW
06BE    C2D3          2548     	CLR	PSW.3		; Select register bank 0 for main program routines	
06C0    D2AF          2549     	SETB	EA			; Enable all interrupts
06C2    32            2550     	RETI
                      2551     
                      2552     
                      2553     
                      2554     
                      2555     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2556     ;
                      2557     ; Wait xms ~(x*4*250)  (Different entry points)	
                      2558     ;
                      2559     ; No assumptions
                      2560     ;
                      2561     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2562     WAIT1MS: 	
06C3    7901          2563     MOV R1 , # 1 
06C5    C1DB          2564     	AJMP	WAITXMS_O
                      2565     
                      2566     WAIT3MS: 	
06C7    7903          2567     MOV R1 , # 3 
06C9    C1DB          2568     	AJMP	WAITXMS_O
                      2569     
                      2570     WAIT10MS: 	
06CB    790A          2571     MOV R1 , # 10 
06CD    C1DB          2572     	AJMP	WAITXMS_O
                      2573     
                      2574     WAIT30MS: 	
06CF    791E          2575     MOV R1 , # 30 
06D1    C1DB          2576     	AJMP	WAITXMS_O
                      2577     
                      2578     WAIT100MS: 	
06D3    7964          2579     MOV R1 , # 100 
06D5    C1DB          2580     	AJMP	WAITXMS_O
                      2581     
                      2582     WAIT200MS: 	
06D7    79C8          2583     MOV R1 , # 200 
06D9    C1DB          2584     	AJMP	WAITXMS_O
                      2585     
                      2586     WAITXMS_O: 	; Outer loop
06DB    7817          2587     MOV R0 , # 23 
                      2588     WAITXMS_M: 	; Middle loop
06DD    E4            2589     	CLR	A
06DE    D5E0FD        2590      	DJNZ	ACC, $	; Inner loop (42.7us - 1024 cycles)
06E1    D8FA          2591     DJNZ R0 , WAITXMS_M 
06E3    D9F6          2592     DJNZ R1 , WAITXMS_O 
06E5    22            2593     	RET
                      2594     
                      2595     
                      2596     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2597     ;
                      2598     ; Beeper routines (4 different entry points) 
                      2599     ;
                      2600     ; No assumptions
                      2601     ;
                      2602     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2603     BEEP_F1: 	; Entry point 1, load beeper frequency 1 settings
06E6    7A18          2604     MOV R2 , # 24 
06E8    7B78          2605     MOV R3 , # 120 
06EA    C1FE          2606     	AJMP	BEEP
                      2607     
                      2608     BEEP_F2: 	; Entry point 2, load beeper frequency 2 settings
06EC    7A15          2609     MOV R2 , # 21 
06EE    7B8C          2610     MOV R3 , # 140 
06F0    C1FE          2611     	AJMP	BEEP
                      2612     
                      2613     BEEP_F3: 	; Entry point 3, load beeper frequency 3 settings
06F2    7A12          2614     MOV R2 , # 18 
06F4    7BB4          2615     MOV R3 , # 180 
06F6    C1FE          2616     	AJMP	BEEP
                      2617     
                      2618     BEEP_F4: 	; Entry point 4, load beeper frequency 4 settings
06F8    7A0F          2619     MOV R2 , # 15 
06FA    7BC8          2620     MOV R3 , # 200 
06FC    C1FE          2621     	AJMP	BEEP
                      2622     
                      2623     BEEP: 	; Beep loop start
06FE    AC26          2624     MOV R4 , CURRENT_PWM_LIMITED 
0700    752601        2625     	MOV	CURRENT_PWM_LIMITED, #1		; Set to a nonzero value
0703    7902          2626     MOV R1 , # 2 
                      2627     BEEP_ONOFF: 
0705    B27C          2628     CPL FLAGS3 . 4 
0707    E4            2629     	CLR	A
                      2630     	BPFET_ON			; BpFET on
0708    D294          2630+1   SETB P1 . 4 
070A    D5E0FD        2631     	DJNZ	ACC, $		; Allow some time after pfet is turned on
                      2632     	; Turn on nfet
070D    207C02        2633     JB FLAGS3 . 4 , ( $+5 ) 
0710    D287          2634     SETB P0 . 7 
0712    307C02        2635     JNB FLAGS3 . 4 , ( $+5 ) 
0715    D293          2636     SETB P1 . 3 
                      2637     	ANFET_ON			; AnFET on
0717    E526          2637+1   MOV A , CURRENT_PWM_LIMITED 
0719    600A          2637+1   JZ ( $+12 ) 
071B    207C02        2637+1   JB FLAGS3 . 4 , ( $+5 ) 
071E    C297          2637+1   CLR P1 . 7 
0720    307C02        2637+1   JNB FLAGS3 . 4 , ( $+5 ) 
0723    C293          2637+1   CLR P1 . 3 
0725    E56C          2638     	MOV	A, BEEP_STRENGTH
0727    D5E0FD        2639     	DJNZ	ACC, $		
                      2640     	; Turn off nfet
                      2641     	ANFET_OFF			; AnFET off
072A    207C02        2641+1   JB FLAGS3 . 4 , ( $+5 ) 
072D    D297          2641+1   SETB P1 . 7 
072F    307C02        2641+1   JNB FLAGS3 . 4 , ( $+5 ) 
0732    D293          2641+1   SETB P1 . 3 
0734    7496          2642     	MOV	A, #150		; 25s off
0736    D5E0FD        2643     	DJNZ	ACC, $		
0739    D9CA          2644     DJNZ R1 , BEEP_ONOFF 
                      2645     	; Copy variable
073B    EA            2646     MOV A , R2 
073C    F8            2647     MOV R0 , A 
                      2648     BEEP_OFF: 		; Fets off loop
073D    D5E0FD        2649     	DJNZ	ACC, $
0740    D8FB          2650     DJNZ R0 , BEEP_OFF 
0742    DBBA          2651     DJNZ R3 , BEEP 
                      2652     	BPFET_OFF			; BpFET off
0744    C294          2652+1   CLR P1 . 4 
0746    8C26          2653     MOV CURRENT_PWM_LIMITED , R4 
0748    22            2654     	RET
                      2655     
                      2656     
                      2657     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2658     ;
                      2659     ; Multiplication 16bit signed by 8bit unsigned
                      2660     ;
                      2661     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                      2662     ; Result will be in Temp2/Temp1. Result will divided by 16
                      2663     ;
                      2664     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2665     MULT_S16_BY_U8_DIV_16: 
0749    E8            2666     MOV A , R0 
074A    89F0          2667     MOV B , R1 
074C    8A20          2668     MOV BIT_ACCESS , R2 
074E    D2D4          2669     	SETB	PSW.4		; Select register bank 2 for math routines
0750    F8            2670     MOV R0 , A 
0751    A9F0          2671     MOV R1 , B 
0753    7B00          2672     MOV R3 , # 0 
0755    30F70B        2673     	JNB	B.7, MULT_S16_BY_U16_POSITIVE	
                      2674     
0758    7BFF          2675     MOV R3 , # 0FFH 
075A    F4            2676     	CPL	A
075B    2401          2677     	ADD	A, #1
075D    F8            2678     MOV R0 , A 
075E    E9            2679     MOV A , R1 
075F    F4            2680     	CPL	A
0760    3400          2681     	ADDC	A, #0
0762    F9            2682     MOV R1 , A 
                      2683     MULT_S16_BY_U16_POSITIVE: 
0763    E8            2684     MOV A , R0 
0764    8520F0        2685     	MOV	B, BIT_ACCESS
0767    A4            2686     	MUL	AB
0768    ADF0          2687     MOV R5 , B 
076A    F8            2688     MOV R0 , A 
076B    E9            2689     MOV A , R1 
076C    8520F0        2690     	MOV	B, BIT_ACCESS
076F    A4            2691     	MUL	AB
0770    AFF0          2692     MOV R7 , B 
0772    FE            2693     MOV R6 , A 
0773    C3            2694     	CLR	C			; Add up
0774    ED            2695     MOV A , R5 
0775    3E            2696     ADDC A , R6 
0776    F9            2697     MOV R1 , A 
0777    7400          2698     	MOV	A, #0
0779    3F            2699     ADDC A , R7 
077A    FA            2700     MOV R2 , A 
077B    7C04          2701     MOV R4 , # 4 
                      2702     MULT_S16_BY_U16_DIV_LOOP: 
077D    C3            2703     	CLR	C			; Rotate right three places (decimal point at 8)
077E    EA            2704     MOV A , R2 
077F    13            2705     	RRC	A
0780    FA            2706     MOV R2 , A 
0781    E9            2707     MOV A , R1 
0782    13            2708     	RRC	A
0783    F9            2709     MOV R1 , A 
0784    E8            2710     MOV A , R0 
0785    13            2711     	RRC	A
0786    F8            2712     MOV R0 , A 
0787    1C            2713     DEC R4 
0788    EC            2714     MOV A , R4 
0789    70F2          2715     	JNZ	MULT_S16_BY_U16_DIV_LOOP
                      2716     
078B    8BF0          2717     MOV B , R3 
078D    30F70A        2718     	JNB	B.7, MULT_S16_BY_U16_EXIT	
                      2719     
0790    E8            2720     MOV A , R0 
0791    F4            2721     	CPL	A
0792    2401          2722     	ADD	A, #1
0794    F8            2723     MOV R0 , A 
0795    E9            2724     MOV A , R1 
0796    F4            2725     	CPL	A
0797    3400          2726     	ADDC	A, #0
0799    F9            2727     MOV R1 , A 
                      2728     
                      2729     MULT_S16_BY_U16_EXIT: 
079A    E8            2730     MOV A , R0 
079B    89F0          2731     MOV B , R1 
079D    C2D4          2732     	CLR	PSW.4		; Select normal register bank
079F    F8            2733     MOV R0 , A 
07A0    A9F0          2734     MOV R1 , B 
07A2    22            2735     	RET
                      2736     
                      2737     
                      2738     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2739     ;
                      2740     ; Calculate governor routines
                      2741     ;
                      2742     ; No assumptions
                      2743     ;
                      2744     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                      2745     ; The governor task is split into several routines in order to distribute processing time
                      2746     ;
                      2747     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      2748     ; First governor routine - calculate governor target
                      2749     CALC_GOVERNOR_TARGET: 
07A3    7884          2750     MOV R0 , # PGM_GOV_MODE 
07A5    B60403        2751     CJNE @ R0 , # 4 , GOVERNOR_SPEED_CHECK 
07A8    020822        2752     	JMP	CALC_GOVERNOR_TARGET_EXIT	; No
                      2753     
                      2754     GOVERNOR_SPEED_CHECK: 
                      2755     	; Stop governor for stop RC pulse	
07AB    C3            2756     	CLR	C
07AC    E559          2757     	MOV	A, NEW_RCP				; Check RC pulse against stop value
07AE    9401          2758     SUBB A , # 1 
07B0    401A          2759     	JC	GOVERNOR_DEACTIVATE			; Yes - deactivate
                      2760     
                      2761     	; Skip speed check if governor is alrady active
07B2    E549          2762     	MOV	A, GOV_ACTIVE
07B4    702C          2763     	JNZ	GOVERNOR_TARGET_CALC
                      2764     
                      2765     	; Check speed (do not run governor for low speeds)
07B6    7805          2766     MOV R0 , # 05H 
07B8    C3            2767     	CLR	C
07B9    7985          2768     MOV R1 , # PGM_GOV_RANGE 
07BB    E7            2769     MOV A , @ R1 
07BC    9402          2770     	SUBB	A, #2
07BE    7002          2771     	JNZ	($+4)
                      2772     
07C0    7812          2773     MOV R0 , # 12H 
                      2774     
07C2    C3            2775     	CLR	C
07C3    E53C          2776     	MOV	A, COMM_PERIOD4X_L
07C5    9400          2777     	SUBB	A, #00H
07C7    E53D          2778     	MOV	A, COMM_PERIOD4X_H
07C9    98            2779     SUBB A , R0 
07CA    4013          2780     	JC	GOVERNOR_ACTIVATE			; If speed above min limit  - run governor
                      2781     
                      2782     GOVERNOR_DEACTIVATE: 
07CC    852224        2783     	MOV	CURRENT_PWM, REQUESTED_PWM	; Set current pwm to requested
07CF    E4            2784     	CLR	A
07D0    F540          2785     	MOV	GOV_TARGET_L, A			; Set target to zero
07D2    F541          2786     	MOV	GOV_TARGET_H, A
07D4    F542          2787     	MOV	GOV_INTEGRAL_L, A			; Set integral to zero
07D6    F543          2788     	MOV	GOV_INTEGRAL_H, A
07D8    F544          2789     	MOV	GOV_INTEGRAL_X, A
07DA    F549          2790     	MOV	GOV_ACTIVE, A
07DC    020822        2791     	JMP	CALC_GOVERNOR_TARGET_EXIT
                      2792     
                      2793     GOVERNOR_ACTIVATE: 
07DF    754901        2794     	MOV	GOV_ACTIVE, #1
                      2795     GOVERNOR_TARGET_CALC: 
                      2796     	; Governor calculations
07E2    C3            2797     	CLR	C
07E3    E7            2798     MOV A , @ R1 
07E4    9402          2799     	SUBB	A, #2
07E6    601B          2800     	JZ	CALC_GOVERNOR_TARGET_LOW
                      2801     
07E8    E523          2802     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
07EA    F4            2803     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      2804     	; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
07EB    33            2805     	RLC	A					; Msb to carry
07EC    33            2806     	RLC	A					; To bit0
07ED    F9            2807     MOV R1 , A 
07EE    13            2808     	RRC	A					
07EF    F8            2809     MOV R0 , A 
07F0    E9            2810     MOV A , R1 
07F1    5401          2811     	ANL	A, #01H				; Calculate H byte
07F3    04            2812     	INC	A					; Add 1
07F4    F9            2813     MOV R1 , A 
07F5    E8            2814     MOV A , R0 
07F6    54FE          2815     	ANL	A, #0FEH				; Calculate L byte
07F8    C3            2816     	CLR	C
07F9    9440          2817     	SUBB	A, #40H				; Subtract 0.25
07FB    F8            2818     MOV R0 , A 
07FC    E9            2819     MOV A , R1 
07FD    9400          2820     	SUBB	A, #0
07FF    F9            2821     MOV R1 , A 
0800    02081E        2822     	JMP	CALC_GOVERNOR_STORE_TARGET
                      2823     
                      2824     CALC_GOVERNOR_TARGET_LOW: 
0803    E523          2825     	MOV	A, GOVERNOR_REQ_PWM		; Load governor requested pwm
0805    F4            2826     	CPL	A					; Calculate 255-pwm (invert pwm) 
                      2827     	; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
0806    33            2828     	RLC	A					; Msb to carry
0807    33            2829     	RLC	A					; To bit0
0808    33            2830     	RLC	A					; To bit1
0809    33            2831     	RLC	A					; To bit2
080A    F9            2832     MOV R1 , A 
080B    13            2833     	RRC	A					
080C    F8            2834     MOV R0 , A 
080D    E9            2835     MOV A , R1 
080E    5407          2836     	ANL	A, #07H				; Calculate H byte
0810    04            2837     	INC	A					; Add 1
0811    04            2838     	INC	A					; Add 1 more
0812    F9            2839     MOV R1 , A 
0813    E8            2840     MOV A , R0 
0814    54F8          2841     	ANL	A, #0F8H				; Calculate L byte
0816    C3            2842     	CLR	C
0817    9440          2843     	SUBB	A, #40H				; Subtract 0.25
0819    F8            2844     MOV R0 , A 
081A    E9            2845     MOV A , R1 
081B    9400          2846     	SUBB	A, #0
081D    F9            2847     MOV R1 , A 
                      2848     
                      2849     CALC_GOVERNOR_STORE_TARGET: 
                      2850     	; Store governor target
081E    8840          2851     MOV GOV_TARGET_L , R0 
0820    8941          2852     MOV GOV_TARGET_H , R1 
                      2853     CALC_GOVERNOR_TARGET_EXIT: 
0822    22            2854     	RET						
                      2855     
                      2856     
                      2857     ; Second governor routine - calculate governor proportional error
                      2858     CALC_GOVERNOR_PROP_ERROR: 
                      2859     	; Exit if governor is inactive
0823    E549          2860     	MOV	A, GOV_ACTIVE
0825    603C          2861     	JZ	CALC_GOVERNOR_PROP_ERROR_EXIT
                      2862     
                      2863     	; Load comm period and divide by 2
0827    C3            2864     	CLR	C
0828    E53D          2865     	MOV	A, COMM_PERIOD4X_H
082A    13            2866     	RRC	A
082B    F9            2867     MOV R1 , A 
082C    E53C          2868     	MOV	A, COMM_PERIOD4X_L
082E    13            2869     	RRC	A
082F    F8            2870     MOV R0 , A 
                      2871     	; Calculate error
0830    C3            2872     	CLR	C
0831    E540          2873     	MOV	A, GOV_TARGET_L
0833    98            2874     SUBB A , R0 
0834    F8            2875     MOV R0 , A 
0835    E541          2876     	MOV	A, GOV_TARGET_H
0837    99            2877     SUBB A , R1 
0838    F9            2878     MOV R1 , A 
                      2879     	; Check error and limit (to low byte)
0839    30E70C        2880     	JNB	ACC.7, GOVERNOR_CHECK_PROP_LIMIT_POS	; Check sign bit
                      2881     
083C    C3            2882     	CLR	C
083D    E8            2883     MOV A , R0 
083E    9480          2884     	SUBB	A, #80H					; Is error too negative?
0840    E9            2885     MOV A , R1 
0841    94FF          2886     	SUBB	A, #0FFH
0843    4016          2887     	JC	GOVERNOR_LIMIT_PROP_ERROR_NEG	; Yes - limit
0845    02085F        2888     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2889     
                      2890     GOVERNOR_CHECK_PROP_LIMIT_POS: 
0848    C3            2891     	CLR	C
0849    E8            2892     MOV A , R0 
084A    947F          2893     	SUBB	A, #7FH					; Is error too positive?
084C    E9            2894     MOV A , R1 
084D    9400          2895     	SUBB	A, #00H
084F    5003          2896     	JNC	GOVERNOR_LIMIT_PROP_ERROR_POS	; Yes - limit
0851    02085F        2897     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2898     
                      2899     GOVERNOR_LIMIT_PROP_ERROR_POS: 
0854    787F          2900     MOV R0 , # 7FH 
0856    7900          2901     MOV R1 , # 00H 
0858    02085F        2902     	JMP	GOVERNOR_STORE_PROP_ERROR
                      2903     
                      2904     GOVERNOR_LIMIT_PROP_ERROR_NEG: 
085B    7880          2905     MOV R0 , # 80H 
085D    79FF          2906     MOV R1 , # 0FFH 
                      2907     
                      2908     GOVERNOR_STORE_PROP_ERROR: 
                      2909     	; Store proportional
085F    8845          2910     MOV GOV_PROPORTIONAL_L , R0 
0861    8946          2911     MOV GOV_PROPORTIONAL_H , R1 
                      2912     CALC_GOVERNOR_PROP_ERROR_EXIT: 
0863    22            2913     	RET						
                      2914     
                      2915     
                      2916     ; Third governor routine - calculate governor integral error
                      2917     CALC_GOVERNOR_INT_ERROR: 
                      2918     	; Exit if governor is inactive
0864    E549          2919     	MOV	A, GOV_ACTIVE
0866    6055          2920     	JZ	CALC_GOVERNOR_INT_ERROR_EXIT
                      2921     
                      2922     	; Add proportional to integral
0868    E542          2923     	MOV	A, GOV_INTEGRAL_L
086A    2545          2924     	ADD	A, GOV_PROPORTIONAL_L
086C    F8            2925     MOV R0 , A 
086D    E543          2926     	MOV	A, GOV_INTEGRAL_H
086F    3546          2927     	ADDC	A, GOV_PROPORTIONAL_H
0871    F9            2928     MOV R1 , A 
0872    E544          2929     	MOV	A, GOV_INTEGRAL_X
0874    3546          2930     	ADDC	A, GOV_PROPORTIONAL_H
0876    FA            2931     MOV R2 , A 
                      2932     	; Check integral and limit
0877    30E709        2933     	JNB	ACC.7, GOVERNOR_CHECK_INT_LIMIT_POS	; Check sign bit
                      2934     
087A    C3            2935     	CLR	C
087B    EA            2936     MOV A , R2 
087C    94F0          2937     	SUBB	A, #0F0H					; Is error too negative?
087E    4015          2938     	JC	GOVERNOR_LIMIT_INT_ERROR_NEG	; Yes - limit
0880    02089B        2939     	JMP	GOVERNOR_CHECK_PWM
                      2940     
                      2941     GOVERNOR_CHECK_INT_LIMIT_POS: 
0883    C3            2942     	CLR	C
0884    EA            2943     MOV A , R2 
0885    940F          2944     	SUBB	A, #0FH					; Is error too positive?
0887    5003          2945     	JNC	GOVERNOR_LIMIT_INT_ERROR_POS	; Yes - limit
0889    02089B        2946     	JMP	GOVERNOR_CHECK_PWM
                      2947     
                      2948     GOVERNOR_LIMIT_INT_ERROR_POS: 
088C    78FF          2949     MOV R0 , # 0FFH 
088E    79FF          2950     MOV R1 , # 0FFH 
0890    7A0F          2951     MOV R2 , # 0FH 
0892    02089B        2952     	JMP	GOVERNOR_CHECK_PWM
                      2953     
                      2954     GOVERNOR_LIMIT_INT_ERROR_NEG: 
0895    7800          2955     MOV R0 , # 00H 
0897    7900          2956     MOV R1 , # 00H 
0899    7AF0          2957     MOV R2 , # 0F0H 
                      2958     
                      2959     GOVERNOR_CHECK_PWM: 
                      2960     	; Check current pwm
089B    C3            2961     	CLR	C
089C    E524          2962     	MOV	A, CURRENT_PWM
089E    955D          2963     	SUBB	A, PWM_LIMIT				; Is current pwm above pwm limit?
08A0    5009          2964     	JNC	GOVERNOR_INT_MAX_PWM		; Yes - branch
                      2965     
08A2    C3            2966     	CLR	C
08A3    E524          2967     	MOV	A, CURRENT_PWM
08A5    9401          2968     	SUBB	A, #1					; Is current below pwm min?
08A7    4009          2969     	JC	GOVERNOR_INT_MIN_PWM		; Yes - branch
08A9    01B7          2970     	AJMP	GOVERNOR_STORE_INT_ERROR		; No - store integral error
                      2971     
                      2972     GOVERNOR_INT_MAX_PWM: 
08AB    E545          2973     	MOV	A, GOV_PROPORTIONAL_L
08AD    20E70D        2974     	JB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error negative - branch (high byte is always zero)
08B0    01B7          2975     	AJMP	GOVERNOR_STORE_INT_ERROR		; Positive - store integral error
                      2976     
                      2977     GOVERNOR_INT_MIN_PWM: 
08B2    E545          2978     	MOV	A, GOV_PROPORTIONAL_L
08B4    30E706        2979     	JNB	ACC.7, CALC_GOVERNOR_INT_ERROR_EXIT	; Is proportional error positive - branch (high byte is always zero)
                      2980     
                      2981     GOVERNOR_STORE_INT_ERROR: 
                      2982     	; Store integral
08B7    8842          2983     MOV GOV_INTEGRAL_L , R0 
08B9    8943          2984     MOV GOV_INTEGRAL_H , R1 
08BB    8A44          2985     MOV GOV_INTEGRAL_X , R2 
                      2986     CALC_GOVERNOR_INT_ERROR_EXIT: 
08BD    22            2987     	RET						
                      2988     
                      2989     
                      2990     ; Fourth governor routine - calculate governor proportional correction
                      2991     CALC_GOVERNOR_PROP_CORRECTION: 
                      2992     	; Exit if governor is inactive
08BE    E549          2993     	MOV	A, GOV_ACTIVE
08C0    7003          2994     	JNZ	CALC_GOVERNOR_PROP_CORR
08C2    02092A        2995     	JMP	CALC_GOVERNOR_PROP_CORR_EXIT
                      2996     
                      2997     CALC_GOVERNOR_PROP_CORR: 
                      2998     	; Load proportional gain
08C5    7882          2999     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
08C7    E6            3000     MOV A , @ R0 
08C8    FA            3001     MOV R2 , A 
                      3002     	; Load proportional
08C9    854520        3003     	MOV	BIT_ACCESS, GOV_PROPORTIONAL_L	; Only low byte required (high byte is always zero)
08CC    E4            3004     	CLR	A
08CD    300701        3005     	JNB	BIT_ACCESS.7, ($+4)			; Sign extend high byte
08D0    F4            3006     	CPL	A
08D1    F9            3007     MOV R1 , A 
08D2    C3            3008     	CLR	C
08D3    E545          3009     	MOV	A, GOV_PROPORTIONAL_L		; Nominal multiply by 2
08D5    33            3010     	RLC	A
08D6    F8            3011     MOV R0 , A 
08D7    E9            3012     MOV A , R1 
08D8    33            3013     	RLC	A
08D9    F9            3014     MOV R1 , A 
                      3015     	; Apply gain
08DA    120749        3016     	CALL	MULT_S16_BY_U8_DIV_16
                      3017     	; Check error and limit (to low byte)
08DD    E9            3018     MOV A , R1 
08DE    30E70B        3019     	JNB	ACC.7, GOVERNOR_CHECK_PROP_CORR_LIMIT_POS	; Check sign bit
                      3020     
08E1    C3            3021     	CLR	C
08E2    E8            3022     MOV A , R0 
08E3    9480          3023     	SUBB	A, #80H					; Is error too negative?
08E5    E9            3024     MOV A , R1 
08E6    94FF          3025     	SUBB	A, #0FFH
08E8    4013          3026     	JC	GOVERNOR_LIMIT_PROP_CORR_NEG	; Yes - limit
08EA    2101          3027     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3028     
                      3029     GOVERNOR_CHECK_PROP_CORR_LIMIT_POS: 
08EC    C3            3030     	CLR	C
08ED    E8            3031     MOV A , R0 
08EE    947F          3032     	SUBB	A, #7FH					; Is error too positive?
08F0    E9            3033     MOV A , R1 
08F1    9400          3034     	SUBB	A, #00H
08F3    5002          3035     	JNC	GOVERNOR_LIMIT_PROP_CORR_POS	; Yes - limit
08F5    2101          3036     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3037     
                      3038     GOVERNOR_LIMIT_PROP_CORR_POS: 
08F7    787F          3039     MOV R0 , # 7FH 
08F9    7900          3040     MOV R1 , # 00H 
08FB    2101          3041     	AJMP	GOVERNOR_APPLY_PROP_CORR
                      3042     
                      3043     GOVERNOR_LIMIT_PROP_CORR_NEG: 
08FD    7880          3044     MOV R0 , # 80H 
08FF    79FF          3045     MOV R1 , # 0FFH 
                      3046     
                      3047     GOVERNOR_APPLY_PROP_CORR: 
                      3048     	; Test proportional sign
0901    E8            3049     MOV A , R0 
0902    20E715        3050     	JB	ACC.7, GOVERNOR_CORR_NEG_PROP	; If proportional negative - go to correct negative
                      3051     
                      3052     	; Subtract positive proportional
0905    C3            3053     	CLR	C
0906    E523          3054     	MOV	A, GOVERNOR_REQ_PWM
0908    98            3055     SUBB A , R0 
0909    F8            3056     MOV R0 , A 
                      3057     	; Check result
090A    4009          3058     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Is result negative?
                      3059     
090C    C3            3060     	CLR	C
090D    E8            3061     MOV A , R0 
090E    9401          3062     	SUBB	A, #1
0910    4003          3063     	JC	GOVERNOR_CORR_PROP_MIN_PWM	; Yes
0912    020928        3064     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3065     
                      3066     GOVERNOR_CORR_PROP_MIN_PWM: 
0915    7801          3067     MOV R0 , # 1 
0917    020928        3068     	JMP	GOVERNOR_STORE_PROP_CORR
                      3069     
                      3070     GOVERNOR_CORR_NEG_PROP: 
                      3071     	; Add negative proportional
091A    E8            3072     MOV A , R0 
091B    F4            3073     	CPL	A
091C    2401          3074     	ADD	A, #1
091E    2523          3075     	ADD	A, GOVERNOR_REQ_PWM
0920    F8            3076     MOV R0 , A 
                      3077     	; Check result
0921    4003          3078     	JC	GOVERNOR_CORR_PROP_MAX_PWM	; Is result above max?
0923    020928        3079     	JMP	GOVERNOR_STORE_PROP_CORR		; No - store proportional correction
                      3080     
                      3081     GOVERNOR_CORR_PROP_MAX_PWM: 
0926    78FF          3082     MOV R0 , # 255 
                      3083     GOVERNOR_STORE_PROP_CORR: 
                      3084     	; Store proportional pwm
0928    8847          3085     MOV GOV_PROP_PWM , R0 
                      3086     CALC_GOVERNOR_PROP_CORR_EXIT: 
092A    22            3087     	RET
                      3088     
                      3089     
                      3090     ; Fifth governor routine - calculate governor integral correction
                      3091     CALC_GOVERNOR_INT_CORRECTION: 
                      3092     	; Exit if governor is inactive
092B    E549          3093     	MOV	A, GOV_ACTIVE
092D    7003          3094     	JNZ	CALC_GOVERNOR_INT_CORR
092F    020990        3095     	JMP	CALC_GOVERNOR_INT_CORR_EXIT
                      3096     
                      3097     CALC_GOVERNOR_INT_CORR: 
                      3098     	; Load integral gain
0932    7883          3099     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
0934    E6            3100     MOV A , @ R0 
0935    FA            3101     MOV R2 , A 
                      3102     	; Load integral
0936    A843          3103     MOV R0 , GOV_INTEGRAL_H 
0938    A944          3104     MOV R1 , GOV_INTEGRAL_X 
                      3105     	; Apply gain
093A    120749        3106     	CALL	MULT_S16_BY_U8_DIV_16
                      3107     	; Check integral and limit
093D    E9            3108     MOV A , R1 
093E    30E70C        3109     	JNB	ACC.7, GOVERNOR_CHECK_INT_CORR_LIMIT_POS	; Check sign bit
                      3110     
0941    C3            3111     	CLR	C
0942    E8            3112     MOV A , R0 
0943    9400          3113     	SUBB	A, #00H					; Is integral too negative?
0945    E9            3114     MOV A , R1 
0946    94FF          3115     	SUBB	A, #0FFH
0948    4016          3116     	JC	GOVERNOR_LIMIT_INT_CORR_NEG	; Yes - limit
094A    020964        3117     	JMP	GOVERNOR_APPLY_INT_CORR
                      3118     
                      3119     GOVERNOR_CHECK_INT_CORR_LIMIT_POS: 
094D    C3            3120     	CLR	C
094E    E8            3121     MOV A , R0 
094F    94FF          3122     	SUBB	A, #0FFH					; Is integral too positive?
0951    E9            3123     MOV A , R1 
0952    9400          3124     	SUBB	A, #00H
0954    5003          3125     	JNC	GOVERNOR_LIMIT_INT_CORR_POS	; Yes - limit
0956    020964        3126     	JMP	GOVERNOR_APPLY_INT_CORR
                      3127     
                      3128     GOVERNOR_LIMIT_INT_CORR_POS: 
0959    78FF          3129     MOV R0 , # 0FFH 
095B    7900          3130     MOV R1 , # 00H 
095D    020964        3131     	JMP	GOVERNOR_APPLY_INT_CORR
                      3132     
                      3133     GOVERNOR_LIMIT_INT_CORR_NEG: 
0960    7800          3134     MOV R0 , # 00H 
0962    79FF          3135     MOV R1 , # 0FFH 
                      3136     
                      3137     GOVERNOR_APPLY_INT_CORR: 
                      3138     	; Test integral sign
0964    E9            3139     MOV A , R1 
0965    20E715        3140     	JB	ACC.7, GOVERNOR_CORR_NEG_INT	; If integral negative - go to correct negative
                      3141     
                      3142     	; Subtract positive integral
0968    C3            3143     	CLR	C
0969    E547          3144     	MOV	A, GOV_PROP_PWM
096B    98            3145     SUBB A , R0 
096C    F8            3146     MOV R0 , A 
                      3147     	; Check result
096D    4009          3148     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Is result negative?
                      3149     
096F    C3            3150     	CLR	C
0970    E8            3151     MOV A , R0 
0971    9401          3152     	SUBB	A, #1
0973    4003          3153     	JC	GOVERNOR_CORR_INT_MIN_PWM	; Yes
0975    02098E        3154     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3155     
                      3156     GOVERNOR_CORR_INT_MIN_PWM: 
0978    7801          3157     MOV R0 , # 1 
097A    02098E        3158     	JMP	GOVERNOR_STORE_INT_CORR
                      3159     
                      3160     GOVERNOR_CORR_NEG_INT: 
                      3161     	; Add negative integral
097D    E8            3162     MOV A , R0 
097E    F4            3163     	CPL	A
097F    2401          3164     	ADD	A, #1
0981    2547          3165     	ADD	A, GOV_PROP_PWM
0983    F8            3166     MOV R0 , A 
0984    E9            3167     MOV A , R1 
0985    3400          3168     	ADDC	A, #0
                      3169     	; Check result
0987    4003          3170     	JC	GOVERNOR_CORR_INT_MAX_PWM	; Is result above max?
0989    02098E        3171     	JMP	GOVERNOR_STORE_INT_CORR		; No - store correction
                      3172     
                      3173     GOVERNOR_CORR_INT_MAX_PWM: 
098C    78FF          3174     MOV R0 , # 255 
                      3175     GOVERNOR_STORE_INT_CORR: 
                      3176     	; Store current pwm
098E    8824          3177     MOV CURRENT_PWM , R0 
                      3178     CALC_GOVERNOR_INT_CORR_EXIT: 
0990    22            3179     	RET
                      3180     
                      3181     
                      3182     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3183     ;
                      3184     ; Measure lipo cells
                      3185     ;
                      3186     ; No assumptions
                      3187     ;
                      3188     ; Measure voltage and calculate lipo cells
                      3189     ;
                      3190     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3191     MEASURE_LIPO_CELLS: 
                      3192     IF MODE == 1	; Tail
                               	; If tail, then exit if voltage compensation is not enabled
                               	CLR	C
                               	MOV	TEMP1, #PGM_VOLT_COMP
                               	MOV	A, @TEMP1				
                               	SUBB	A, #2
                               	JNC	MEASURE_LIPO_START
                               	JMP	MEASURE_LIPO_EXIT
                               ENDIF
                      3201     MEASURE_LIPO_START: 
                      3202     	; Load programmed low voltage limit
0991    7886          3203     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
0993    E6            3204     MOV A , @ R0 
0994    F520          3205     	MOV	BIT_ACCESS, A					; Store in Bit_Access
                      3206     	; Set commutation to BpFET on
0996    120F3D        3207     	CALL	COMM5COMM6			
                      3208     	; Start adc
                      3209     	START_ADC 
0999    75E890        3209+1   MOV ADC0CN , # 90H  ; ADC START
                      3210     	; Wait for ADC conversion to complete
                      3211     	GET_ADC_STATUS 
099C    E5E8          3211+1   MOV A , ADC0CN 
099E    20ECF0        3212     	JB	AD0BUSY, MEASURE_LIPO_CELLS
                      3213     	; Read ADC result
                      3214     	READ_ADC_RESULT
09A1    A8BD          3214+1   MOV R0 , ADC0L 
09A3    A9BE          3214+1   MOV R1 , ADC0H 
                      3215     	; Stop ADC
                      3216     	STOP_ADC
                      3217     	; Switch power off
09A5    120FE1        3218     	CALL	SWITCH_POWER_OFF		
                      3219     	; Set limit step
09A8    756755        3220     MOV LIPO_ADC_LIMIT_L , # 85 
09AB    756800        3221     MOV LIPO_ADC_LIMIT_H , # 0 
09AE    C3            3222     	CLR	C
09AF    7400          3223     MOV A , # 0 
09B1    13            3224     	RRC	A
09B2    FD            3225     MOV R5 , A 
09B3    7455          3226     MOV A , # 85 
09B5    13            3227     	RRC	A
09B6    FC            3228     MOV R4 , A 
09B7    C3            3229     	CLR	C
09B8    7455          3230     MOV A , # 85 
09BA    3C            3231     ADDC A , R4 
09BB    FC            3232     MOV R4 , A 
09BC    7400          3233     MOV A , # 0 
09BE    3D            3234     ADDC A , R5 
09BF    FD            3235     MOV R5 , A 
                      3236     	; Check voltage against 2S lower limit
09C0    EC            3237     MOV A , R4 
09C1    FA            3238     MOV R2 , A 
09C2    ED            3239     MOV A , R5 
09C3    FB            3240     MOV R3 , A 
09C4    C3            3241     	CLR	C
09C5    E8            3242     MOV A , R0 
09C6    9A            3243     SUBB A , R2 
09C7    E9            3244     MOV A , R1 
09C8    9B            3245     SUBB A , R3 
09C9    403E          3246     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3247     
                      3248     	; Set 2S voltage limit
09CB    E567          3249     	MOV	A, LIPO_ADC_LIMIT_L		
09CD    2455          3250     ADD A , # 85 
09CF    F567          3251     	MOV	LIPO_ADC_LIMIT_L, A
09D1    E568          3252     	MOV	A, LIPO_ADC_LIMIT_H		
09D3    3400          3253     ADDC A , # 0 
09D5    F568          3254     	MOV	LIPO_ADC_LIMIT_H, A
                      3255     	; Set 3S lower limit
09D7    EA            3256     MOV A , R2 
09D8    2C            3257     ADD A , R4 
09D9    FA            3258     MOV R2 , A 
09DA    EB            3259     MOV A , R3 
09DB    3D            3260     ADDC A , R5 
09DC    FB            3261     MOV R3 , A 
                      3262     	; Check voltage against 3S lower limit
09DD    C3            3263     	CLR	C
09DE    E8            3264     MOV A , R0 
09DF    9A            3265     SUBB A , R2 
09E0    E9            3266     MOV A , R1 
09E1    9B            3267     SUBB A , R3 
09E2    4025          3268     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3269     
                      3270     	; Set 3S voltage limit
09E4    E567          3271     	MOV	A, LIPO_ADC_LIMIT_L		
09E6    2455          3272     ADD A , # 85 
09E8    F567          3273     	MOV	LIPO_ADC_LIMIT_L, A
09EA    E568          3274     	MOV	A, LIPO_ADC_LIMIT_H		
09EC    3400          3275     ADDC A , # 0 
09EE    F568          3276     	MOV	LIPO_ADC_LIMIT_H, A
                      3277     	; Set 4S lower limit
09F0    EA            3278     MOV A , R2 
09F1    2C            3279     ADD A , R4 
09F2    FA            3280     MOV R2 , A 
09F3    EB            3281     MOV A , R3 
09F4    3D            3282     ADDC A , R5 
09F5    FB            3283     MOV R3 , A 
                      3284     	; Check voltage against 4S lower limit
09F6    C3            3285     	CLR	C
09F7    E8            3286     MOV A , R0 
09F8    9A            3287     SUBB A , R2 
09F9    E9            3288     MOV A , R1 
09FA    9B            3289     SUBB A , R3 
09FB    400C          3290     	JC	MEASURE_LIPO_ADJUST		; No - branch
                      3291     
                      3292     	; Set 4S voltage limit
09FD    E567          3293     	MOV	A, LIPO_ADC_LIMIT_L		
09FF    2455          3294     ADD A , # 85 
0A01    F567          3295     	MOV	LIPO_ADC_LIMIT_L, A
0A03    E568          3296     	MOV	A, LIPO_ADC_LIMIT_H		
0A05    3400          3297     ADDC A , # 0 
0A07    F568          3298     	MOV	LIPO_ADC_LIMIT_H, A
                      3299     
                      3300     MEASURE_LIPO_ADJUST: 
0A09    AE67          3301     MOV R6 , LIPO_ADC_LIMIT_L 
0A0B    AF68          3302     MOV R7 , LIPO_ADC_LIMIT_H 
                      3303     	; Calculate 3.125%
0A0D    C3            3304     	CLR	C
0A0E    E568          3305     	MOV	A, LIPO_ADC_LIMIT_H
0A10    13            3306     	RRC	A
0A11    F9            3307     MOV R1 , A 
0A12    E567          3308     	MOV	A, LIPO_ADC_LIMIT_L	
0A14    13            3309     	RRC	A
0A15    F8            3310     MOV R0 , A 
0A16    C3            3311     	CLR	C
0A17    E9            3312     MOV A , R1 
0A18    13            3313     	RRC	A
0A19    F9            3314     MOV R1 , A 
0A1A    E8            3315     MOV A , R0 
0A1B    13            3316     	RRC	A
0A1C    F8            3317     MOV R0 , A 
0A1D    E567          3318     	MOV	A, LIPO_ADC_LIMIT_L			; Set adc reference
0A1F    28            3319     ADD A , R0 
0A20    F565          3320     	MOV	LIPO_ADC_REFERENCE_L, A
0A22    E568          3321     	MOV	A, LIPO_ADC_LIMIT_H
0A24    39            3322     ADDC A , R1 
0A25    F566          3323     	MOV	LIPO_ADC_REFERENCE_H, A
0A27    C3            3324     	CLR	C
0A28    E9            3325     MOV A , R1 
0A29    13            3326     	RRC	A
0A2A    F9            3327     MOV R1 , A 
0A2B    FD            3328     MOV R5 , A 
0A2C    E8            3329     MOV A , R0 
0A2D    13            3330     	RRC	A
0A2E    F8            3331     MOV R0 , A 
0A2F    FC            3332     MOV R4 , A 
0A30    C3            3333     	CLR	C
0A31    E9            3334     MOV A , R1 
0A32    13            3335     	RRC	A
0A33    F9            3336     MOV R1 , A 
0A34    FB            3337     MOV R3 , A 
0A35    E8            3338     MOV A , R0 
0A36    13            3339     	RRC	A
0A37    F8            3340     MOV R0 , A 
0A38    FA            3341     MOV R2 , A 
0A39    C3            3342     	CLR	C
0A3A    E9            3343     MOV A , R1 
0A3B    13            3344     	RRC	A
0A3C    F9            3345     MOV R1 , A 
0A3D    E8            3346     MOV A , R0 
0A3E    13            3347     	RRC	A
0A3F    F8            3348     MOV R0 , A 
0A40    C3            3349     	CLR	C
0A41    E520          3350     	MOV	A, BIT_ACCESS		; Load programmed limit(Bit_Access has Pgm_Low_Voltage_Lim)
0A43    9401          3351     	SUBB	A, #1			; Is limit 3.0V?
0A45    6030          3352     	JZ	MEASURE_LIPO_UPDATE	; Yes - branch
                      3353     
0A47    C3            3354     	CLR	C
0A48    E520          3355     	MOV	A, BIT_ACCESS	
0A4A    9405          3356     	SUBB	A, #5			; Is limit 3.4V?
0A4C    7008          3357     	JNZ	MEASURE_LIPO_625	; No - branch
                      3358     
0A4E    EE            3359     MOV A , R6 
0A4F    2C            3360     ADD A , R4 
0A50    FE            3361     MOV R6 , A 
0A51    EF            3362     MOV A , R7 
0A52    3D            3363     ADDC A , R5 
0A53    FF            3364     MOV R7 , A 
0A54    4177          3365     	AJMP MEASURE_LIPO_UPDATE
                      3366     
                      3367     MEASURE_LIPO_625: 
0A56    C3            3368     	CLR	C
0A57    E520          3369     	MOV	A, BIT_ACCESS	
0A59    9403          3370     	SUBB	A, #3			; Is limit 3.2V or higher?
0A5B    4006          3371     	JC	MEASURE_LIPO_3125	; No - branch
                      3372     
0A5D    EE            3373     MOV A , R6 
0A5E    2A            3374     ADD A , R2 
0A5F    FE            3375     MOV R6 , A 
0A60    EF            3376     MOV A , R7 
0A61    3B            3377     ADDC A , R3 
0A62    FF            3378     MOV R7 , A 
                      3379     
                      3380     MEASURE_LIPO_3125: 
0A63    C3            3381     	CLR	C
0A64    E520          3382     	MOV	A, BIT_ACCESS	
0A66    9401          3383     	SUBB	A, #1			; Is limit 3.0V?
0A68    600D          3384     	JZ	MEASURE_LIPO_UPDATE	; Yes - branch
                      3385     
0A6A    C3            3386     	CLR	C
0A6B    E520          3387     	MOV	A, BIT_ACCESS	
0A6D    9403          3388     	SUBB	A, #3			; Is limit 3.2V?
0A6F    6006          3389     	JZ	MEASURE_LIPO_UPDATE	; Yes - branch
                      3390     
0A71    EE            3391     MOV A , R6 
0A72    28            3392     ADD A , R0 
0A73    FE            3393     MOV R6 , A 
0A74    EF            3394     MOV A , R7 
0A75    39            3395     ADDC A , R1 
0A76    FF            3396     MOV R7 , A 
                      3397     
                      3398     MEASURE_LIPO_UPDATE: 
0A77    8E67          3399     MOV LIPO_ADC_LIMIT_L , R6 
0A79    8F68          3400     MOV LIPO_ADC_LIMIT_H , R7 
                      3401     
                      3402     MEASURE_LIPO_EXIT: 
0A7B    22            3403     	RET
                      3404     
                      3405     
                      3406     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3407     ;
                      3408     ; Start ADC conversion
                      3409     ;
                      3410     ; No assumptions
                      3411     ;
                      3412     ; Start conversion used for measuring power supply voltage
                      3413     ;
                      3414     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3415     START_ADC_CONVERSION: 
                      3416     	; Start adc
                      3417     	START_ADC 
0A7C    75E890        3417+1   MOV ADC0CN , # 90H  ; ADC START
0A7F    22            3418     	RET
                      3419     
                      3420     
                      3421     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3422     ;
                      3423     ; Check temperature, power supply voltage, compensate current pwm and limit power
                      3424     ;
                      3425     ; No assumptions
                      3426     ;
                      3427     ; Used to compensate main motor power for battery voltage and
                      3428     ; to limit main motor power in order to maintain the required voltage
                      3429     ;
                      3430     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3431     CHECK_TEMP_VOLTAGE_COMPENSATE_AND_LIMIT_POWER: 
                      3432     	; Load programmed voltage compensation
0A80    7895          3433     MOV R0 , # PGM_VOLT_COMP 
0A82    E6            3434     MOV A , @ R0 
0A83    FF            3435     MOV R7 , A 
                      3436     	; Wait for ADC conversion to complete
                      3437     	GET_ADC_STATUS 
0A84    E5E8          3437+1   MOV A , ADC0CN 
0A86    20ECF7        3438     	JB	AD0BUSY, CHECK_TEMP_VOLTAGE_COMPENSATE_AND_LIMIT_POWER
                      3439     	; Read ADC result
                      3440     	READ_ADC_RESULT
0A89    A8BD          3440+1   MOV R0 , ADC0L 
0A8B    A9BE          3440+1   MOV R1 , ADC0H 
                      3441     	; Stop ADC
                      3442     	STOP_ADC
                      3443     
0A8D    056A          3444     	INC	ADC_CONVERSION_CNT			; Increment conversion counter
0A8F    C3            3445     	CLR	C
0A90    E56A          3446     	MOV	A, ADC_CONVERSION_CNT		; Is conversion count equal to temp rate?
0A92    9408          3447     SUBB A , # 8 
0A94    4032          3448     	JC	CHECK_VOLTAGE_COMP_START		; No - check voltage
                      3449     
0A96    756A00        3450     	MOV	ADC_CONVERSION_CNT, #0		; Yes - temperature check. Reset counter
0A99    C3            3451     	CLR	C
0A9A    E8            3452     MOV A , R0 
0A9B    94F6          3453     SUBB A , # 246 
0A9D    F8            3454     MOV R0 , A 
0A9E    E9            3455     MOV A , R1 
0A9F    9401          3456     SUBB A , # 1 
0AA1    4021          3457     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3458     
0AA3    755DC0        3459     	MOV  PWM_LIMIT, #192			; No - limit pwm
                      3460     
0AA6    C3            3461     	CLR	C
0AA7    E8            3462     MOV A , R0 
0AA8    9406          3463     SUBB A , # 6 
0AAA    F8            3464     MOV R0 , A 
0AAB    4017          3465     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3466     
0AAD    755D80        3467     	MOV  PWM_LIMIT, #128			; No - limit pwm
                      3468     
0AB0    C3            3469     	CLR	C
0AB1    E8            3470     MOV A , R0 
0AB2    9406          3471     SUBB A , # 6 
0AB4    F8            3472     MOV R0 , A 
0AB5    400D          3473     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3474     
0AB7    755D40        3475     	MOV  PWM_LIMIT, #64				; No - limit pwm
                      3476     
0ABA    C3            3477     	CLR	C
0ABB    E8            3478     MOV A , R0 
0ABC    9406          3479     SUBB A , # 6 
0ABE    F8            3480     MOV R0 , A 
0ABF    4003          3481     	JC	TEMP_CHECK_EXIT			; Yes - exit
                      3482     
0AC1    755D00        3483     	MOV  PWM_LIMIT, #0				; No - limit pwm
                      3484     
                      3485     TEMP_CHECK_EXIT: 
                      3486     	SET_ADC_IP_VOLT				; Select adc input for next conversion
0AC4    75BB08        3486+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
0AC7    22            3487     	RET
                      3488     
                      3489     CHECK_VOLTAGE_COMP_START: 
                      3490     	; Skip compensation part if voltage compensation is not enabled
0AC8    C3            3491     	CLR	C
0AC9    EF            3492     MOV A , R7 
0ACA    9402          3493     	SUBB	A, #2
0ACC    406C          3494     	JC	CHECK_VOLTAGE_COMP_SKIP
                      3495     	; Check range of adc reading and adc reference
0ACE    E9            3496     MOV A , R1 
0ACF    FB            3497     MOV R3 , A 
0AD0    E8            3498     MOV A , R0 
0AD1    FA            3499     MOV R2 , A 
0AD2    AD66          3500     MOV R5 , LIPO_ADC_REFERENCE_H 
0AD4    AC65          3501     MOV R4 , LIPO_ADC_REFERENCE_L 
0AD6    EB            3502     MOV A , R3 
0AD7    4D            3503     ORL A , R5 
0AD8    F520          3504     	MOV	BIT_ACCESS, A
0ADA    30010E        3505     	JNB	BIT_ACCESS.1, CHECK_VOLTAGE_INPUT_SHIFTED_ONCE
                      3506     
0ADD    C3            3507     	CLR	C
0ADE    EB            3508     MOV A , R3 
0ADF    13            3509     	RRC	A
0AE0    FB            3510     MOV R3 , A 
0AE1    EA            3511     MOV A , R2 
0AE2    13            3512     	RRC	A
0AE3    FA            3513     MOV R2 , A 
0AE4    C3            3514     	CLR	C
0AE5    ED            3515     MOV A , R5 
0AE6    13            3516     	RRC	A
0AE7    FD            3517     MOV R5 , A 
0AE8    EC            3518     MOV A , R4 
0AE9    13            3519     	RRC	A
0AEA    FC            3520     MOV R4 , A 
                      3521     
                      3522     CHECK_VOLTAGE_INPUT_SHIFTED_ONCE: 
0AEB    EB            3523     MOV A , R3 
0AEC    4D            3524     ORL A , R5 
0AED    F520          3525     	MOV	BIT_ACCESS, A
0AEF    30000E        3526     	JNB	BIT_ACCESS.0, CHECK_VOLTAGE_INPUT_SHIFTED_TWICE
                      3527     
0AF2    C3            3528     	CLR	C
0AF3    EB            3529     MOV A , R3 
0AF4    13            3530     	RRC	A
0AF5    FB            3531     MOV R3 , A 
0AF6    EA            3532     MOV A , R2 
0AF7    13            3533     	RRC	A
0AF8    FA            3534     MOV R2 , A 
0AF9    C3            3535     	CLR	C
0AFA    ED            3536     MOV A , R5 
0AFB    13            3537     	RRC	A
0AFC    FD            3538     MOV R5 , A 
0AFD    EC            3539     MOV A , R4 
0AFE    13            3540     	RRC	A
0AFF    FC            3541     MOV R4 , A 
                      3542     
                      3543     CHECK_VOLTAGE_INPUT_SHIFTED_TWICE: 
                      3544     	; Multiply adc value with voltage compensation factor
0B00    EA            3545     MOV A , R2 
0B01    8569F0        3546     	MOV	B, VOLTAGE_COMP_FACTOR
0B04    A4            3547     	MUL	AB			
                      3548     	; Compare result with adc reference
0B05    E5F0          3549     	MOV	A, B					; Shift result left once, to match ADC scale
0B07    33            3550     	RLC	A				
0B08    C3            3551     	CLR	C
0B09    9C            3552     SUBB A , R4 
0B0A    A2E7          3553     	MOV	C, ACC.7				; Preserve sign of 2's complement number
0B0C    13            3554     	RRC	A					; Divide error by 2
0B0D    FA            3555     MOV R2 , A 
0B0E    E569          3556     	MOV	A, VOLTAGE_COMP_FACTOR
0B10    9A            3557     SUBB A , R2 
0B11    FA            3558     MOV R2 , A 
                      3559     	; Do not update voltage compensation factor if low voltage limit is activated (to avoid interaction)
0B12    E55D          3560     	MOV	A, PWM_LIMIT
0B14    F4            3561     	CPL	A
0B15    7002          3562     	JNZ	CHECK_VOLTAGE_COMPENSATE_POWER
                      3563     
0B17    8A69          3564     MOV VOLTAGE_COMP_FACTOR , R2 
                      3565     
                      3566     CHECK_VOLTAGE_COMPENSATE_POWER: 
                      3567     	; Multiply current pwm with voltage compensation factor
0B19    E524          3568     	MOV	A, CURRENT_PWM
0B1B    8569F0        3569     	MOV	B, VOLTAGE_COMP_FACTOR
0B1E    A4            3570     	MUL	AB			
                      3571     	; Shift result
0B1F    ABF0          3572     MOV R3 , B 
0B21    FA            3573     MOV R2 , A 
0B22    EA            3574     MOV A , R2 
0B23    33            3575     	RLC	A
0B24    EB            3576     MOV A , R3 
0B25    33            3577     	RLC	A
0B26    5002          3578     	JNC	($+4)				; If result is below max pwm - branch 
                      3579     
0B28    74FF          3580     	MOV	A, #0FFH
                      3581     
0B2A    F525          3582     	MOV	CURRENT_PWM_COMP, A
                      3583     IF MODE >= 1	; Tail or multi
0B2C    F526          3584     	MOV	CURRENT_PWM_LIMITED, A			; Set this also here, for tail operation. Default not limited
0B2E    C3            3585     	CLR	C
0B2F    E525          3586     	MOV	A, CURRENT_PWM_COMP				; Check against limit
0B31    955D          3587     	SUBB	A, PWM_LIMIT
0B33    4003          3588     	JC	($+5)						; If current pwm below limit - branch
                      3589     
0B35    855D26        3590     	MOV	CURRENT_PWM_LIMITED, PWM_LIMIT	; Limit pwm
                      3591     ENDIF
0B38    613D          3592     	AJMP	CHECK_VOLTAGE_LIMIT_START
                      3593     
                      3594     CHECK_VOLTAGE_COMP_SKIP: 
0B3A    852425        3595     	MOV	CURRENT_PWM_COMP, CURRENT_PWM
                      3596     
                      3597     CHECK_VOLTAGE_LIMIT_START: 
                      3598     IF MODE == 0 OR MODE == 2	; Main or multi
                      3599     	; Check if ADC is saturated
0B3D    C3            3600     	CLR	C
0B3E    E8            3601     MOV A , R0 
0B3F    94FF          3602     	SUBB	A, #0FFH
0B41    E9            3603     MOV A , R1 
0B42    9403          3604     	SUBB	A, #03H
0B44    5012          3605     	JNC	CHECK_VOLTAGE_GOOD		; ADC saturated, can not make judgement
                      3606     
                      3607     	; Check voltage against limit
0B46    C3            3608     	CLR	C
0B47    E8            3609     MOV A , R0 
0B48    9567          3610     	SUBB	A, LIPO_ADC_LIMIT_L
0B4A    E9            3611     MOV A , R1 
0B4B    9568          3612     	SUBB	A, LIPO_ADC_LIMIT_H
0B4D    5009          3613     	JNC	CHECK_VOLTAGE_GOOD		; If voltage above limit - branch
                      3614     
                      3615     	; Decrease pwm limit
0B4F    E55D          3616     	MOV  A, PWM_LIMIT
0B51    600C          3617     	JZ	CHECK_VOLTAGE_LIM		; If limit zero - branch
                      3618     
0B53    155D          3619     	DEC	PWM_LIMIT				; Decrement limit
0B55    020B5F        3620     	JMP	CHECK_VOLTAGE_LIM
                      3621     
                      3622     CHECK_VOLTAGE_GOOD: 
                      3623     	; Increase pwm limit
0B58    E55D          3624     	MOV  A, PWM_LIMIT
0B5A    F4            3625     	CPL	A			
0B5B    6002          3626     	JZ	CHECK_VOLTAGE_LIM		; If limit max - branch
                      3627     
0B5D    055D          3628     	INC	PWM_LIMIT				; Increment limit
                      3629     
                      3630     CHECK_VOLTAGE_LIM: 
0B5F    A85D          3631     MOV R0 , PWM_LIMIT 
0B61    C3            3632     	CLR	C
0B62    E525          3633     	MOV	A, CURRENT_PWM_COMP
0B64    98            3634     SUBB A , R0 
0B65    5002          3635     	JNC	CHECK_VOLTAGE_SPOOLUP_LIM	; If current pwm above limit - branch and limit	
                      3636     
0B67    A825          3637     MOV R0 , CURRENT_PWM_COMP 
                      3638     
                      3639     CHECK_VOLTAGE_SPOOLUP_LIM: 
0B69    8826          3640     MOV CURRENT_PWM_LIMITED , R0 
                      3641     	; Slow spoolup
0B6B    C3            3642     	CLR	C
0B6C    E526          3643     	MOV	A, CURRENT_PWM_LIMITED
0B6E    955E          3644     	SUBB	A, PWM_LIMIT_SPOOLUP
0B70    400B          3645     	JC	CHECK_VOLTAGE_EXIT			; If current pwm below limit - branch	
                      3646     
0B72    855E26        3647     	MOV	CURRENT_PWM_LIMITED, PWM_LIMIT_SPOOLUP
0B75    E55E          3648     	MOV	A, PWM_LIMIT_SPOOLUP		; Check if spoolup limit is max
0B77    F4            3649     	CPL	A
0B78    6003          3650     	JZ	CHECK_VOLTAGE_EXIT			; If max - branch
                      3651      
0B7A    855E5D        3652     	MOV	PWM_LIMIT, PWM_LIMIT_SPOOLUP	; Set pwm limit to spoolup limit during ramp (to avoid governor integral buildup)
                      3653     
                      3654     CHECK_VOLTAGE_EXIT: 
                      3655     ENDIF
                      3656     	; Set adc mux for next conversion
0B7D    C3            3657     	CLR	C
0B7E    E56A          3658     	MOV	A, ADC_CONVERSION_CNT		; Is next conversion for temperature?
0B80    9407          3659     	SUBB	A, #(TEMP_CHECK_RATE-1)
0B82    7003          3660     	JNZ	($+5)					; No - skip changing adc input mux
                      3661     
                      3662     	SET_ADC_IP_TEMP				; Select temp sensor for next conversion
0B84    75BB10        3662+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      3663     
0B87    22            3664     	RET
                      3665     
                      3666     
                      3667     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3668     ;
                      3669     ; Set startup PWM routine
                      3670     ;
                      3671     ; No assumptions
                      3672     ;
                      3673     ; Used for pwm control during startup
                      3674     ;
                      3675     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3676     SET_STARTUP_PWM: 	
                      3677     	; Set pwm values according to startup phase flags
0B88    306902        3678     JNB FLAGS1 . 1 , ( $+5 ) 
0B8B    7832          3679     MOV R0 , # 50 
0B8D    306A02        3680     JNB FLAGS1 . 2 , ( $+5 ) 
0B90    7878          3681     MOV R0 , # 120 
0B92    306B02        3682     JNB FLAGS1 . 3 , ( $+5 ) 
0B95    7850          3683     MOV R0 , # 80 
                      3684     
                      3685     	; Update pwm variables if any startup phase flag is set
0B97    E52D          3686     	MOV	A, FLAGS1
0B99    540E          3687     	ANL	A, #((1 SHL SETTLE_PHASE)+(1 SHL STEPPER_PHASE)+(1 SHL AQUISITION_PHASE))
0B9B    6038          3688     	JZ	STARTUP_PWM_EXIT		; If no startup phase set - exit
                      3689     
                      3690     	; Adjust startup power
0B9D    7989          3691     MOV R1 , # PGM_STARTUP_PWR 
0B9F    B70303        3692     CJNE @ R1 , # 3 , ( $+6 ) 
0BA2    020BC8        3693     	LJMP	STARTUP_PWM_SET_PWM			; Yes - skip adjustment
                      3694     
0BA5    C3            3695     	CLR	C
0BA6    E8            3696     MOV A , R0 
0BA7    13            3697     	RRC	A			; After this "0.5"
0BA8    8720          3698     MOV BIT_ACCESS , @ R1 
0BAA    200002        3699     	JB	BIT_ACCESS.0, STARTUP_PWM_CORR	; Branch if bit 0 in gain is set
                      3700     
0BAD    C3            3701     	CLR	C
0BAE    13            3702     	RRC	A			; After this "0.25"
                      3703     
                      3704     STARTUP_PWM_CORR: 
0BAF    200207        3705     	JB	BIT_ACCESS.2, STARTUP_PWM_GAIN_POS	; Branch if bit 2 in gain is set
                      3706     
0BB2    C8            3707     XCH A , R0 
0BB3    C3            3708     	CLR	C
0BB4    98            3709     SUBB A , R0 
0BB5    F8            3710     MOV R0 , A 
0BB6    020BC8        3711     	JMP	STARTUP_PWM_SET_PWM
                      3712     
                      3713     STARTUP_PWM_GAIN_POS: 
0BB9    28            3714     ADD A , R0 
0BBA    F8            3715     MOV R0 , A 
0BBB    5003          3716     	JNC	STARTUP_PWM_CHECK_LIMIT		; Above max?
                      3717     
0BBD    74FF          3718     	MOV	A, #0FFH					; Yes - limit
0BBF    F8            3719     MOV R0 , A 
                      3720     
                      3721     STARTUP_PWM_CHECK_LIMIT: 
0BC0    C3            3722     	CLR	C
0BC1    E8            3723     MOV A , R0 
0BC2    955D          3724     	SUBB	A, PWM_LIMIT
0BC4    4002          3725     	JC	STARTUP_PWM_SET_PWM			; If pwm below limit - branch
                      3726     
0BC6    A85D          3727     MOV R0 , PWM_LIMIT 
                      3728     
                      3729     STARTUP_PWM_SET_PWM: 
                      3730     	; Set pwm variables
0BC8    8822          3731     MOV REQUESTED_PWM , R0 
0BCA    8824          3732     MOV CURRENT_PWM , R0 
0BCC    8825          3733     MOV CURRENT_PWM_COMP , R0 
0BCE    8826          3734     MOV CURRENT_PWM_LIMITED , R0 
0BD0    306902        3735     JNB FLAGS1 . 1 , STARTUP_PWM_EXIT 
                      3736     
0BD3    885F          3737     MOV PWM_SPOOLUP_BEG , R0 
                      3738     
                      3739     STARTUP_PWM_EXIT: 
0BD5    22            3740     	RET
                      3741     
                      3742     
                      3743     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3744     ;
                      3745     ; Initialize all timings routine
                      3746     ;
                      3747     ; No assumptions
                      3748     ;
                      3749     ; Part of initialization before motor start
                      3750     ;
                      3751     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3752     INITIALIZE_ALL_TIMINGS:  
                      3753     	; Load programmed startup rpm
0BD6    788D          3754     MOV R0 , # PGM_STARTUP_RPM 
0BD8    E6            3755     MOV A , @ R0 
0BD9    FF            3756     MOV R7 , A 
                      3757     	; Check startup rpm setting and set step accordingly
0BDA    C3            3758     	CLR	C
0BDB    EF            3759     MOV A , R7 
0BDC    9405          3760     	SUBB	A, #5
0BDE    5018          3761     	JNC	STEPPER_STEP_HIGH
0BE0    C3            3762     	CLR	C
0BE1    EF            3763     MOV A , R7 
0BE2    9404          3764     	SUBB	A, #4
0BE4    5020          3765     	JNC	STEPPER_STEP_MED_HIGH
0BE6    C3            3766     	CLR	C
0BE7    EF            3767     MOV A , R7 
0BE8    9403          3768     	SUBB	A, #3
0BEA    5028          3769     	JNC	STEPPER_STEP_MED
0BEC    C3            3770     	CLR	C
0BED    EF            3771     MOV A , R7 
0BEE    9402          3772     	SUBB	A, #2
0BF0    5030          3773     	JNC	STEPPER_STEP_MED_LOW
0BF2    C3            3774     	CLR	C
0BF3    EF            3775     MOV A , R7 
0BF4    9401          3776     	SUBB	A, #1
0BF6    5038          3777     	JNC	STEPPER_STEP_LOW
                      3778     
                      3779     STEPPER_STEP_HIGH: 
0BF8    7533A0        3780     	MOV	STEPPER_STEP_BEG_L, #LOW(2000 SHL 1)
0BFB    75340F        3781     	MOV	STEPPER_STEP_BEG_H, #HIGH(2000 SHL 1)
0BFE    75353C        3782     	MOV	STEPPER_STEP_END_L, #LOW(670 SHL 1)
0C01    753605        3783     	MOV	STEPPER_STEP_END_H, #HIGH(670 SHL 1)
0C04    813E          3784     	AJMP	STEPPER_STEP_SET
                      3785     STEPPER_STEP_MED_HIGH: 
0C06    7533C0        3786     	MOV	STEPPER_STEP_BEG_L, #LOW(2400 SHL 1)
0C09    753412        3787     	MOV	STEPPER_STEP_BEG_H, #HIGH(2400 SHL 1)
0C0C    753540        3788     	MOV	STEPPER_STEP_END_L, #LOW(800 SHL 1)
0C0F    753606        3789     	MOV	STEPPER_STEP_END_H, #HIGH(800 SHL 1)
0C12    813E          3790     	AJMP	STEPPER_STEP_SET
                      3791     STEPPER_STEP_MED: 
0C14    753370        3792     	MOV	STEPPER_STEP_BEG_L, #LOW(3000 SHL 1)	; ~3300 eRPM 
0C17    753417        3793     	MOV	STEPPER_STEP_BEG_H, #HIGH(3000 SHL 1)
0C1A    7535D0        3794     	MOV	STEPPER_STEP_END_L, #LOW(1000 SHL 1)	; ~10000 eRPM
0C1D    753607        3795     	MOV	STEPPER_STEP_END_H, #HIGH(1000 SHL 1)
0C20    813E          3796     	AJMP	STEPPER_STEP_SET
                      3797     STEPPER_STEP_MED_LOW: 
0C22    75334C        3798     	MOV	STEPPER_STEP_BEG_L, #LOW(3750 SHL 1)
0C25    75341D        3799     	MOV	STEPPER_STEP_BEG_H, #HIGH(3750 SHL 1)
0C28    7535C4        3800     	MOV	STEPPER_STEP_END_L, #LOW(1250 SHL 1)
0C2B    753609        3801     	MOV	STEPPER_STEP_END_H, #HIGH(1250 SHL 1)
0C2E    813E          3802     	AJMP	STEPPER_STEP_SET
                      3803     STEPPER_STEP_LOW: 
0C30    753328        3804     	MOV	STEPPER_STEP_BEG_L, #LOW(4500 SHL 1)
0C33    753423        3805     	MOV	STEPPER_STEP_BEG_H, #HIGH(4500 SHL 1)
0C36    7535B8        3806     	MOV	STEPPER_STEP_END_L, #LOW(1500 SHL 1)
0C39    75360B        3807     	MOV	STEPPER_STEP_END_H, #HIGH(1500 SHL 1)
0C3C    813E          3808     	AJMP	STEPPER_STEP_SET
                      3809     
                      3810     STEPPER_STEP_SET: 
0C3E    853350        3811     	MOV	WT_STEPPER_STEP_L, STEPPER_STEP_BEG_L	; Initialize stepper step time 
0C41    853451        3812     	MOV	WT_STEPPER_STEP_H, STEPPER_STEP_BEG_H
0C44    7AFF          3813     MOV R2 , # 0FFH 
0C46    7B3F          3814     MOV R3 , # 3FH 
0C48    8A4E          3815     MOV WT_COMM_L , R2 
0C4A    8B4F          3816     MOV WT_COMM_H , R3 
0C4C    8A4A          3817     MOV WT_ADVANCE_L , R2 
0C4E    8B4B          3818     MOV WT_ADVANCE_H , R3 
0C50    7B1F          3819     MOV R3 , # 1FH 
0C52    8A4C          3820     MOV WT_ZC_SCAN_L , R2 
0C54    8B4D          3821     MOV WT_ZC_SCAN_H , R3 
0C56    8A3C          3822     MOV COMM_PERIOD4X_L , R2 
0C58    8B3D          3823     MOV COMM_PERIOD4X_H , R3 
0C5A    22            3824     	RET
                      3825     
                      3826     
                      3827     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3828     ;
                      3829     ; Calculate next commutation timing routine
                      3830     ;
                      3831     ; No assumptions
                      3832     ;
                      3833     ; Called immediately after each commutation
                      3834     ; Also sets up timer 1 to wait advance timing
                      3835     ; Two entry points are used
                      3836     ;
                      3837     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3838     CALC_NEXT_COMM_TIMING_START: 	; Entry point for startup
0C5B    A850          3839     MOV R0 , WT_STEPPER_STEP_L 
0C5D    A951          3840     MOV R1 , WT_STEPPER_STEP_H 
0C5F    020C66        3841     	JMP	READ_TIMER
                      3842     
                      3843     CALC_NEXT_COMM_TIMING: 		; Entry point for run phase
0C62    A84A          3844     MOV R0 , WT_ADVANCE_L 
0C64    A94B          3845     MOV R1 , WT_ADVANCE_H 
                      3846     READ_TIMER: 
                      3847     	; Set up next wait
0C66    759100        3848     	MOV	TMR3CN, #00H		; Timer3 disabled
0C69    C3            3849     	CLR	C
0C6A    E4            3850     	CLR	A
0C6B    98            3851     SUBB A , R0 
0C6C    F594          3852     	MOV	TMR3L, A
0C6E    E4            3853     	CLR	A
0C6F    99            3854     SUBB A , R1 
0C70    F595          3855     	MOV	TMR3H, A
0C72    759104        3856     	MOV	TMR3CN, #04H		; Timer3 enabled
0C75    D260          3857     SETB FLAGS0 . 0 
                      3858     	; Read commutation time
0C77    75C820        3859     	MOV	TMR2CN, #20H		; Timer2 disabled
0C7A    A8CC          3860     MOV R0 , TMR2L 
0C7C    A9CD          3861     MOV R1 , TMR2H 
0C7E    75C824        3862     	MOV	TMR2CN, #24H		; Timer2 enabled
                      3863     	; Calculate this commutation time
0C81    AA3A          3864     MOV R2 , PREV_COMM_L 
0C83    AB3B          3865     MOV R3 , PREV_COMM_H 
0C85    883A          3866     MOV PREV_COMM_L , R0 
0C87    893B          3867     MOV PREV_COMM_H , R1 
0C89    C3            3868     	CLR	C
0C8A    E8            3869     MOV A , R0 
0C8B    9A            3870     SUBB A , R2 
0C8C    F8            3871     MOV R0 , A 
0C8D    E9            3872     MOV A , R1 
0C8E    9B            3873     SUBB A , R3 
0C8F    F9            3874     MOV R1 , A 
                      3875     	; Calculate next zero cross scan timeout 
0C90    AA3C          3876     MOV R2 , COMM_PERIOD4X_L 
0C92    AB3D          3877     MOV R3 , COMM_PERIOD4X_H 
0C94    C3            3878     	CLR	C
0C95    EB            3879     MOV A , R3 
0C96    13            3880     	RRC	A					; Divide by 2
0C97    FD            3881     MOV R5 , A 
0C98    EA            3882     MOV A , R2 
0C99    13            3883     	RRC	A
0C9A    FC            3884     MOV R4 , A 
0C9B    C3            3885     	CLR	C
0C9C    ED            3886     MOV A , R5 
0C9D    13            3887     	RRC	A					; Divide by 2 again
0C9E    FD            3888     MOV R5 , A 
0C9F    EC            3889     MOV A , R4 
0CA0    13            3890     	RRC	A
0CA1    FC            3891     MOV R4 , A 
0CA2    C3            3892     	CLR	C
0CA3    EA            3893     MOV A , R2 
0CA4    9C            3894     SUBB A , R4 
0CA5    FA            3895     MOV R2 , A 
0CA6    EB            3896     MOV A , R3 
0CA7    9D            3897     SUBB A , R5 
0CA8    FB            3898     MOV R3 , A 
                      3899     
0CA9    EA            3900     MOV A , R2 
0CAA    28            3901     ADD A , R0 
0CAB    FA            3902     MOV R2 , A 
0CAC    EB            3903     MOV A , R3 
0CAD    39            3904     ADDC A , R1 
0CAE    FB            3905     MOV R3 , A 
0CAF    8A3C          3906     MOV COMM_PERIOD4X_L , R2 
0CB1    8B3D          3907     MOV COMM_PERIOD4X_H , R3 
0CB3    4001          3908     	JC	CALC_NEXT_COMM_SLOW		; If period larger than 0xffff - go to slow case
0CB5    22            3909     	RET
                      3910     
                      3911     CALC_NEXT_COMM_SLOW: 
0CB6    753CFF        3912     	MOV	COMM_PERIOD4X_L, #0FFH	; Set commutation period registers to very slow timing (0xffff)
0CB9    753DFF        3913     	MOV	COMM_PERIOD4X_H, #0FFH
0CBC    22            3914     	RET
                      3915     
                      3916     
                      3917     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3918     ;
                      3919     ; Wait advance timing routine
                      3920     ;
                      3921     ; No assumptions
                      3922     ;
                      3923     ; Waits for the advance timing to elapse
                      3924     ; Also sets up timer 1 to wait the zero cross scan wait time
                      3925     ;
                      3926     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3927     WAIT_ADVANCE_TIMING: 	
0CBD    306002        3928     JNB FLAGS0 . 0 , ( $+5 ) 
0CC0    81BD          3929     	AJMP	WAIT_ADVANCE_TIMING
                      3930     
0CC2    759100        3931     	MOV	TMR3CN, #00H		; Timer3 disabled
0CC5    C3            3932     	CLR	C
0CC6    E4            3933     	CLR	A
0CC7    954C          3934     	SUBB	A, WT_ZC_SCAN_L	; Set wait to zero cross scan value
0CC9    F594          3935     	MOV	TMR3L, A
0CCB    E4            3936     	CLR	A
0CCC    954D          3937     	SUBB	A, WT_ZC_SCAN_H		
0CCE    F595          3938     	MOV	TMR3H, A
0CD0    759104        3939     	MOV	TMR3CN, #04H		; Timer3 enabled
0CD3    D260          3940     SETB FLAGS0 . 0 
0CD5    22            3941     	RET
                      3942     
                      3943     
                      3944     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3945     ;
                      3946     ; Calculate new wait times routine
                      3947     ;
                      3948     ; No assumptions
                      3949     ;
                      3950     ; Calculates new wait times
                      3951     ;
                      3952     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      3953     CALC_NEW_WAIT_TIMES: 	
                      3954     	; Load programmed commutation timing
0CD6    7890          3955     MOV R0 , # PGM_COMM_TIMING 
0CD8    E6            3956     MOV A , @ R0 
0CD9    FF            3957     MOV R7 , A 
0CDA    7E0A          3958     MOV R6 , # ( COMM_TIME_RED SHL 1 ) 
0CDC    306D04        3959     JNB FLAGS1 . 5 , CALC_NEW_WAIT_DIR_START_SET 
                      3960     
0CDF    7F01          3961     MOV R7 , # 1 
0CE1    7E32          3962     MOV R6 , # 50 
                      3963     
                      3964     CALC_NEW_WAIT_DIR_START_SET: 
                      3965     	; Load current commutation timing
0CE3    A93D          3966     MOV R1 , COMM_PERIOD4X_H 
0CE5    A83C          3967     MOV R0 , COMM_PERIOD4X_L 
0CE7    7A04          3968     MOV R2 , # 4 
                      3969     DIVIDE_WAIT_TIMES: 
0CE9    C3            3970     	CLR	C
0CEA    E9            3971     MOV A , R1 
0CEB    13            3972     	RRC	A					; Divide by 2
0CEC    F9            3973     MOV R1 , A 
0CED    E8            3974     MOV A , R0 
0CEE    13            3975     	RRC	A
0CEF    F8            3976     MOV R0 , A 
0CF0    DAF7          3977     DJNZ R2 , DIVIDE_WAIT_TIMES 
                      3978     
0CF2    C3            3979     	CLR	C
0CF3    E8            3980     MOV A , R0 
0CF4    9E            3981     SUBB A , R6 
0CF5    F8            3982     MOV R0 , A 
0CF6    E9            3983     MOV A , R1 
0CF7    9400          3984     	SUBB	A, #0
0CF9    F9            3985     MOV R1 , A 
0CFA    4009          3986     	JC	LOAD_MIN_TIME			; Check that result is still positive
                      3987     
0CFC    C3            3988     	CLR	C
0CFD    E8            3989     MOV A , R0 
0CFE    940A          3990     	SUBB	A, #(COMM_TIME_MIN SHL 1)
0D00    E9            3991     MOV A , R1 
0D01    9400          3992     	SUBB	A, #0
0D03    5004          3993     	JNC	ADJUST_TIMING			; Check that result is still above minumum
                      3994     
                      3995     LOAD_MIN_TIME: 
0D05    780A          3996     MOV R0 , # ( COMM_TIME_MIN SHL 1 ) 
0D07    E4            3997     	CLR	A
0D08    F9            3998     MOV R1 , A 
                      3999     
                      4000     ADJUST_TIMING: 
0D09    E9            4001     MOV A , R1 
0D0A    FB            4002     MOV R3 , A 
0D0B    E8            4003     MOV A , R0 
0D0C    FA            4004     MOV R2 , A 
0D0D    C3            4005     	CLR	C
0D0E    E9            4006     MOV A , R1 
0D0F    13            4007     	RRC	A					; Divide by 2
0D10    FD            4008     MOV R5 , A 
0D11    E8            4009     MOV A , R0 
0D12    13            4010     	RRC	A
0D13    FC            4011     MOV R4 , A 
0D14    C3            4012     	CLR	C
0D15    EF            4013     MOV A , R7 
0D16    9403          4014     	SUBB	A, #3				; Is timing normal?
0D18    6030          4015     	JZ	STORE_TIMES_DECREASE	; Yes - branch
                      4016     
0D1A    EF            4017     MOV A , R7 
0D1B    20E00E        4018     	JB	ACC.0, ADJUST_TIMING_TWO_STEPS	; If an odd number - branch
                      4019     
0D1E    C3            4020     	CLR	C
0D1F    E8            4021     MOV A , R0 
0D20    3C            4022     ADDC A , R4 
0D21    F8            4023     MOV R0 , A 
0D22    E9            4024     MOV A , R1 
0D23    3D            4025     ADDC A , R5 
0D24    F9            4026     MOV R1 , A 
0D25    EC            4027     MOV A , R4 
0D26    FA            4028     MOV R2 , A 
0D27    ED            4029     MOV A , R5 
0D28    FB            4030     MOV R3 , A 
0D29    020D37        4031     	JMP	STORE_TIMES_UP_OR_DOWN
                      4032     
                      4033     ADJUST_TIMING_TWO_STEPS: 
0D2C    C3            4034     	CLR	C
0D2D    E8            4035     MOV A , R0 
0D2E    38            4036     ADDC A , R0 
0D2F    F8            4037     MOV R0 , A 
0D30    E9            4038     MOV A , R1 
0D31    39            4039     ADDC A , R1 
0D32    F9            4040     MOV R1 , A 
0D33    7A0A          4041     MOV R2 , # ( COMM_TIME_MIN SHL 1 ) 
0D35    E4            4042     	CLR	A
0D36    FB            4043     MOV R3 , A 
                      4044     
                      4045     STORE_TIMES_UP_OR_DOWN: 
0D37    C3            4046     	CLR	C
0D38    EF            4047     MOV A , R7 
0D39    9403          4048     	SUBB	A, #3				; Is timing higher than normal?
0D3B    400D          4049     	JC	STORE_TIMES_DECREASE	; No - branch
                      4050     
                      4051     STORE_TIMES_INCREASE: 
0D3D    8A4E          4052     MOV WT_COMM_L , R2 
0D3F    8B4F          4053     MOV WT_COMM_H , R3 
0D41    884A          4054     MOV WT_ADVANCE_L , R0 
0D43    894B          4055     MOV WT_ADVANCE_H , R1 
0D45    8C4C          4056     MOV WT_ZC_SCAN_L , R4 
0D47    8D4D          4057     MOV WT_ZC_SCAN_H , R5 
0D49    22            4058     	RET
                      4059     
                      4060     STORE_TIMES_DECREASE: 
0D4A    754E01        4061     	MOV	WT_COMM_L, #1			; Set to "zero" during direct start
0D4D    754F00        4062     	MOV	WT_COMM_H, #0
0D50    206D04        4063     JB FLAGS1 . 5 , STORE_TIMES_DEC_SET 
                      4064     
0D53    884E          4065     MOV WT_COMM_L , R0 
0D55    894F          4066     MOV WT_COMM_H , R1 
                      4067     
                      4068     STORE_TIMES_DEC_SET: 
0D57    8A4A          4069     MOV WT_ADVANCE_L , R2 
0D59    8B4B          4070     MOV WT_ADVANCE_H , R3 
0D5B    8C4C          4071     MOV WT_ZC_SCAN_L , R4 
0D5D    8D4D          4072     MOV WT_ZC_SCAN_H , R5 
0D5F    22            4073     	RET
                      4074     
                      4075     
                      4076     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4077     ;
                      4078     ; Wait before zero cross scan routine
                      4079     ;
                      4080     ; No assumptions
                      4081     ;
                      4082     ; Waits for the zero cross scan wait time to elapse
                      4083     ; Also sets up timer 1 to wait the zero cross scan timeout time
                      4084     ;
                      4085     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4086     WAIT_BEFORE_ZC_SCAN: 	
0D60    306002        4087     JNB FLAGS0 . 0 , ( $+5 ) 
0D63    A160          4088     	AJMP	WAIT_BEFORE_ZC_SCAN
                      4089     
0D65    759100        4090     	MOV	TMR3CN, #00H		; Timer3 disabled
0D68    C3            4091     	CLR	C
0D69    E4            4092     	CLR	A
0D6A    953C          4093     	SUBB	A, COMM_PERIOD4X_L	; Set wait to zero comm period 4x value
0D6C    F594          4094     	MOV	TMR3L, A
0D6E    E4            4095     	CLR	A
0D6F    953D          4096     	SUBB	A, COMM_PERIOD4X_H		
0D71    F595          4097     	MOV	TMR3H, A
0D73    759104        4098     	MOV	TMR3CN, #04H		; Timer3 enabled
0D76    D260          4099     SETB FLAGS0 . 0 
0D78    22            4100     	RET
                      4101     
                      4102     
                      4103     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4104     ;
                      4105     ; Wait for comparator to go low/high routines
                      4106     ;
                      4107     ; No assumptions
                      4108     ;
                      4109     ; Waits for the zero cross scan wait time to elapse
                      4110     ; Then scans for comparator going low/high
                      4111     ;
                      4112     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4113     WAIT_FOR_COMP_OUT_LOW: 
0D79    753F00        4114     	MOV	COMP_WAIT_READS, #0
0D7C    752000        4115     	MOV	BIT_ACCESS, #00H			; Desired comparator output
0D7F    020D88        4116     	JMP	WAIT_FOR_COMP_OUT_START
                      4117     
                      4118     WAIT_FOR_COMP_OUT_HIGH: 
0D82    753F00        4119     	MOV	COMP_WAIT_READS, #0
0D85    752040        4120     	MOV	BIT_ACCESS, #40H			; Desired comparator output
                      4121     
                      4122     WAIT_FOR_COMP_OUT_START: 
0D88    D2AF          4123     	SETB	EA						; Enable interrupts
0D8A    053F          4124     	INC	COMP_WAIT_READS
0D8C    206001        4125     JB FLAGS0 . 0 , ( $+4 ) 
0D8F    22            4126     	RET							; Yes - return
                      4127     
                      4128     	; Select number of comparator readings based upon current rotation speed
0D90    E53D          4129     	MOV 	A, COMM_PERIOD4X_H			; Load rotation period
0D92    C3            4130     	CLR	C
0D93    13            4131     	RRC	A						; Divide by 4
0D94    C3            4132     	CLR	C
0D95    13            4133     	RRC	A
0D96    F8            4134     MOV R0 , A 
0D97    08            4135     INC R0 
                      4136     	; For damped mode, do fewer comparator readings (since comparator info is primarily only available in the pwm on period)
0D98    307206        4137     JNB FLAGS2 . 2 , COMP_WAIT_SET_RESPONSE_TIME 
                      4138     
0D9B    C3            4139     	CLR	C
0D9C    13            4140     	RRC	A						; Divide by 4 again
0D9D    C3            4141     	CLR	C
0D9E    13            4142     	RRC	A
0D9F    F8            4143     MOV R0 , A 
0DA0    08            4144     INC R0 
                      4145     
                      4146     COMP_WAIT_SET_RESPONSE_TIME: 
0DA1    759D00        4147     	MOV	CPT0MD, #0				; Set fast response (100ns) as default		
0DA4    C3            4148     	CLR	C
0DA5    E53D          4149     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 1ms?
0DA7    9408          4150     	SUBB	A, #8
0DA9    400D          4151     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4152     
0DAB    759D02        4153     	MOV	CPT0MD, #2				; Set medium response (300ns)
0DAE    C3            4154     	CLR	C
0DAF    E53D          4155     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x_H less than 2ms?
0DB1    9410          4156     	SUBB	A, #16
0DB3    4003          4157     	JC	COMP_WAIT_ON_COMP_ABLE		; Yes - jump
                      4158     
0DB5    759D03        4159     	MOV	CPT0MD, #3				; Set slow response (1000ns) 	
                      4160     
                      4161     COMP_WAIT_ON_COMP_ABLE: 
0DB8    206003        4162     JB FLAGS0 . 0 , ( $+6 ) 
0DBB    D2AF          4163     	SETB	EA						; Enable interrupts
0DBD    22            4164     	RET							; Yes - return
                      4165     
0DBE    7918          4166     MOV R1 , # 24 
0DC0    207502        4167     JB FLAGS2 . 5 , ( $+5 ) 
0DC3    7908          4168     MOV R1 , # 8 
0DC5    D2AF          4169     	SETB	EA						; Enable interrupts
0DC7    00            4170     	NOP							; Allocate only just enough time to capture interrupt
0DC8    00            4171     	NOP
0DC9    C2AF          4172     	CLR	EA						; Disable interrupts
0DCB    20620A        4173     JB FLAGS0 . 2 , PWM_WAIT 
                      4174     
0DCE    7914          4175     MOV R1 , # 20 
0DD0    207502        4176     JB FLAGS2 . 5 , ( $+5 ) 
0DD3    7907          4177     MOV R1 , # 7 
0DD5    3077E0        4178     JNB FLAGS2 . 7 , COMP_WAIT_ON_COMP_ABLE 
                      4179     
                      4180     PWM_WAIT: 						
0DD8    C3            4181     	CLR	C
0DD9    E58B          4182     	MOV	A, TL1
0DDB    99            4183     SUBB A , R1 
0DDC    40FA          4184     	JC	PWM_WAIT	
                      4185     
                      4186     COMP_READ: 
                      4187     	READ_COMP_OUT 					; Read comparator output
0DDE    E59B          4187+1   MOV A , CPT0CN  ; READ COMPARATOR OUTPUT
0DE0    5440          4188     	ANL	A, #40H
0DE2    B520A3        4189     	CJNE	A, BIT_ACCESS, WAIT_FOR_COMP_OUT_START	; If comparator output is not correct - go back and restart
                      4190     	
0DE5    D8D1          4191     DJNZ R0 , COMP_WAIT_ON_COMP_ABLE 
0DE7    D2AF          4192     	SETB	EA						; Enable interrupts
0DE9    22            4193     	RET							
                      4194     
                      4195     
                      4196     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4197     ;
                      4198     ; Evaluate comparator integrity
                      4199     ;
                      4200     ; No assumptions
                      4201     ;
                      4202     ; Checks comparator signal behaviour versus expected behaviour
                      4203     ;
                      4204     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4205     EVALUATE_COMPARATOR_INTEGRITY: 
0DEA    306D15        4206     JNB FLAGS1 . 5 , EVAL_COMP_CHECK_TIMEOUT 
0DED    E53F          4207     	MOV	A, COMP_WAIT_READS				; Check if there were no waits (there shall be some). If none, motor may be spinning reverse
0DEF    14            4208     	DEC	A
0DF0    7005          4209     	JNZ	EVAL_COMP_STARTUP_OK
                      4210     
0DF2    0539          4211     	INC	DIRECT_STARTUP_FAIL_CNT			; Increment fail counter
0DF4    020E0C        4212     	JMP	EVAL_COMP_EXIT
                      4213     
                      4214     EVAL_COMP_STARTUP_OK: 
0DF7    0538          4215     	INC	DIRECT_STARTUP_OK_CNT			; Increment ok counter
0DF9    206010        4216     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
                      4217     
0DFC    753800        4218     	MOV	DIRECT_STARTUP_OK_CNT, #0		; Reset ok counter
0DFF    020E0C        4219     	JMP	EVAL_COMP_EXIT
                      4220     
                      4221     EVAL_COMP_CHECK_TIMEOUT: 
0E02    206007        4222     JB FLAGS0 . 0 , EVAL_COMP_EXIT 
0E05    1581          4223     	DEC	SP							; Routine exit without "ret" command
0E07    1581          4224     	DEC	SP
0E09    02173E        4225     	LJMP	RUN_TO_WAIT_FOR_POWER_ON			; Yes - exit run mode
                      4226     
                      4227     EVAL_COMP_EXIT: 
0E0C    22            4228     	RET
                      4229     
                      4230     
                      4231     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4232     ;
                      4233     ; Setup commutation timing routine
                      4234     ;
                      4235     ; No assumptions
                      4236     ;
                      4237     ; Sets up and starts wait from commutation to zero cross
                      4238     ;
                      4239     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4240     SETUP_COMM_WAIT:  
0E0D    759100        4241     	MOV	TMR3CN, #00H		; Timer3 disabled
0E10    C3            4242     	CLR	C
0E11    E4            4243     	CLR	A
0E12    954E          4244     	SUBB	A, WT_COMM_L		; Set wait commutation value
0E14    F594          4245     	MOV	TMR3L, A
0E16    E4            4246     	CLR	A
0E17    954F          4247     	SUBB	A, WT_COMM_H		
0E19    F595          4248     	MOV	TMR3H, A
0E1B    759104        4249     	MOV	TMR3CN, #04H		; Timer3 enabled
0E1E    D260          4250     SETB FLAGS0 . 0 
0E20    22            4251     	RET
                      4252     
                      4253     
                      4254     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4255     ;
                      4256     ; Wait for commutation routine
                      4257     ;
                      4258     ; No assumptions
                      4259     ;
                      4260     ; Waits from zero cross to commutation 
                      4261     ;
                      4262     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4263     WAIT_FOR_COMM:  
0E21    306002        4264     JNB FLAGS0 . 0 , ( $+5 ) 
0E24    C121          4265     	AJMP	WAIT_FOR_COMM			; Yes, go back
0E26    22            4266     	RET
                      4267     
                      4268     
                      4269     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4270     ;
                      4271     ; Commutation routines
                      4272     ;
                      4273     ; No assumptions
                      4274     ;
                      4275     ; Performs commutation switching 
                      4276     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                      4277     ;
                      4278     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4279     COMM1COMM2: 	
0E27    C2AF          4280     	CLR 	EA					; Disable all interrupts
                      4281     	BPFET_OFF					; Bp off
0E29    C294          4281+1   CLR P1 . 4 
0E2B    207203        4282     JB FLAGS2 . 2 , COMM12_DAMP 
0E2E    020E4F        4283     	JMP	COMM12_NONDAMP
                      4284     COMM12_DAMP: 
0E31    9002CE        4285     	MOV	DPTR, #PWM_CNFET_APFET_ON_FAST
                      4286     IF DAMPED_MODE_ENABLE == 0
0E34    307303        4287     JNB FLAGS2 . 3 , ( $+6 ) 
0E37    9002F4        4288     	MOV	DPTR, #PWM_CNFET_APFET_ON_SAFE	
0E3A    207412        4289     JB FLAGS2 . 4 , COMM12_NONDAMP 
                      4290     ENDIF
0E3D    30760F        4291     JNB FLAGS2 . 6 , COMM12_NONDAMP 
                      4292     	CPFET_OFF				
0E40    207C02        4292+1   JB FLAGS3 . 4 , ( $+5 ) 
0E43    C292          4292+1   CLR P1 . 2 
0E45    307C02        4292+1   JNB FLAGS3 . 4 , ( $+5 ) 
0E48    C296          4292+1   CLR P1 . 6 
0E4A    7419          4293     MOV A , # 25 
0E4C    D5E0FD        4294     	DJNZ ACC,	$
                      4295     COMM12_NONDAMP: 
                      4296     	APFET_ON					; Ap on
0E4F    207C02        4296+1   JB FLAGS3 . 4 , ( $+5 ) 
0E52    D296          4296+1   SETB P1 . 6 
0E54    307C02        4296+1   JNB FLAGS3 . 4 , ( $+5 ) 
0E57    D292          4296+1   SETB P1 . 2 
                      4297     	SET_COMP_PHASE_B 			; Set comparator to phase B
0E59    759F10        4297+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0E5C    753E02        4298     	MOV	COMM_PHASE, #2
0E5F    D2AF          4299     	SETB	EA					; Enable all interrupts
0E61    22            4300     	RET
                      4301     
                      4302     COMM2COMM3: 	
0E62    C2AF          4303     	CLR 	EA					; Disable all interrupts
0E64    207203        4304     JB FLAGS2 . 2 , COMM23_DAMP 
0E67    020E8A        4305     	JMP	COMM23_NONDAMP
                      4306     COMM23_DAMP: 
0E6A    90028D        4307     	MOV	DPTR, #PWM_BNFET_APFET_ON_FAST
                      4308     IF DAMPED_MODE_ENABLE == 0
0E6D    307303        4309     JNB FLAGS2 . 3 , ( $+6 ) 
0E70    9002AB        4310     	MOV	DPTR, #PWM_BNFET_APFET_ON_SAFE
                      4311     ENDIF
0E73    307617        4312     JNB FLAGS2 . 6 , COMM23_NFET 
                      4313     	BPFET_OFF				
0E76    C294          4313+1   CLR P1 . 4 
                      4314     	CPFET_OFF				
0E78    207C02        4314+1   JB FLAGS3 . 4 , ( $+5 ) 
0E7B    C292          4314+1   CLR P1 . 2 
0E7D    307C02        4314+1   JNB FLAGS3 . 4 , ( $+5 ) 
0E80    C296          4314+1   CLR P1 . 6 
0E82    7419          4315     MOV A , # 25 
0E84    D5E0FD        4316     	DJNZ ACC,	$
0E87    020E8D        4317     	JMP	COMM23_NFET
                      4318     COMM23_NONDAMP: 
0E8A    90018E        4319     	MOV	DPTR, #PWM_BFET_ON	
                      4320     COMM23_NFET: 
                      4321     	CNFET_OFF					; Cn off
0E8D    207C02        4321+1   JB FLAGS3 . 4 , ( $+5 ) 
0E90    D293          4321+1   SETB P1 . 3 
0E92    307C02        4321+1   JNB FLAGS3 . 4 , ( $+5 ) 
0E95    D297          4321+1   SETB P1 . 7 
0E97    306206        4322     JNB FLAGS0 . 2 , COMM23_CP 
                      4323     	BNFET_ON					; Yes - Bn on
0E9A    E526          4323+1   MOV A , CURRENT_PWM_LIMITED 
0E9C    6002          4323+1   JZ ( $+4 ) 
0E9E    C295          4323+1   CLR P1 . 5 
                      4324     COMM23_CP: 
                      4325     	SET_COMP_PHASE_C 			; Set comparator to phase C
0EA0    207C03        4325+1   JB FLAGS3 . 4 , ( $+6 ) 
0EA3    759F13        4325+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0EA6    307C03        4325+1   JNB FLAGS3 . 4 , ( $+6 ) 
0EA9    759F11        4325+1   MOV CPT0MX , # 11H 
0EAC    753E03        4326     	MOV	COMM_PHASE, #3
0EAF    D2AF          4327     	SETB	EA					; Enable all interrupts
0EB1    22            4328     	RET
                      4329     
                      4330     COMM3COMM4: 	
0EB2    C2AF          4331     	CLR 	EA					; Disable all interrupts
                      4332     	APFET_OFF					; Ap off
0EB4    207C02        4332+1   JB FLAGS3 . 4 , ( $+5 ) 
0EB7    C296          4332+1   CLR P1 . 6 
0EB9    307C02        4332+1   JNB FLAGS3 . 4 , ( $+5 ) 
0EBC    C292          4332+1   CLR P1 . 2 
0EBE    207203        4333     JB FLAGS2 . 2 , COMM34_DAMP 
0EC1    020EDA        4334     	JMP	COMM34_NONDAMP
                      4335     COMM34_DAMP: 
0EC4    90024C        4336     	MOV	DPTR, #PWM_BNFET_CPFET_ON_FAST
                      4337     IF DAMPED_MODE_ENABLE == 0
0EC7    307303        4338     JNB FLAGS2 . 3 , ( $+6 ) 
0ECA    90026A        4339     	MOV	DPTR, #PWM_BNFET_CPFET_ON_SAFE
0ECD    20740A        4340     JB FLAGS2 . 4 , COMM34_NONDAMP 
                      4341     ENDIF
0ED0    307607        4342     JNB FLAGS2 . 6 , COMM34_NONDAMP 
                      4343     	BPFET_OFF				
0ED3    C294          4343+1   CLR P1 . 4 
0ED5    7419          4344     MOV A , # 25 
0ED7    D5E0FD        4345     	DJNZ ACC,	$
                      4346     COMM34_NONDAMP: 
                      4347     	CPFET_ON					; Cp on
0EDA    207C02        4347+1   JB FLAGS3 . 4 , ( $+5 ) 
0EDD    D292          4347+1   SETB P1 . 2 
0EDF    307C02        4347+1   JNB FLAGS3 . 4 , ( $+5 ) 
0EE2    D296          4347+1   SETB P1 . 6 
                      4348     	SET_COMP_PHASE_A 			; Set comparator to phase A
0EE4    207C03        4348+1   JB FLAGS3 . 4 , ( $+6 ) 
0EE7    759F11        4348+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0EEA    307C03        4348+1   JNB FLAGS3 . 4 , ( $+6 ) 
0EED    759F13        4348+1   MOV CPT0MX , # 13H 
0EF0    753E04        4349     	MOV	COMM_PHASE, #4
0EF3    D2AF          4350     	SETB	EA					; Enable all interrupts
0EF5    22            4351     	RET
                      4352     
                      4353     COMM4COMM5: 	
0EF6    C2AF          4354     	CLR 	EA					; Disable all interrupts
0EF8    207203        4355     JB FLAGS2 . 2 , COMM45_DAMP 
0EFB    020F1E        4356     	JMP	COMM45_NONDAMP
                      4357     COMM45_DAMP: 
0EFE    90020B        4358     	MOV	DPTR, #PWM_ANFET_CPFET_ON_FAST
                      4359     IF DAMPED_MODE_ENABLE == 0
0F01    307303        4360     JNB FLAGS2 . 3 , ( $+6 ) 
0F04    900229        4361     	MOV	DPTR, #PWM_ANFET_CPFET_ON_SAFE
                      4362     ENDIF
0F07    307617        4363     JNB FLAGS2 . 6 , COMM45_NFET 
                      4364     	APFET_OFF				
0F0A    207C02        4364+1   JB FLAGS3 . 4 , ( $+5 ) 
0F0D    C296          4364+1   CLR P1 . 6 
0F0F    307C02        4364+1   JNB FLAGS3 . 4 , ( $+5 ) 
0F12    C292          4364+1   CLR P1 . 2 
                      4365     	BPFET_OFF				
0F14    C294          4365+1   CLR P1 . 4 
0F16    7419          4366     MOV A , # 25 
0F18    D5E0FD        4367     	DJNZ ACC,	$
0F1B    020F21        4368     	JMP	COMM45_NFET
                      4369     COMM45_NONDAMP: 
0F1E    90017C        4370     	MOV	DPTR, #PWM_AFET_ON
                      4371     COMM45_NFET: 
                      4372     	BNFET_OFF					; Bn off
0F21    D295          4372+1   SETB P1 . 5 
0F23    30620E        4373     JNB FLAGS0 . 2 , COMM45_CP 
                      4374     	ANFET_ON					; Yes - An on
0F26    E526          4374+1   MOV A , CURRENT_PWM_LIMITED 
0F28    600A          4374+1   JZ ( $+12 ) 
0F2A    207C02        4374+1   JB FLAGS3 . 4 , ( $+5 ) 
0F2D    C297          4374+1   CLR P1 . 7 
0F2F    307C02        4374+1   JNB FLAGS3 . 4 , ( $+5 ) 
0F32    C293          4374+1   CLR P1 . 3 
                      4375     COMM45_CP: 
                      4376     	SET_COMP_PHASE_B 			; Set comparator to phase B
0F34    759F10        4376+1   MOV CPT0MX , # 10H  ; SET COMPARATOR MULTIPLEXER TO PHASE B
0F37    753E05        4377     	MOV	COMM_PHASE, #5
0F3A    D2AF          4378     	SETB	EA					; Enable all interrupts
0F3C    22            4379     	RET
                      4380     
                      4381     COMM5COMM6: 	
0F3D    C2AF          4382     	CLR 	EA					; Disable all interrupts
                      4383     	CPFET_OFF					; Cp off
0F3F    207C02        4383+1   JB FLAGS3 . 4 , ( $+5 ) 
0F42    C292          4383+1   CLR P1 . 2 
0F44    307C02        4383+1   JNB FLAGS3 . 4 , ( $+5 ) 
0F47    C296          4383+1   CLR P1 . 6 
0F49    207203        4384     JB FLAGS2 . 2 , COMM56_DAMP 
0F4C    020F6D        4385     	JMP	COMM56_NONDAMP
                      4386     COMM56_DAMP: 
0F4F    9001BA        4387     	MOV	DPTR, #PWM_ANFET_BPFET_ON_FAST
                      4388     IF DAMPED_MODE_ENABLE == 0
0F52    307303        4389     JNB FLAGS2 . 3 , ( $+6 ) 
0F55    9001E0        4390     	MOV	DPTR, #PWM_ANFET_BPFET_ON_SAFE
0F58    207412        4391     JB FLAGS2 . 4 , COMM56_NONDAMP 
                      4392     ENDIF
0F5B    30760F        4393     JNB FLAGS2 . 6 , COMM56_NONDAMP 
                      4394     	APFET_OFF				
0F5E    207C02        4394+1   JB FLAGS3 . 4 , ( $+5 ) 
0F61    C296          4394+1   CLR P1 . 6 
0F63    307C02        4394+1   JNB FLAGS3 . 4 , ( $+5 ) 
0F66    C292          4394+1   CLR P1 . 2 
0F68    7419          4395     MOV A , # 25 
0F6A    D5E0FD        4396     	DJNZ ACC,	$
                      4397     COMM56_NONDAMP: 
                      4398     	BPFET_ON					; Bp on
0F6D    D294          4398+1   SETB P1 . 4 
                      4399     	SET_COMP_PHASE_C 			; Set comparator to phase C
0F6F    207C03        4399+1   JB FLAGS3 . 4 , ( $+6 ) 
0F72    759F13        4399+1   MOV CPT0MX , # 13H  ; SET COMPARATOR MULTIPLEXER TO PHASE C
0F75    307C03        4399+1   JNB FLAGS3 . 4 , ( $+6 ) 
0F78    759F11        4399+1   MOV CPT0MX , # 11H 
0F7B    753E06        4400     	MOV	COMM_PHASE, #6
0F7E    D2AF          4401     	SETB	EA					; Enable all interrupts
0F80    22            4402     	RET
                      4403     
                      4404     COMM6COMM1: 	
0F81    C2AF          4405     	CLR 	EA					; Disable all interrupts
0F83    207203        4406     JB FLAGS2 . 2 , COMM61_DAMP 
0F86    020FB1        4407     	JMP	COMM61_NONDAMP
                      4408     COMM61_DAMP: 
0F89    90031F        4409     	MOV	DPTR, #PWM_CNFET_BPFET_ON_FAST
                      4410     IF DAMPED_MODE_ENABLE == 0
0F8C    307303        4411     JNB FLAGS2 . 3 , ( $+6 ) 
0F8F    90034D        4412     	MOV	DPTR, #PWM_CNFET_BPFET_ON_SAFE
                      4413     ENDIF
0F92    30761F        4414     JNB FLAGS2 . 6 , COMM61_NFET 
                      4415     	APFET_OFF				
0F95    207C02        4415+1   JB FLAGS3 . 4 , ( $+5 ) 
0F98    C296          4415+1   CLR P1 . 6 
0F9A    307C02        4415+1   JNB FLAGS3 . 4 , ( $+5 ) 
0F9D    C292          4415+1   CLR P1 . 2 
                      4416     	CPFET_OFF				
0F9F    207C02        4416+1   JB FLAGS3 . 4 , ( $+5 ) 
0FA2    C292          4416+1   CLR P1 . 2 
0FA4    307C02        4416+1   JNB FLAGS3 . 4 , ( $+5 ) 
0FA7    C296          4416+1   CLR P1 . 6 
0FA9    7419          4417     MOV A , # 25 
0FAB    D5E0FD        4418     	DJNZ ACC,	$
0FAE    020FB4        4419     	JMP	COMM61_NFET
                      4420     COMM61_NONDAMP: 
0FB1    9001A0        4421     	MOV	DPTR, #PWM_CFET_ON
                      4422     COMM61_NFET: 
                      4423     	ANFET_OFF					; An off
0FB4    207C02        4423+1   JB FLAGS3 . 4 , ( $+5 ) 
0FB7    D297          4423+1   SETB P1 . 7 
0FB9    307C02        4423+1   JNB FLAGS3 . 4 , ( $+5 ) 
0FBC    D293          4423+1   SETB P1 . 3 
0FBE    30620E        4424     JNB FLAGS0 . 2 , COMM61_CP 
                      4425     	CNFET_ON					; Yes - Cn on
0FC1    E526          4425+1   MOV A , CURRENT_PWM_LIMITED 
0FC3    600A          4425+1   JZ ( $+12 ) 
0FC5    207C02        4425+1   JB FLAGS3 . 4 , ( $+5 ) 
0FC8    C293          4425+1   CLR P1 . 3 
0FCA    307C02        4425+1   JNB FLAGS3 . 4 , ( $+5 ) 
0FCD    C297          4425+1   CLR P1 . 7 
                      4426     COMM61_CP: 
                      4427     	SET_COMP_PHASE_A 			; Set comparator to phase A
0FCF    207C03        4427+1   JB FLAGS3 . 4 , ( $+6 ) 
0FD2    759F11        4427+1   MOV CPT0MX , # 11H  ; SET COMPARATOR MULTIPLEXER TO PHASE A
0FD5    307C03        4427+1   JNB FLAGS3 . 4 , ( $+6 ) 
0FD8    759F13        4427+1   MOV CPT0MX , # 13H 
0FDB    753E01        4428     	MOV	COMM_PHASE, #1
0FDE    D2AF          4429     	SETB	EA					; Enable all interrupts
0FE0    22            4430     	RET
                      4431     
                      4432     
                      4433     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4434     ;
                      4435     ; Switch power off routine
                      4436     ;
                      4437     ; No assumptions
                      4438     ;
                      4439     ; Switches all fets off 
                      4440     ;
                      4441     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4442     SWITCH_POWER_OFF: 
0FE1    90017A        4443     	MOV	DPTR, #PWM_NOFET_ON	; Set DPTR register to pwm_nofet_on label		
                      4444     	ALL_NFETS_OFF			; Turn off all nfets
0FE4    D297          4444+1   SETB P1 . 7 
0FE6    D295          4444+1   SETB P1 . 5 
0FE8    D293          4444+1   SETB P1 . 3 
                      4445     	ALL_PFETS_OFF			; Turn off all pfets
0FEA    C296          4445+1   CLR P1 . 6 
0FEC    C294          4445+1   CLR P1 . 4 
0FEE    C292          4445+1   CLR P1 . 2 
0FF0    22            4446     	RET			
                      4447     
                      4448     
                      4449     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4450     ;
                      4451     ; Decrement stepper step routine
                      4452     ;
                      4453     ; No assumptions
                      4454     ;
                      4455     ; Decrements the stepper step 
                      4456     ;
                      4457     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4458     DECREMENT_STEPPER_STEP: 
0FF1    C3            4459     	CLR	C
0FF2    E550          4460     	MOV	A, WT_STEPPER_STEP_L
0FF4    9535          4461     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
0FF6    E551          4462     	MOV	A, WT_STEPPER_STEP_H
0FF8    9536          4463     	SUBB	A, STEPPER_STEP_END_H	
0FFA    5001          4464     	JNC	DECREMENT_STEP				; Branch if same or higher than minimum
0FFC    22            4465     	RET
                      4466     
                      4467     DECREMENT_STEP: 
                      4468     	; Load programmed startup acceleration
0FFD    788E          4469     MOV R0 , # PGM_STARTUP_ACCEL 
0FFF    E6            4470     MOV A , @ R0 
1000    FF            4471     MOV R7 , A 
                      4472     	; Check acceleration setting and set step size accordingly
1001    C3            4473     	CLR	C
1002    EF            4474     MOV A , R7 
1003    9405          4475     	SUBB	A, #5
1005    5018          4476     	JNC	DEC_STEP_HIGH
1007    C3            4477     	CLR	C
1008    EF            4478     MOV A , R7 
1009    9404          4479     	SUBB	A, #4
100B    501B          4480     	JNC	DEC_STEP_MED_HIGH
100D    C3            4481     	CLR	C
100E    EF            4482     MOV A , R7 
100F    9403          4483     	SUBB	A, #3
1011    501E          4484     	JNC	DEC_STEP_MED
1013    C3            4485     	CLR	C
1014    EF            4486     MOV A , R7 
1015    9402          4487     	SUBB	A, #2
1017    5021          4488     	JNC	DEC_STEP_MED_LOW
1019    C3            4489     	CLR	C
101A    EF            4490     MOV A , R7 
101B    9401          4491     	SUBB	A, #1
101D    5023          4492     	JNC	DEC_STEP_LOW
                      4493     
                      4494     DEC_STEP_HIGH: 
101F    C3            4495     	CLR	C
1020    E550          4496     	MOV	A, WT_STEPPER_STEP_L
1022    943C          4497     	SUBB	A, #LOW(30 SHL 1)		
1024    F8            4498     MOV R0 , A 
1025    02104A        4499     	JMP	DECREMENT_STEP_EXIT
                      4500     DEC_STEP_MED_HIGH: 
1028    C3            4501     	CLR	C
1029    E550          4502     	MOV	A, WT_STEPPER_STEP_L
102B    9428          4503     	SUBB	A, #LOW(20 SHL 1)		
102D    F8            4504     MOV R0 , A 
102E    02104A        4505     	JMP	DECREMENT_STEP_EXIT
                      4506     DEC_STEP_MED: 
1031    C3            4507     	CLR	C
1032    E550          4508     	MOV	A, WT_STEPPER_STEP_L
1034    941A          4509     	SUBB	A, #LOW(13 SHL 1)		
1036    F8            4510     MOV R0 , A 
1037    02104A        4511     	JMP	DECREMENT_STEP_EXIT
                      4512     DEC_STEP_MED_LOW: 
103A    C3            4513     	CLR	C
103B    E550          4514     	MOV	A, WT_STEPPER_STEP_L
103D    9412          4515     	SUBB	A, #LOW(9 SHL 1)		
103F    F8            4516     MOV R0 , A 
1040    014A          4517     	AJMP	DECREMENT_STEP_EXIT
                      4518     DEC_STEP_LOW: 
1042    C3            4519     	CLR	C
1043    E550          4520     	MOV	A, WT_STEPPER_STEP_L
1045    940A          4521     	SUBB	A, #LOW(5 SHL 1)		
1047    F8            4522     MOV R0 , A 
1048    014A          4523     	AJMP	DECREMENT_STEP_EXIT
                      4524     
                      4525     DECREMENT_STEP_EXIT: 
104A    E551          4526     	MOV	A, WT_STEPPER_STEP_H
104C    9400          4527     	SUBB	A, #0		
104E    F9            4528     MOV R1 , A 
104F    8850          4529     MOV WT_STEPPER_STEP_L , R0 
1051    8951          4530     MOV WT_STEPPER_STEP_H , R1 
1053    22            4531     	RET
                      4532     
                      4533     
                      4534     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4535     ;
                      4536     ; Stepper timer wait
                      4537     ;
                      4538     ; No assumptions
                      4539     ;
                      4540     ; Waits for the stepper step timer to elapse
                      4541     ;
                      4542     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4543     STEPPER_TIMER_WAIT: 
1054    306003        4544     JNB FLAGS0 . 0 , ( $+6 ) 
1057    021054        4545     	LJMP	STEPPER_TIMER_WAIT		; Yes, go back
105A    22            4546     	RET
                      4547     
                      4548     
                      4549     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4550     ;
                      4551     ; Set default parameters
                      4552     ;
                      4553     ; No assumptions
                      4554     ;
                      4555     ; Sets default programming parameters
                      4556     ;
                      4557     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4558     SET_DEFAULT_PARAMETERS: 
                      4559     IF MODE == 0	; Main
                               	MOV	TEMP1, #PGM_GOV_P_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_P_GAIN
                               	MOV	TEMP1, #PGM_GOV_I_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_I_GAIN
                               	MOV	TEMP1, #PGM_GOV_MODE
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
                               	MOV	TEMP1, #PGM_GOV_RANGE
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
                               	MOV	TEMP1, #PGM_LOW_VOLTAGE_LIM
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
                               	MOV	TEMP1, #PGM_STARTUP_PWR
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_PWR
                               	MOV	TEMP1, #PGM_STARTUP_RPM
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_RPM
                               	MOV	TEMP1, #PGM_STARTUP_ACCEL
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_ACCEL
                               	MOV	TEMP1, #PGM_STARTUP_METHOD
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_STARTUP_METHOD
                               	MOV	TEMP1, #PGM_COMM_TIMING
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_COMM_TIMING
                               	MOV	TEMP1, #PGM_THROTTLE_RATE
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_THROTTLE_RATE
                               	MOV	TEMP1, #PGM_DAMPING_FORCE
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DAMPING_FORCE
                               	MOV	TEMP1, #PGM_PWM_FREQ
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_PWM_FREQ
                               	MOV	TEMP1, #PGM_VOLT_COMP
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_VOLT_COMP
                               	MOV	TEMP1, #PGM_DIRECTION_REV
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_DIRECTION_REV
                               	MOV	TEMP1, #PGM_INPUT_POL
                               	MOV	@TEMP1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                               	MOV	TEMP1, #PGM_MOTOR_IDLE
                               	MOV	@TEMP1, #0
                               ENDIF
                      4595     IF MODE == 1	; Tail
                               	MOV	TEMP1, #PGM_MOTOR_GAIN
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_GAIN
                               	MOV	TEMP1, #PGM_MOTOR_IDLE
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                               	MOV	TEMP1, #PGM_STARTUP_PWR
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                               	MOV	TEMP1, #PGM_STARTUP_RPM
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_RPM
                               	MOV	TEMP1, #PGM_STARTUP_ACCEL
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_ACCEL
                               	MOV	TEMP1, #PGM_STARTUP_METHOD
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_STARTUP_METHOD
                               	MOV	TEMP1, #PGM_COMM_TIMING
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_COMM_TIMING
                               	MOV	TEMP1, #PGM_THROTTLE_RATE
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_THROTTLE_RATE
                               	MOV	TEMP1, #PGM_DAMPING_FORCE
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DAMPING_FORCE
                               	MOV	TEMP1, #PGM_PWM_FREQ
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_PWM_FREQ
                               	MOV	TEMP1, #PGM_VOLT_COMP
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_VOLT_COMP
                               	MOV	TEMP1, #PGM_DIRECTION_REV
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_DIRECTION_REV
                               	MOV	TEMP1, #PGM_INPUT_POL
                               	MOV	@TEMP1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                               	MOV	TEMP1, #PGM_GOV_MODE
                               	MOV	@TEMP1, #4
                               ENDIF
                      4625     IF MODE == 2	; Multi
105B    7887          4626     MOV R0 , # PGM_MOTOR_GAIN 
105D    7603          4627     MOV @ R0 , # 3 
105F    7886          4628     MOV R0 , # PGM_LOW_VOLTAGE_LIM 
1061    7603          4629     MOV @ R0 , # 3 
1063    7889          4630     MOV R0 , # PGM_STARTUP_PWR 
1065    7603          4631     MOV @ R0 , # 3 
1067    788D          4632     MOV R0 , # PGM_STARTUP_RPM 
1069    7601          4633     MOV @ R0 , # 1 
106B    788E          4634     MOV R0 , # PGM_STARTUP_ACCEL 
106D    7605          4635     MOV @ R0 , # 5 
106F    788F          4636     MOV R0 , # PGM_STARTUP_METHOD 
1071    7602          4637     MOV @ R0 , # 2 
1073    7890          4638     MOV R0 , # PGM_COMM_TIMING 
1075    7603          4639     MOV @ R0 , # 3 
1077    7891          4640     MOV R0 , # PGM_THROTTLE_RATE 
1079    760D          4641     MOV @ R0 , # 13 
107B    7893          4642     MOV R0 , # PGM_DAMPING_FORCE 
107D    7602          4643     MOV @ R0 , # 2 
107F    7894          4644     MOV R0 , # PGM_PWM_FREQ 
1081    7601          4645     MOV @ R0 , # 1 
1083    7895          4646     MOV R0 , # PGM_VOLT_COMP 
1085    7601          4647     MOV @ R0 , # 1 
1087    7896          4648     MOV R0 , # PGM_DIRECTION_REV 
1089    7601          4649     MOV @ R0 , # 1 
108B    7897          4650     MOV R0 , # PGM_INPUT_POL 
108D    7601          4651     MOV @ R0 , # 1 
108F    7888          4652     MOV R0 , # PGM_MOTOR_IDLE 
1091    7600          4653     MOV @ R0 , # 0 
1093    7884          4654     MOV R0 , # PGM_GOV_MODE 
1095    7604          4655     MOV @ R0 , # 4 
                      4656     ENDIF
1097    788A          4657     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
1099    7601          4658     MOV @ R0 , # 1 
109B    788B          4659     MOV R0 , # PGM_MAIN_REARM_START 
109D    7600          4660     MOV @ R0 , # 0 
109F    788C          4661     MOV R0 , # PGM_GOV_SETUP_TARGET 
10A1    76B4          4662     MOV @ R0 , # 180 
10A3    7898          4663     MOV R0 , # PGM_PPM_MIN_THROTTLE 
10A5    7625          4664     MOV @ R0 , # 37 
10A7    7899          4665     MOV R0 , # PGM_PPM_MAX_THROTTLE 
10A9    76D0          4666     MOV @ R0 , # 208 
10AB    789A          4667     MOV R0 , # PGM_BEEP_STRENGTH 
10AD    7678          4668     MOV @ R0 , # 120 
10AF    789B          4669     MOV R0 , # PGM_BEACON_STRENGTH 
10B1    76C8          4670     MOV @ R0 , # 200 
10B3    789C          4671     MOV R0 , # PGM_BEACON_DELAY 
10B5    7601          4672     MOV @ R0 , # 1 
10B7    22            4673     	RET
                      4674     
                      4675     
                      4676     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4677     ;
                      4678     ; Decode parameters
                      4679     ;
                      4680     ; No assumptions
                      4681     ;
                      4682     ; Decodes programming parameters
                      4683     ;
                      4684     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4685     DECODE_PARAMETERS: 
                      4686     	; Load programmed damping force
10B8    7893          4687     MOV R0 , # PGM_DAMPING_FORCE 
10BA    E6            4688     MOV A , @ R0 
10BB    FF            4689     MOV R7 , A 
                      4690     	; Decode damping
10BC    756309        4691     	MOV	DAMPING_PERIOD, #9		; Set default
10BF    756401        4692     	MOV	DAMPING_ON, #1
10C2    C3            4693     	CLR	C
10C3    EF            4694     MOV A , R7 
10C4    9402          4695     	SUBB	A, #2
10C6    7009          4696     	JNZ	DECODE_DAMPING_3
                      4697     
10C8    756305        4698     	MOV	DAMPING_PERIOD, #5
10CB    756401        4699     	MOV	DAMPING_ON, #1
10CE    0210FB        4700     	JMP	DECODE_DAMPING_DONE
                      4701     
                      4702     DECODE_DAMPING_3: 
10D1    C3            4703     	CLR	C
10D2    EF            4704     MOV A , R7 
10D3    9403          4705     	SUBB	A, #3
10D5    7009          4706     	JNZ	DECODE_DAMPING_4
                      4707     
10D7    756305        4708     	MOV	DAMPING_PERIOD, #5
10DA    756402        4709     	MOV	DAMPING_ON, #2
10DD    0210FB        4710     	JMP	DECODE_DAMPING_DONE
                      4711     
                      4712     DECODE_DAMPING_4: 
10E0    C3            4713     	CLR	C
10E1    EF            4714     MOV A , R7 
10E2    9404          4715     	SUBB	A, #4
10E4    7009          4716     	JNZ	DECODE_DAMPING_5
                      4717     
10E6    756305        4718     	MOV	DAMPING_PERIOD, #5
10E9    756403        4719     	MOV	DAMPING_ON, #3
10EC    0210FB        4720     	JMP	DECODE_DAMPING_DONE
                      4721     
                      4722     DECODE_DAMPING_5: 
10EF    C3            4723     	CLR	C
10F0    EF            4724     MOV A , R7 
10F1    9405          4725     	SUBB	A, #5
10F3    7006          4726     	JNZ	DECODE_DAMPING_DONE
                      4727     
10F5    756309        4728     	MOV	DAMPING_PERIOD, #9
10F8    756407        4729     	MOV	DAMPING_ON, #7
                      4730     
                      4731     DECODE_DAMPING_DONE: 
                      4732     	; Load programmed pwm frequency
10FB    7894          4733     MOV R0 , # PGM_PWM_FREQ 
10FD    E6            4734     MOV A , @ R0 
10FE    FF            4735     MOV R7 , A 
                      4736     IF MODE == 0	; Main
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	C
                               	MOV	A, TEMP8			
                               	SUBB	A, #3
                               	JNZ	($+4)
                               	SETB	FLAGS2.PGM_PWMOFF_DAMPED_LIGHT
                               	CLR	FLAGS2.PGM_PWMOFF_DAMPED_FULL
                               ENDIF
                      4745     IF MODE >= 1	; Tail or multi
10FF    C274          4746     CLR FLAGS2 . 4 
1101    C3            4747     	CLR	C
1102    EF            4748     MOV A , R7 
1103    9403          4749     	SUBB	A, #3
1105    7002          4750     	JNZ	($+4)
1107    D274          4751     SETB FLAGS2 . 4 
1109    C273          4752     CLR FLAGS2 . 3 
110B    C3            4753     	CLR	C
110C    EF            4754     MOV A , R7 
110D    9404          4755     	SUBB	A, #4
110F    7002          4756     	JNZ	($+4)					
1111    D273          4757     SETB FLAGS2 . 3 
                      4758     ENDIF
1113    C272          4759     CLR FLAGS2 . 2 
1115    7418          4760     	MOV	A, #((1 SHL PGM_PWMOFF_DAMPED_FULL)+(1 SHL PGM_PWMOFF_DAMPED_LIGHT))
1117    552E          4761     	ANL	A, FLAGS2					; Check if any damped mode is set
1119    6002          4762     	JZ	($+4)
111B    D272          4763     SETB FLAGS2 . 2 
111D    C276          4764     CLR FLAGS2 . 6 
111F    6002          4765     	JZ	($+4)
1121    D276          4766     SETB FLAGS2 . 6 
1123    D277          4767     SETB FLAGS2 . 7 
1125    6002          4768     	JZ	($+4)
1127    C277          4769     CLR FLAGS2 . 7 
1129    C27C          4770     CLR FLAGS3 . 4 
112B    7896          4771     MOV R0 , # PGM_DIRECTION_REV 
112D    E6            4772     MOV A , @ R0 
112E    30E102        4773     	JNB	ACC.1, ($+5)
1131    D27C          4774     SETB FLAGS3 . 4 
1133    C27D          4775     CLR FLAGS3 . 5 
1135    7897          4776     MOV R0 , # PGM_INPUT_POL 
1137    E6            4777     MOV A , @ R0 
1138    30E102        4778     	JNB	ACC.1, ($+5)
113B    D27D          4779     SETB FLAGS3 . 5 
113D    C3            4780     	CLR	C
113E    EF            4781     MOV A , R7 
113F    9402          4782     	SUBB	A, #2
1141    6008          4783     	JZ	DECODE_PWM_FREQ_LOW
                      4784     
1143    758E01        4785     	MOV	CKCON, #01H		; Timer0 set for clk/4 (22kHz pwm)
1146    D275          4786     SETB FLAGS2 . 5 
1148    021150        4787     	JMP	DECODE_PWM_FREQ_END
                      4788     
                      4789     DECODE_PWM_FREQ_LOW: 
114B    758E00        4790     	MOV	CKCON, #00H		; Timer0 set for clk/12 (8kHz pwm)
114E    C275          4791     CLR FLAGS2 . 5 
                      4792     
                      4793     DECODE_PWM_FREQ_END: 
1150    22            4794     	RET
                      4795     
                      4796     
                      4797     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4798     ;
                      4799     ; Decode governor gain
                      4800     ;
                      4801     ; No assumptions
                      4802     ;
                      4803     ; Decodes governor gains
                      4804     ;
                      4805     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4806     DECODE_GOVERNOR_GAINS: 
                      4807     	; Decode governor gains
1151    7880          4808     MOV R0 , # PGM_GOV_P_GAIN 
1153    E6            4809     MOV A , @ R0 
1154    14            4810     	DEC	A	
1155    900080        4811     	MOV	DPTR, #GOV_GAIN_TABLE
1158    93            4812     	MOVC A, @A+DPTR	
1159    7882          4813     MOV R0 , # PGM_GOV_P_GAIN_DECODED 
115B    F6            4814     MOV @ R0 , A 
115C    7881          4815     MOV R0 , # PGM_GOV_I_GAIN 
115E    E6            4816     MOV A , @ R0 
115F    14            4817     	DEC	A	
1160    900080        4818     	MOV	DPTR, #GOV_GAIN_TABLE
1163    93            4819     	MOVC A, @A+DPTR	
1164    7883          4820     MOV R0 , # PGM_GOV_I_GAIN_DECODED 
1166    F6            4821     MOV @ R0 , A 
1167    120FE1        4822     	CALL	SWITCH_POWER_OFF		; Reset DPTR
116A    22            4823     	RET
                      4824     
                      4825     
                      4826     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4827     ;
                      4828     ; Decode throttle rate
                      4829     ;
                      4830     ; No assumptions
                      4831     ;
                      4832     ; Decodes throttle rate
                      4833     ;
                      4834     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4835     DECODE_THROTTLE_RATE: 
                      4836     	; Decode throttle rate
116B    7891          4837     MOV R0 , # PGM_THROTTLE_RATE 
116D    E6            4838     MOV A , @ R0 
116E    14            4839     	DEC	A	
116F    90008D        4840     	MOV	DPTR, #THROTTLE_RATE_TABLE
1172    93            4841     	MOVC A, @A+DPTR	
1173    7892          4842     MOV R0 , # PGM_THROTTLE_RATE_DECODED 
1175    F6            4843     MOV @ R0 , A 
1176    120FE1        4844     	CALL	SWITCH_POWER_OFF			; Reset DPTR
1179    22            4845     	RET
                      4846     
                      4847     
                      4848     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4849     ;
                      4850     ; Find throttle gain
                      4851     ;
                      4852     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Throttle difference of 130)
                      4853     ;
                      4854     ; Finds throttle gain from throttle calibration values
                      4855     ;
                      4856     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4857     FIND_THROTTLE_GAIN: 
                      4858     	; Load programmed minimum and maximum throttle
117A    7898          4859     MOV R0 , # PGM_PPM_MIN_THROTTLE 
117C    E6            4860     MOV A , @ R0 
117D    FA            4861     MOV R2 , A 
117E    7899          4862     MOV R0 , # PGM_PPM_MAX_THROTTLE 
1180    E6            4863     MOV A , @ R0 
1181    FB            4864     MOV R3 , A 
                      4865     	; Check if full range is chosen
1182    307E04        4866     JNB FLAGS3 . 6 , FIND_THROTTLE_GAIN_CALCULATE 
                      4867     
1185    7A00          4868     MOV R2 , # 0 
1187    7BFF          4869     MOV R3 , # 255 
                      4870     
                      4871     FIND_THROTTLE_GAIN_CALCULATE: 
                      4872     	; Calculate difference
1189    C3            4873     	CLR	C
118A    EB            4874     MOV A , R3 
118B    9A            4875     SUBB A , R2 
118C    FC            4876     MOV R4 , A 
                      4877     	; Check that difference is minimum 130
118D    C3            4878     	CLR	C
118E    9482          4879     	SUBB	A, #130
1190    5002          4880     	JNC	($+4)
                      4881     
1192    7C82          4882     MOV R4 , # 130 
                      4883     
                      4884     	; Find gain
1194    756B00        4885     	MOV	PPM_THROTTLE_GAIN, #0
                      4886     TEST_GAIN: 
1197    056B          4887     	INC	PPM_THROTTLE_GAIN
1199    EC            4888     MOV A , R4 
119A    856BF0        4889     	MOV	B, PPM_THROTTLE_GAIN	; A has difference, B has gain
119D    A4            4890     	MUL	AB
119E    C3            4891     	CLR	C
119F    E5F0          4892     	MOV	A, B
11A1    9480          4893     	SUBB	A, #128
11A3    40F2          4894     	JC	TEST_GAIN
11A5    22            4895     	RET
                      4896     
                      4897     
                      4898     
                      4899     
                      4900     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4901     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4902     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4903     ;
                      4904     ; Main program start
                      4905     ;
                      4906     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4907     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4908     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      4909     
                      4910     RESET: 
                      4911     	; Select register bank 0 for main program routines
11A6    C2D3          4912     	CLR	PSW.3			; Select register bank 0 for main program routines	
                      4913     	; Disable the WDT.
11A8    53D9BF        4914     	ANL	PCA0MD, #NOT(40H)	; Clear watchdog enable bit
                      4915     	; Initialize stack
11AB    7581C0        4916     	MOV	SP, #0C0H			; Stack = 64 upper bytes of RAM
                      4917     	; Initialize VDD monitor
11AE    43FF80        4918     	ORL	VDM0CN, #080H    	; Enable the VDD monitor
11B1    1206C3        4919     	CALL	WAIT1MS			; Wait at least 100us
                      4920     	; Set clock frequency
11B4    43B203        4921     	ORL	OSCICN, #03H		; Set clock divider to 1
11B7    E5B3          4922     	MOV	A, OSCICL				
11B9    2404          4923     	ADD	A, #04H			; 24.5MHz to 24MHz (~0.5% per step)
11BB    4002          4924     	JC	RESET_CAL_DONE		; Is carry set? - skip next instruction
                      4925     
11BD    F5B3          4926     	MOV	OSCICL, A
                      4927     
                      4928     RESET_CAL_DONE: 
                      4929     	; Ports initialization
11BF    7580FF        4930     MOV P0 , # 255 
11C2    7590A9        4931     MOV P1 , # 169 
11C5    75A400        4932     MOV P0MDOUT , # 0 
11C8    75A5FC        4933     MOV P1MDOUT , # 252 
11CB    75A601        4934     MOV P2MDOUT , # 1 
11CE    75F1B2        4935     MOV P0MDIN , # -78 
11D1    75F2FC        4936     MOV P1MDIN , # 252 
11D4    75D4DF        4937     MOV P0SKIP , # 223 
11D7    75D501        4938     MOV P1SKIP , # 1 
11DA    75E241        4939     	MOV	XBR1, #41H		; Xbar enabled, CEX0 routed to pin Rcp_In			
                      4940     	; Switch power off
11DD    120FE1        4941     	CALL	SWITCH_POWER_OFF
                      4942     	; Clear RAM
11E0    E4            4943     	CLR	A				; Clear accumulator
11E1    F8            4944     MOV R0 , A 
                      4945     CLEAR_RAM: 	
11E2    F6            4946     MOV @ R0 , A 
11E3    D8FD          4947     DJNZ R0 , CLEAR_RAM 
                      4948     	; Set default programmed parameters
11E5    115B          4949     	CALL	SET_DEFAULT_PARAMETERS
                      4950     	; Read all programmed parameters
11E7    1217B1        4951     	CALL READ_ALL_EEPROM_PARAMETERS
                      4952     	; Decode parameters
11EA    11B8          4953     	CALL	DECODE_PARAMETERS
                      4954     	; Decode governor gains
11EC    3151          4955     	CALL	DECODE_GOVERNOR_GAINS
                      4956     	; Decode throttle rate
11EE    316B          4957     	CALL	DECODE_THROTTLE_RATE
                      4958     	; Find throttle gain from stored min and max settings
11F0    317A          4959     	CALL	FIND_THROTTLE_GAIN
                      4960     	; Set beep strength
11F2    789A          4961     MOV R0 , # PGM_BEEP_STRENGTH 
11F4    866C          4962     MOV BEEP_STRENGTH , @ R0 
                      4963     	; Switch power off
11F6    120FE1        4964     	CALL	SWITCH_POWER_OFF
                      4965     	; Timer control
11F9    758850        4966     	MOV	TCON, #50H		; Timer0 and timer1 enabled
                      4967     	; Timer mode
11FC    758902        4968     	MOV	TMOD, #02H		; Timer0 as 8bit
                      4969     	; Timer2: clk/12 for 128us and 32ms interrupts
11FF    75C824        4970     	MOV	TMR2CN, #24H		; Timer2 enabled, low counter interrups enabled 
                      4971     	; Timer3: clk/12 for commutation timing
1202    759104        4972     	MOV	TMR3CN, #04H		; Timer3 enabled
                      4973     	; PCA
1205    75D840        4974     	MOV	PCA0CN, #40H		; PCA enabled
                      4975     	; Initializing beep
1208    1206D7        4976     	CALL WAIT200MS	
120B    1206E6        4977     	CALL BEEP_F1
120E    1206CF        4978     	CALL WAIT30MS
1211    1206EC        4979     	CALL BEEP_F2
1214    1206CF        4980     	CALL WAIT30MS
1217    1206F2        4981     	CALL BEEP_F3
121A    1206CF        4982     	CALL WAIT30MS
                      4983     
                      4984     	; Enable interrupts
121D    75A822        4985     	MOV	IE, #22H			; Enable timer0 and timer2 interrupts
1220    75B802        4986     	MOV	IP, #02H			; High priority to timer0 interrupts
1223    75E690        4987     	MOV	EIE1, #90H		; Enable timer3 and PCA0 interrupts
1226    75F610        4988     	MOV	EIP1, #10H		; High priority to PCA interrupts
                      4989     	; Initialize comparator
1229    759B80        4990     	MOV	CPT0CN, #80H		; Comparator enabled, no hysteresis
122C    759D03        4991     	MOV	CPT0MD, #03H		; Comparator response time 1us
                      4992     	; Initialize ADC
                      4993     	INITIALIZE_ADC			; Initialize ADC operation
122F    75D10E        4993+1   MOV REF0CN , # 0EH  ; SET VDD (3.3V) AS REFERENCE. ENABLE TEMP SENSOR AND BIAS
1232    75BCB8        4993+1   MOV ADC0CF , # 0B8H  ; ADC CLOCK 1MHZ
1235    75BB08        4993+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
1238    75BA11        4993+1   MOV AMX0N , # 11H  ; SELECT NEGATIVE INPUT AS GROUND
123B    75E880        4993+1   MOV ADC0CN , # 80H  ; ADC ENABLED
123E    1206C3        4994     	CALL	WAIT1MS
1241    D2AF          4995     	SETB	EA				; Enable all interrupts
                      4996     	; Measure number of lipo cells
1243    120991        4997     	CALL MEASURE_LIPO_CELLS			; Measure number of lipo cells
                      4998     	; Initialize rc pulse
                      4999     	RCP_INT_ENABLE		 			; Enable interrupt
1246    43DA01        4999+1   ORL PCA0CPM0 , # 01H  ; INTERRUPT ENABLED
                      5000     	RCP_CLEAR_INT_FLAG 				; Clear interrupt flag
1249    C2D8          5000+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
124B    C271          5001     CLR FLAGS2 . 1 
124D    1206D7        5002     	CALL WAIT200MS
                      5003     	; Set initial arm variable
1250    753001        5004     	MOV	INITIAL_ARM, #1
                      5005     
                      5006     	; Measure PWM frequency
                      5007     MEASURE_PWM_FREQ_INIT: 	
1253    D261          5008     SETB FLAGS0 . 1 
                      5009     MEASURE_PWM_FREQ_START: 	
1255    7A0A          5010     MOV R2 , # 10 
                      5011     MEASURE_PWM_FREQ_LOOP: 	
                      5012     	; Check if period diff was accepted
1257    E558          5013     	MOV	A, RCP_PERIOD_DIFF_ACCEPTED
1259    7002          5014     	JNZ	($+4)
                      5015     
125B    7A0A          5016     MOV R2 , # 10 
                      5017     
125D    1206C7        5018     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1260    E559          5019     	MOV	A, NEW_RCP					; Load value
1262    C3            5020     	CLR	C
1263    9402          5021     SUBB A , # 2 
1265    40EE          5022     	JC	MEASURE_PWM_FREQ_START			; No - start over
                      5023     
1267    E52F          5024     	MOV	A, FLAGS3						; Check pwm frequency flags
1269    540F          5025     	ANL	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
126B    855B5A        5026     	MOV	PREV_RCP_PWM_FREQ, CURR_RCP_PWM_FREQ		; Store as previous flags for next pulse 
126E    F55B          5027     	MOV	CURR_RCP_PWM_FREQ, A					; Store current flags for next pulse 
1270    B55AE2        5028     	CJNE	A, PREV_RCP_PWM_FREQ, MEASURE_PWM_FREQ_START	; Go back if new flags not same as previous
                      5029     
1273    DAE2          5030     DJNZ R2 , MEASURE_PWM_FREQ_LOOP 
                      5031     
                      5032     	; Clear measure pwm frequency flag
1275    C261          5033     CLR FLAGS0 . 1 
                      5034     	; Set up RC pulse interrupts after pwm frequency measurement
                      5035     	RCP_INT_FIRST 						; Enable interrupt and set to first edge
1277    53DACF        5035+1   ANL PCA0CPM0 , # 0CFH 
127A    207D03        5035+1   JB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY POSITIVE?
127D    43DA20        5035+1   ORL PCA0CPM0 , # 20H  ; CAPTURE RISING EDGE
1280    307D03        5035+1   JNB FLAGS3 . 5 , ( $+6 )  ; IS PWM POLARITY NEGATIVE?
1283    43DA10        5035+1   ORL PCA0CPM0 , # 10H  ; CAPTURE FALLING EDGE
                      5036     	RCP_CLEAR_INT_FLAG 					; Clear interrupt flag
1286    C2D8          5036+1   CLR CCF0  ; CLEAR INTERRUPT FLAG
1288    C271          5037     CLR FLAGS2 . 1 
128A    1206D3        5038     	CALL WAIT100MS						; Wait for new RC pulse
                      5039     
                      5040     	; Validate RC pulse
                      5041     VALIDATE_RCP_START: 	
128D    1206C7        5042     	CALL WAIT3MS						; Wait for next pulse (NB: Uses Temp1/2!) 
1290    7802          5043     MOV R0 , # 2 
1292    740F          5044     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
1294    552F          5045     	ANL	A, FLAGS3						; Check pwm frequency flags
1296    7002          5046     	JNZ	($+4)						; If a flag is set (PWM) - branch
                      5047     
1298    7800          5048     MOV R0 , # 0 
                      5049     
129A    C3            5050     	CLR	C
129B    E559          5051     	MOV	A, NEW_RCP					; Load value
129D    98            5052     SUBB A , R0 
129E    40ED          5053     	JC	VALIDATE_RCP_START				; No - start over
                      5054     
                      5055     	; Beep arm sequence start signal
12A0    C2AF          5056     	CLR 	EA							; Disable all interrupts
12A2    1206E6        5057     	CALL BEEP_F1						; Signal that RC pulse is ready
12A5    1206E6        5058     	CALL BEEP_F1
12A8    1206E6        5059     	CALL BEEP_F1
12AB    D2AF          5060     	SETB	EA							; Enable all interrupts
12AD    1206D7        5061     	CALL WAIT200MS	
                      5062     
                      5063     	; Arming sequence start
12B0    754800        5064     	MOV	GOV_ARM_TARGET, #0		; Clear governor arm target
                      5065     ARMING_START: 
12B3    1206C7        5066     	CALL WAIT3MS
12B6    788A          5067     MOV R0 , # PGM_ENABLE_TX_PROGRAM 
12B8    E6            5068     MOV A , @ R0 
12B9    C3            5069     	CLR	C
12BA    9401          5070     	SUBB	A, #1				; Is TX programming enabled?
12BC    5003          5071     	JNC 	ARMING_INITIAL_ARM_CHECK	; Yes - proceed
                      5072     
12BE    02137C        5073     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5074     
                      5075     ARMING_INITIAL_ARM_CHECK: 
12C1    E530          5076     	MOV	A, INITIAL_ARM			; Yes - check if it is initial arm sequence
12C3    C3            5077     	CLR	C
12C4    9401          5078     	SUBB	A, #1				; Is it the initial arm sequence?
12C6    5003          5079     	JNC 	ARMING_PPM_CHECK		; Yes - proceed
                      5080     
12C8    02137C        5081     	JMP 	PROGRAM_BY_TX_CHECKED	; No - branch
                      5082     
                      5083     ARMING_PPM_CHECK: 
12CB    740F          5084     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
12CD    552F          5085     	ANL	A, FLAGS3				; Check pwm frequency flags
12CF    6035          5086     	JZ	THROTTLE_HIGH_CAL_START	; If no flag is set (PPM) - branch
                      5087     
                      5088     	; PWM tx program entry
12D1    C3            5089     	CLR	C
12D2    E559          5090     	MOV	A, NEW_RCP			; Load new RC pulse value
12D4    94FF          5091     SUBB A , # 255 
12D6    5003          5092     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; Yes - proceed
                      5093     
12D8    02137C        5094     	JMP	PROGRAM_BY_TX_CHECKED	; No - branch
                      5095     
                      5096     PROGRAM_BY_TX_ENTRY_PWM: 	
12DB    C2AF          5097     	CLR	EA					; Disable all interrupts
12DD    1206F8        5098     	CALL BEEP_F4
12E0    D2AF          5099     	SETB	EA					; Enable all interrupts
12E2    1206D3        5100     	CALL WAIT100MS
12E5    C3            5101     	CLR	C
12E6    E559          5102     	MOV	A, NEW_RCP			; Load new RC pulse value
12E8    9401          5103     SUBB A , # 1 
12EA    50EF          5104     	JNC	PROGRAM_BY_TX_ENTRY_PWM	; No - start over
                      5105     
                      5106     PROGRAM_BY_TX_ENTRY_WAIT_PWM: 	
12EC    C2AF          5107     	CLR	EA					; Disable all interrupts
12EE    1206E6        5108     	CALL BEEP_F1
12F1    1206CB        5109     	CALL WAIT10MS
12F4    1206E6        5110     	CALL BEEP_F1
12F7    D2AF          5111     	SETB	EA					; Enable all interrupts
12F9    1206D3        5112     	CALL WAIT100MS
12FC    C3            5113     	CLR	C
12FD    E559          5114     	MOV	A, NEW_RCP			; Load new RC pulse value
12FF    94FF          5115     SUBB A , # 255 
1301    40E9          5116     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PWM	; No - start over
                      5117     
1303    021D09        5118     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      5119     
                      5120     	; PPM throttle calibration and tx program entry
                      5121     THROTTLE_HIGH_CAL_START: 
1306    7F1E          5122     MOV R7 , # 30 
                      5123     THROTTLE_HIGH_CAL: 			
1308    D27E          5124     SETB FLAGS3 . 6 
130A    317A          5125     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
130C    1206D3        5126     	CALL WAIT100MS				; Wait for new throttle value
130F    C2AF          5127     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1311    C27E          5128     CLR FLAGS3 . 6 
1313    317A          5129     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1315    C3            5130     	CLR	C
1316    E559          5131     	MOV	A, NEW_RCP			; Load new RC pulse value
1318    947F          5132     	SUBB	A, #(RCP_MAX/2)		; Is RC pulse above midstick?
131A    D2AF          5133     	SETB	EA					; Enable interrupts
131C    4068          5134     	JC	ARM_TARGET_UPDATED		; No - branch
                      5135     
131E    C2AF          5136     	CLR	EA					; Disable all interrupts
1320    1206F8        5137     	CALL BEEP_F4
1323    D2AF          5138     	SETB	EA					; Enable all interrupts
1325    DFE1          5139     DJNZ R7 , THROTTLE_HIGH_CAL 
                      5140     
1327    C3            5141     	CLR	C
1328    E559          5142     	MOV	A, NEW_RCP			; Limit to max 250
132A    9405          5143     	SUBB	A, #5				; Subtract about 2% and ensure that it is 250 or lower
132C    7899          5144     MOV R0 , # PGM_PPM_MAX_THROTTLE 
132E    F6            5145     MOV @ R0 , A 
132F    1206D7        5146     	CALL WAIT200MS				
1332    1218A2        5147     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
1335    121C8C        5148     	CALL	SUCCESS_BEEP
                      5149     
                      5150     THROTTLE_LOW_CAL_START: 
1338    7F1E          5151     MOV R7 , # 30 
                      5152     THROTTLE_LOW_CAL: 			
133A    D27E          5153     SETB FLAGS3 . 6 
133C    317A          5154     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
133E    1206D3        5155     	CALL WAIT100MS
1341    C2AF          5156     	CLR	EA					; Disable interrupts (freeze New_Rcp value)
1343    C27E          5157     CLR FLAGS3 . 6 
1345    317A          5158     	CALL	FIND_THROTTLE_GAIN		; Set throttle gain
1347    C3            5159     	CLR	C
1348    E559          5160     	MOV	A, NEW_RCP			; Load new RC pulse value
134A    947F          5161     	SUBB	A, #(RCP_MAX/2)		; Below midstick?
134C    D2AF          5162     	SETB	EA					; Enable interrupts
134E    50E8          5163     	JNC	THROTTLE_LOW_CAL_START	; No - start over
                      5164     
1350    C2AF          5165     	CLR	EA					; Disable all interrupts
1352    1206E6        5166     	CALL BEEP_F1
1355    1206CB        5167     	CALL WAIT10MS
1358    1206E6        5168     	CALL BEEP_F1
135B    D2AF          5169     	SETB	EA					; Enable all interrupts
135D    DFDB          5170     DJNZ R7 , THROTTLE_LOW_CAL 
                      5171     
135F    E559          5172     	MOV	A, NEW_RCP			
1361    2405          5173     	ADD	A, #5				; Add about 2%
1363    7898          5174     MOV R0 , # PGM_PPM_MIN_THROTTLE 
1365    F6            5175     MOV @ R0 , A 
1366    1206D7        5176     	CALL WAIT200MS				
1369    1218A2        5177     	CALL ERASE_AND_STORE_ALL_IN_EEPROM	
136C    121CBB        5178     	CALL	SUCCESS_BEEP_INVERTED
                      5179     
                      5180     PROGRAM_BY_TX_ENTRY_WAIT_PPM: 	
136F    1206D3        5181     	CALL WAIT100MS
1372    C3            5182     	CLR	C
1373    E559          5183     	MOV	A, NEW_RCP			; Load new RC pulse value
1375    94FF          5184     SUBB A , # 255 
1377    40F6          5185     	JC	PROGRAM_BY_TX_ENTRY_WAIT_PPM	; No - start over
                      5186     
1379    021D09        5187     	JMP	PROGRAM_BY_TX			; Yes - enter programming mode
                      5188     
                      5189     PROGRAM_BY_TX_CHECKED: 
137C    C3            5190     	CLR	C
137D    E559          5191     	MOV	A, NEW_RCP			; Load new RC pulse value
137F    9548          5192     	SUBB	A, GOV_ARM_TARGET		; Is RC pulse larger than arm target?
1381    4003          5193     	JC	ARM_TARGET_UPDATED		; No - do not update
                      5194     
1383    855948        5195     	MOV	GOV_ARM_TARGET, NEW_RCP	; Yes - update arm target
                      5196     
                      5197     ARM_TARGET_UPDATED: 
1386    1206D3        5198     	CALL WAIT100MS				; Wait for new throttle value
1389    C3            5199     	CLR	C
138A    E559          5200     	MOV	A, NEW_RCP			; Load new RC pulse value
138C    9401          5201     SUBB A , # 1 
138E    4002          5202     	JC	ARM_END_BEEP			; Yes - proceed
                      5203     
1390    41B3          5204     	JMP	ARMING_START			; No - start over
                      5205     
                      5206     ARM_END_BEEP: 
                      5207     	; Beep arm sequence end signal
1392    C2AF          5208     	CLR 	EA					; Disable all interrupts
1394    1206F8        5209     	CALL BEEP_F4				; Signal that rcpulse is ready
1397    1206F8        5210     	CALL BEEP_F4
139A    1206F8        5211     	CALL BEEP_F4
139D    D2AF          5212     	SETB	EA					; Enable all interrupts
139F    1206D7        5213     	CALL WAIT200MS
                      5214     
                      5215     	; Clear initial arm variable
13A2    753000        5216     	MOV	INITIAL_ARM, #0
                      5217     
                      5218     	; Armed and waiting for power on
                      5219     WAIT_FOR_POWER_ON: 
13A5    E4            5220     	CLR	A
13A6    F531          5221     	MOV	POWER_ON_WAIT_CNT_L, A	; Clear wait counter
13A8    F532          5222     	MOV	POWER_ON_WAIT_CNT_H, A	
                      5223     WAIT_FOR_POWER_ON_LOOP: 
13AA    0531          5224     	INC	POWER_ON_WAIT_CNT_L		; Increment low wait counter
13AC    E531          5225     	MOV	A, POWER_ON_WAIT_CNT_L
13AE    F4            5226     	CPL	A
13AF    7036          5227     	JNZ	WAIT_FOR_POWER_ON_NO_BEEP; Counter wrapping (about 1 sec)?
                      5228     
13B1    0532          5229     	INC	POWER_ON_WAIT_CNT_H		; Increment high wait counter
13B3    789C          5230     MOV R0 , # PGM_BEACON_DELAY 
13B5    E6            5231     MOV A , @ R0 
13B6    7828          5232     MOV R0 , # 40 
13B8    14            5233     	DEC	A
13B9    6012          5234     	JZ	BEEP_DELAY_SET
                      5235     
13BB    7850          5236     MOV R0 , # 80 
13BD    14            5237     	DEC	A
13BE    600D          5238     	JZ	BEEP_DELAY_SET
                      5239     
13C0    78A0          5240     MOV R0 , # 160 
13C2    14            5241     	DEC	A
13C3    6008          5242     	JZ	BEEP_DELAY_SET
                      5243     
13C5    78F0          5244     MOV R0 , # 240 
13C7    14            5245     	DEC	A
13C8    6003          5246     	JZ	BEEP_DELAY_SET
                      5247     
13CA    753200        5248     	MOV	POWER_ON_WAIT_CNT_H, #0		; Reset counter for infinite delay
                      5249     
                      5250     BEEP_DELAY_SET: 
13CD    C3            5251     	CLR	C
13CE    E532          5252     	MOV	A, POWER_ON_WAIT_CNT_H
13D0    98            5253     SUBB A , R0 
13D1    4014          5254     	JC	WAIT_FOR_POWER_ON_NO_BEEP; Has delay elapsed?
                      5255     
13D3    1532          5256     	DEC	POWER_ON_WAIT_CNT_H		; Decrement high wait counter
13D5    789B          5257     MOV R0 , # PGM_BEACON_STRENGTH 
13D7    866C          5258     MOV BEEP_STRENGTH , @ R0 
13D9    C2AF          5259     	CLR 	EA					; Disable all interrupts
13DB    1206F8        5260     	CALL BEEP_F4				; Signal that there is no signal
13DE    D2AF          5261     	SETB	EA					; Enable all interrupts
13E0    789A          5262     MOV R0 , # PGM_BEEP_STRENGTH 
13E2    866C          5263     MOV BEEP_STRENGTH , @ R0 
13E4    1206D3        5264     	CALL WAIT100MS				; Wait for new RC pulse to be measured
                      5265     
                      5266     WAIT_FOR_POWER_ON_NO_BEEP: 
13E7    1206C7        5267     	CALL WAIT3MS
13EA    C3            5268     	CLR	C
13EB    E559          5269     	MOV	A, NEW_RCP			; Load new RC pulse value
13ED    9406          5270     	SUBB	A, #(RCP_STOP+5) 		; Higher than stop (plus some hysteresis)?
13EF    40B9          5271     	JC	WAIT_FOR_POWER_ON_LOOP	; No - start over
                      5272     
13F1    E529          5273     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
13F3    7003          5274     	JNZ	($+5)				; If it is not zero - proceed
                      5275     
13F5    021253        5276     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5277     
13F8    1206D3        5278     	CALL	WAIT100MS				; Wait to see if start pulse was only a glitch
13FB    E529          5279     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
13FD    7003          5280     	JNZ	($+5)				; If it is not zero - proceed
                      5281     
13FF    021253        5282     	LJMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5283     
                      5284     
                      5285     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5286     ;
                      5287     ; Start entry point
                      5288     ;
                      5289     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5290     INIT_START: 
1402    120FE1        5291     	CALL SWITCH_POWER_OFF
1405    E4            5292     	CLR	A
1406    F522          5293     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1408    F523          5294     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
140A    F524          5295     	MOV	CURRENT_PWM, A			; Set current pwm to zero
140C    F525          5296     	MOV	CURRENT_PWM_COMP, A		; Set compensated current pwm to zero
140E    F526          5297     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
1410    F55F          5298     	MOV	PWM_SPOOLUP_BEG, A		; Set spoolup beginning pwm to zero
1412    755DFF        5299     	MOV	PWM_LIMIT, #0FFH		; Set pwm limit to max
1415    7888          5300     MOV R0 , # PGM_MOTOR_IDLE 
1417    8660          5301     MOV PWM_MOTOR_IDLE , @ R0 
1419    F540          5302     	MOV	GOV_TARGET_L, A		; Set target to zero
141B    F541          5303     	MOV	GOV_TARGET_H, A
141D    F542          5304     	MOV	GOV_INTEGRAL_L, A		; Set integral to zero
141F    F543          5305     	MOV	GOV_INTEGRAL_H, A
1421    F544          5306     	MOV	GOV_INTEGRAL_X, A
1423    756980        5307     	MOV	VOLTAGE_COMP_FACTOR, #80H; Set voltage compensation factor to "1"
1426    F56A          5308     	MOV	ADC_CONVERSION_CNT, A
1428    F549          5309     	MOV	GOV_ACTIVE, A
142A    F52C          5310     	MOV	FLAGS0, A				; Clear flags0
142C    F52D          5311     	MOV	FLAGS1, A				; Clear flags1
142E    F55C          5312     	MOV	RCP_STOP_CNT, A		; Set RC pulse stop count to zero
1430    120BD6        5313     	CALL INITIALIZE_ALL_TIMINGS	; Initialize timing
                      5314     	;**** **** **** **** ****
                      5315     	; Settle phase beginning
                      5316     	;**** **** **** **** **** 
1433    756A08        5317     MOV ADC_CONVERSION_CNT , # 8 
                      5318     	SET_ADC_IP_TEMP
1436    75BB10        5318+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
1439    1206C3        5319     	CALL WAIT1MS
143C    120A7C        5320     	CALL START_ADC_CONVERSION
143F    120A80        5321     	CALL CHECK_TEMP_VOLTAGE_COMPENSATE_AND_LIMIT_POWER
1442    756A08        5322     MOV ADC_CONVERSION_CNT , # 8 
                      5323     	SET_ADC_IP_TEMP
1445    75BB10        5323+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5324     
                      5325     	; Go to the desired startup mode
1448    788F          5326     MOV R0 , # PGM_STARTUP_METHOD 
144A    E6            5327     MOV A , @ R0 
144B    30E003        5328     	JNB	ACC.0, DIRECT_METHOD_START
                      5329     
144E    021488        5330     	JMP	STEPPER_METHOD_START
                      5331     
                      5332     DIRECT_METHOD_START: 
                      5333     	; Set up start operating conditions
1451    7894          5334     MOV R0 , # PGM_PWM_FREQ 
1453    E6            5335     MOV A , @ R0 
1454    FE            5336     MOV R6 , A 
1455    7601          5337     MOV @ R0 , # 1 
1457    11B8          5338     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1459    7894          5339     MOV R0 , # PGM_PWM_FREQ 
145B    EE            5340     MOV A , R6 
145C    F6            5341     MOV @ R0 , A 
                      5342     	; Set max allowed power
145D    D269          5343     SETB FLAGS1 . 1 
145F    120B88        5344     	CALL SET_STARTUP_PWM
1462    85225D        5345     	MOV	PWM_LIMIT, REQUESTED_PWM
1465    85225F        5346     	MOV	PWM_SPOOLUP_BEG, REQUESTED_PWM
1468    C269          5347     CLR FLAGS1 . 1 
                      5348     	; Begin startup sequence
146A    D268          5349     SETB FLAGS1 . 0 
146C    D26D          5350     SETB FLAGS1 . 5 
146E    D26C          5351     SETB FLAGS1 . 4 
1470    753800        5352     	MOV	DIRECT_STARTUP_OK_CNT, #0	; Reset ok counter
1473    753900        5353     	MOV	DIRECT_STARTUP_FAIL_CNT, #0	; Reset fail counter
1476    75370A        5354     	MOV	STARTUP_ROT_CNT, #10		; Set startup rotation count
1479    120F3D        5355     	CALL COMM5COMM6				; Initialize commutation
147C    120F81        5356     	CALL COMM6COMM1				
147F    120C62        5357     	CALL	CALC_NEXT_COMM_TIMING		; Set virtual commutation point
1482    1206C7        5358     	CALL	WAIT3MS
1485    021629        5359     	JMP	RUN1
                      5360     
                      5361     
                      5362     STEPPER_METHOD_START: 
                      5363     	; Set up start operating conditions
1488    7894          5364     MOV R0 , # PGM_PWM_FREQ 
148A    E6            5365     MOV A , @ R0 
148B    FE            5366     MOV R6 , A 
148C    7603          5367     MOV @ R0 , # 3 
148E    7893          5368     MOV R0 , # PGM_DAMPING_FORCE 
1490    E6            5369     MOV A , @ R0 
1491    FD            5370     MOV R5 , A 
1492    7605          5371     MOV @ R0 , # 5 
1494    11B8          5372     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1496    7894          5373     MOV R0 , # PGM_PWM_FREQ 
1498    EE            5374     MOV A , R6 
1499    F6            5375     MOV @ R0 , A 
149A    7893          5376     MOV R0 , # PGM_DAMPING_FORCE 
149C    ED            5377     MOV A , R5 
149D    F6            5378     MOV @ R0 , A 
                      5379     	; Begin startup sequence
149E    D268          5380     SETB FLAGS1 . 0 
14A0    D269          5381     SETB FLAGS1 . 1 
14A2    D276          5382     SETB FLAGS2 . 6 
14A4    120F3D        5383     	CALL COMM5COMM6			; Initialize commutation
14A7    120F81        5384     	CALL COMM6COMM1			
14AA    120B88        5385     	CALL SET_STARTUP_PWM
14AD    1206C3        5386     	CALL WAIT1MS
14B0    120E27        5387     	CALL COMM1COMM2
14B3    1206C3        5388     	CALL WAIT1MS
14B6    1206C3        5389     	CALL WAIT1MS
14B9    120E62        5390     	CALL COMM2COMM3
14BC    1206C7        5391     	CALL WAIT3MS			
14BF    120EB2        5392     	CALL COMM3COMM4
14C2    1206C7        5393     	CALL WAIT3MS			
14C5    1206C7        5394     	CALL WAIT3MS			
14C8    120EF6        5395     	CALL COMM4COMM5
14CB    1206CB        5396     	CALL WAIT10MS				; Settle rotor
14CE    120F3D        5397     	CALL COMM5COMM6
14D1    1206C7        5398     	CALL WAIT3MS				
14D4    1206C3        5399     	CALL WAIT1MS			
14D7    C269          5400     CLR FLAGS1 . 1 
14D9    D26A          5401     SETB FLAGS1 . 2 
                      5402     
                      5403     	;**** **** **** **** ****
                      5404     	; Stepper phase beginning
                      5405     	;**** **** **** **** **** 
                      5406     STEPPER_ROT_BEG: 
14DB    120A7C        5407     	CALL START_ADC_CONVERSION
14DE    120A80        5408     	CALL CHECK_TEMP_VOLTAGE_COMPENSATE_AND_LIMIT_POWER
14E1    120B88        5409     	CALL SET_STARTUP_PWM
14E4    756A08        5410     MOV ADC_CONVERSION_CNT , # 8 
                      5411     	SET_ADC_IP_TEMP
14E7    75BB10        5411+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5412     
14EA    120F81        5413     	CALL COMM6COMM1				; Commutate
14ED    120C5B        5414     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
14F0    120CD6        5415     	CALL CALC_NEW_WAIT_TIMES
14F3    120FF1        5416     	CALL DECREMENT_STEPPER_STEP
14F6    1154          5417     	CALL STEPPER_TIMER_WAIT
                      5418     
14F8    120E27        5419     	CALL COMM1COMM2			
14FB    120C5B        5420     	CALL CALC_NEXT_COMM_TIMING_START	
14FE    120CD6        5421     	CALL CALC_NEW_WAIT_TIMES
1501    120FF1        5422     	CALL DECREMENT_STEPPER_STEP
1504    1154          5423     	CALL STEPPER_TIMER_WAIT
                      5424     
1506    120E62        5425     	CALL COMM2COMM3			
1509    120C5B        5426     	CALL CALC_NEXT_COMM_TIMING_START	
150C    120CD6        5427     	CALL CALC_NEW_WAIT_TIMES
150F    120FF1        5428     	CALL DECREMENT_STEPPER_STEP
1512    1154          5429     	CALL STEPPER_TIMER_WAIT
                      5430     
1514    120EB2        5431     	CALL COMM3COMM4			
1517    120C5B        5432     	CALL CALC_NEXT_COMM_TIMING_START	
151A    120CD6        5433     	CALL CALC_NEW_WAIT_TIMES
151D    120FF1        5434     	CALL DECREMENT_STEPPER_STEP
1520    1154          5435     	CALL STEPPER_TIMER_WAIT
                      5436     
1522    120EF6        5437     	CALL COMM4COMM5			
1525    120C5B        5438     	CALL CALC_NEXT_COMM_TIMING_START	
1528    120CD6        5439     	CALL CALC_NEW_WAIT_TIMES
152B    120FF1        5440     	CALL DECREMENT_STEPPER_STEP
152E    1154          5441     	CALL STEPPER_TIMER_WAIT
                      5442     
1530    120F3D        5443     	CALL COMM5COMM6			
1533    120C5B        5444     	CALL CALC_NEXT_COMM_TIMING_START	
1536    120CD6        5445     	CALL CALC_NEW_WAIT_TIMES
1539    120FF1        5446     	CALL DECREMENT_STEPPER_STEP	
                      5447     	; Check stepper step versus end criteria
153C    C3            5448     	CLR	C
153D    E550          5449     	MOV	A, WT_STEPPER_STEP_L
153F    9535          5450     	SUBB	A, STEPPER_STEP_END_L		; Minimum Stepper_Step_End
1541    E551          5451     	MOV	A, WT_STEPPER_STEP_H
1543    9536          5452     	SUBB	A, STEPPER_STEP_END_H
1545    400C          5453     	JC	STEPPER_ROT_EXIT			; Branch if lower than minimum
                      5454     
                      5455     	; Wait for step
1547    1154          5456     	CALL STEPPER_TIMER_WAIT
1549    C3            5457     	CLR	C
154A    E559          5458     	MOV	A, NEW_RCP				; Load new pulse value
154C    9401          5459     SUBB A , # 1 
154E    508B          5460     	JNC	STEPPER_ROT_BEG
                      5461     
1550    02173E        5462     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5463     
                      5464     STEPPER_ROT_EXIT: 
                      5465     	; Set aquisition phase
1553    C26A          5466     CLR FLAGS1 . 2 
1555    D26B          5467     SETB FLAGS1 . 3 
                      5468     	; Set aquisition rotation count
1557    753702        5469     MOV STARTUP_ROT_CNT , # 2 
                      5470     	; Wait for step
155A    1154          5471     	CALL STEPPER_TIMER_WAIT			; As the last part of stepper phase
                      5472     	
                      5473     	;**** **** **** **** ****
                      5474     	; Aquisition phase beginning
                      5475     	;**** **** **** **** **** 
                      5476     AQUISITION_ROT_BEG: 
155C    120A7C        5477     	CALL START_ADC_CONVERSION
155F    120A80        5478     	CALL CHECK_TEMP_VOLTAGE_COMPENSATE_AND_LIMIT_POWER
1562    120B88        5479     	CALL SET_STARTUP_PWM
1565    756A08        5480     MOV ADC_CONVERSION_CNT , # 8 
                      5481     	SET_ADC_IP_TEMP
1568    75BB10        5481+1   MOV AMX0P , # 10H  ; SELECT TEMP SENSOR INPUT
                      5482     
156B    120F81        5483     	CALL COMM6COMM1				; Commutate
156E    120C5B        5484     	CALL CALC_NEXT_COMM_TIMING_START	; Update timing and set timer
1571    120CD6        5485     	CALL CALC_NEW_WAIT_TIMES
1574    120FF1        5486     	CALL DECREMENT_STEPPER_STEP
1577    1154          5487     	CALL STEPPER_TIMER_WAIT
                      5488     
1579    120E27        5489     	CALL COMM1COMM2
157C    120C5B        5490     	CALL CALC_NEXT_COMM_TIMING_START	
157F    120CD6        5491     	CALL CALC_NEW_WAIT_TIMES
1582    120FF1        5492     	CALL DECREMENT_STEPPER_STEP
1585    1154          5493     	CALL STEPPER_TIMER_WAIT
                      5494     
1587    120E62        5495     	CALL COMM2COMM3
158A    120C5B        5496     	CALL CALC_NEXT_COMM_TIMING_START	
158D    120CD6        5497     	CALL CALC_NEW_WAIT_TIMES
1590    120FF1        5498     	CALL DECREMENT_STEPPER_STEP
1593    1154          5499     	CALL STEPPER_TIMER_WAIT
                      5500     
1595    120EB2        5501     	CALL COMM3COMM4
1598    120C5B        5502     	CALL CALC_NEXT_COMM_TIMING_START	
159B    120CD6        5503     	CALL CALC_NEW_WAIT_TIMES
159E    120FF1        5504     	CALL DECREMENT_STEPPER_STEP
15A1    1154          5505     	CALL STEPPER_TIMER_WAIT
                      5506     
15A3    120EF6        5507     	CALL COMM4COMM5
15A6    120C5B        5508     	CALL CALC_NEXT_COMM_TIMING_START	
15A9    120CD6        5509     	CALL CALC_NEW_WAIT_TIMES
15AC    120FF1        5510     	CALL DECREMENT_STEPPER_STEP
15AF    1154          5511     	CALL STEPPER_TIMER_WAIT
                      5512     
15B1    120F3D        5513     	CALL COMM5COMM6
15B4    120C5B        5514     	CALL CALC_NEXT_COMM_TIMING_START	
15B7    120CD6        5515     	CALL CALC_NEW_WAIT_TIMES
15BA    120FF1        5516     	CALL DECREMENT_STEPPER_STEP
                      5517     	; Decrement startup rotation count
15BD    E537          5518     	MOV	A, STARTUP_ROT_CNT
15BF    14            5519     	DEC	A
                      5520     	; Check number of aquisition rotations
15C0    600E          5521     	JZ AQUISITION_ROT_EXIT		; Branch if counter is zero
                      5522     	
                      5523     	; Store counter
15C2    F537          5524     	MOV	STARTUP_ROT_CNT, A
                      5525     	; Wait for step
15C4    1154          5526     	CALL STEPPER_TIMER_WAIT
15C6    C3            5527     	CLR	C
15C7    E559          5528     	MOV	A, NEW_RCP				; Load new pulse value
15C9    9401          5529     SUBB A , # 1 
15CB    508F          5530     	JNC	AQUISITION_ROT_BEG
                      5531     
15CD    02173E        5532     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5533     
                      5534     AQUISITION_ROT_EXIT: 
15D0    D26C          5535     SETB FLAGS1 . 4 
                      5536     	; Set spoolup power variables (power is now controlled from RCP)
                      5537     IF MODE == 0
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
                               	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
                               ENDIF
                      5541     IF MODE == 1
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH			; Allow full power
                               ENDIF
                      5544     IF MODE == 2
15D2    855F5E        5545     	MOV	PWM_LIMIT_SPOOLUP, PWM_SPOOLUP_BEG	; Set initial slow spoolup power
15D5    855F5D        5546     	MOV	PWM_LIMIT, PWM_SPOOLUP_BEG
                      5547     ENDIF
15D8    1154          5548     	CALL STEPPER_TIMER_WAIT		; As the last part of aquisition phase
                      5549     
15DA    120F81        5550     	CALL COMM6COMM1
15DD    120C62        5551     	CALL CALC_NEXT_COMM_TIMING	
15E0    120CBD        5552     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
15E3    120CD6        5553     	CALL CALC_NEW_WAIT_TIMES
15E6    120D60        5554     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5555     
                      5556     	; Set nondamped run rotation count
15E9    75370A        5557     MOV STARTUP_ROT_CNT , # 10 
                      5558     	; Transition from damped to nondamped
15EC    7894          5559     MOV R0 , # PGM_PWM_FREQ 
15EE    E6            5560     MOV A , @ R0 
15EF    FE            5561     MOV R6 , A 
15F0    7601          5562     MOV @ R0 , # 1 
15F2    11B8          5563     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
15F4    7894          5564     MOV R0 , # PGM_PWM_FREQ 
15F6    EE            5565     MOV A , R6 
15F7    F6            5566     MOV @ R0 , A 
15F8    C2AF          5567     	CLR	EA					; Disable all interrupts
                      5568     	ALL_PFETS_OFF 				; Turn off all pfets
15FA    C296          5568+1   CLR P1 . 6 
15FC    C294          5568+1   CLR P1 . 4 
15FE    C292          5568+1   CLR P1 . 2 
                      5569     	BPFET_ON					; Bp on
1600    D294          5569+1   SETB P1 . 4 
1602    742D          5570     	MOV	A, #45				; 8us delay for pfets to go off
1604    D5E0FD        5571     	DJNZ	ACC, $
1607    9001A0        5572     	MOV	DPTR, #PWM_CFET_ON		; Set DPTR register to desired pwm_nfet_on label		
160A    D2AF          5573     	SETB	EA					; Enable interrupts
160C    120A7C        5574     	CALL START_ADC_CONVERSION
160F    120A80        5575     	CALL CHECK_TEMP_VOLTAGE_COMPENSATE_AND_LIMIT_POWER
1612    120B88        5576     	CALL SET_STARTUP_PWM
1615    756A00        5577     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5578     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
1618    75BB08        5578+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
161B    021629        5579     	JMP	RUN1
                      5580     
                      5581     
                      5582     
                      5583     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5584     ;
                      5585     ; Run entry point
                      5586     ;
                      5587     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5588     DAMPED_TRANSITION: 
                      5589     	; Transition from nondamped to damped if applicable
161E    11B8          5590     	CALL	DECODE_PARAMETERS		; Set programmed parameters
1620    120F81        5591     	CALL	COMM6COMM1
1623    756A00        5592     	MOV	ADC_CONVERSION_CNT, #0	; Make sure a voltage reading is done next time
                      5593     	SET_ADC_IP_VOLT			; Set adc measurement to voltage
1626    75BB08        5593+1   MOV AMX0P , # ( 8+ADC_IP )  ; SELECT POSITIVE INPUT
                      5594     
                      5595     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                      5596     ; Out_cA changes from high to low
                      5597     RUN1: 
1629    120D82        5598     	CALL WAIT_FOR_COMP_OUT_HIGH	; Wait zero cross wait and wait for high
162C    120DEA        5599     	CALL	EVALUATE_COMPARATOR_INTEGRITY	; Check whether comparator reading has been normal
162F    120E0D        5600     	CALL SETUP_COMM_WAIT		; Setup wait time from zero cross to commutation
1632    1207A3        5601     	CALL CALC_GOVERNOR_TARGET	; Calculate governor target
1635    120E21        5602     	CALL WAIT_FOR_COMM			; Wait from zero cross to commutation
1638    120E27        5603     	CALL COMM1COMM2			; Commutate
163B    120C62        5604     	CALL CALC_NEXT_COMM_TIMING	; Calculate next timing and start advance timing wait
163E    120CBD        5605     	CALL WAIT_ADVANCE_TIMING		; Wait advance timing and start zero cross wait
1641    120CD6        5606     	CALL CALC_NEW_WAIT_TIMES
1644    120D60        5607     	CALL WAIT_BEFORE_ZC_SCAN		; Wait zero cross wait and start zero cross timeout
                      5608     
                      5609     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                      5610     ; Out_cB changes from low to high
                      5611     RUN2: 
1647    120D79        5612     	CALL WAIT_FOR_COMP_OUT_LOW
164A    120DEA        5613     	CALL	EVALUATE_COMPARATOR_INTEGRITY
164D    120E0D        5614     	CALL SETUP_COMM_WAIT	
1650    120823        5615     	CALL CALC_GOVERNOR_PROP_ERROR
1653    120E21        5616     	CALL WAIT_FOR_COMM
1656    120E62        5617     	CALL COMM2COMM3
1659    120C62        5618     	CALL CALC_NEXT_COMM_TIMING
165C    120CBD        5619     	CALL WAIT_ADVANCE_TIMING
165F    120CD6        5620     	CALL CALC_NEW_WAIT_TIMES
1662    120D60        5621     	CALL WAIT_BEFORE_ZC_SCAN	
                      5622     
                      5623     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                      5624     ; Out_cC changes from high to low
                      5625     RUN3: 
1665    120D82        5626     	CALL WAIT_FOR_COMP_OUT_HIGH
1668    120DEA        5627     	CALL	EVALUATE_COMPARATOR_INTEGRITY
166B    120E0D        5628     	CALL SETUP_COMM_WAIT	
166E    120864        5629     	CALL CALC_GOVERNOR_INT_ERROR
1671    120E21        5630     	CALL WAIT_FOR_COMM
1674    120EB2        5631     	CALL COMM3COMM4
1677    120C62        5632     	CALL CALC_NEXT_COMM_TIMING
167A    120CBD        5633     	CALL WAIT_ADVANCE_TIMING
167D    120CD6        5634     	CALL CALC_NEW_WAIT_TIMES
1680    120D60        5635     	CALL WAIT_BEFORE_ZC_SCAN	
                      5636     
                      5637     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                      5638     ; Out_cA changes from low to high
                      5639     RUN4: 
1683    120D79        5640     	CALL WAIT_FOR_COMP_OUT_LOW
1686    120DEA        5641     	CALL	EVALUATE_COMPARATOR_INTEGRITY
1689    120E0D        5642     	CALL SETUP_COMM_WAIT	
168C    1208BE        5643     	CALL CALC_GOVERNOR_PROP_CORRECTION
168F    120E21        5644     	CALL WAIT_FOR_COMM
1692    120EF6        5645     	CALL COMM4COMM5
1695    120C62        5646     	CALL CALC_NEXT_COMM_TIMING
1698    120CBD        5647     	CALL WAIT_ADVANCE_TIMING
169B    120CD6        5648     	CALL CALC_NEW_WAIT_TIMES
169E    120D60        5649     	CALL WAIT_BEFORE_ZC_SCAN	
                      5650     
                      5651     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                      5652     ; Out_cB changes from high to low
                      5653     RUN5: 
16A1    120D82        5654     	CALL WAIT_FOR_COMP_OUT_HIGH
16A4    120DEA        5655     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16A7    120E0D        5656     	CALL SETUP_COMM_WAIT	
16AA    12092B        5657     	CALL CALC_GOVERNOR_INT_CORRECTION
16AD    120E21        5658     	CALL WAIT_FOR_COMM
16B0    120F3D        5659     	CALL COMM5COMM6
16B3    120C62        5660     	CALL CALC_NEXT_COMM_TIMING
16B6    120CBD        5661     	CALL WAIT_ADVANCE_TIMING
16B9    120CD6        5662     	CALL CALC_NEW_WAIT_TIMES
16BC    120D60        5663     	CALL WAIT_BEFORE_ZC_SCAN	
                      5664     
                      5665     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                      5666     ; Out_cC changes from low to high
                      5667     RUN6: 
16BF    120D79        5668     	CALL WAIT_FOR_COMP_OUT_LOW
16C2    120A7C        5669     	CALL START_ADC_CONVERSION
16C5    120DEA        5670     	CALL	EVALUATE_COMPARATOR_INTEGRITY
16C8    120E0D        5671     	CALL SETUP_COMM_WAIT	
16CB    120A80        5672     	CALL CHECK_TEMP_VOLTAGE_COMPENSATE_AND_LIMIT_POWER
16CE    120E21        5673     	CALL WAIT_FOR_COMM
16D1    120F81        5674     	CALL COMM6COMM1
16D4    120C62        5675     	CALL CALC_NEXT_COMM_TIMING
16D7    120CBD        5676     	CALL WAIT_ADVANCE_TIMING
16DA    120CD6        5677     	CALL CALC_NEW_WAIT_TIMES
16DD    120D60        5678     	CALL WAIT_BEFORE_ZC_SCAN	
                      5679     
                      5680     	; Check if it is direct startup
16E0    306D23        5681     JNB FLAGS1 . 5 , NORMAL_RUN_CHECKS 
                      5682     
16E3    C3            5683     	CLR	C
16E4    E539          5684     	MOV	A, DIRECT_STARTUP_FAIL_CNT	; Load fail counter
16E6    9414          5685     	SUBB	A, #20					; Is counter below requirement?
16E8    5054          5686     	JNC	RUN_TO_WAIT_FOR_POWER_ON		
                      5687     
16EA    C3            5688     	CLR	C
16EB    E538          5689     	MOV	A, DIRECT_STARTUP_OK_CNT		; Load ok counter
16ED    9428          5690     	SUBB	A, #40					; Is counter above requirement?
16EF    4008          5691     	JC	DIRECT_START_CHECK_RCP		; No - proceed
                      5692     
16F1    C26D          5693     CLR FLAGS1 . 5 
                      5694     	; Set spoolup power variables
                      5695     IF MODE == 0
                               	MOV	PWM_LIMIT_SPOOLUP, PWM_LIMIT	; Set initial slow spoolup power
                               ENDIF
                      5698     IF MODE == 1
                               	MOV	PWM_LIMIT_SPOOLUP, #0FFH		; Allow full power
                               ENDIF
                      5701     IF MODE == 2
16F3    855D5E        5702     	MOV	PWM_LIMIT_SPOOLUP, PWM_LIMIT	; Set initial slow spoolup power
                      5703     ENDIF
16F6    021706        5704     	JMP	NORMAL_RUN_CHECKS
                      5705     
                      5706     DIRECT_START_CHECK_RCP: 
16F9    C3            5707     	CLR	C
16FA    E559          5708     	MOV	A, NEW_RCP				; Load new pulse value
16FC    9401          5709     SUBB A , # 1 
16FE    4003          5710     	JC	($+5)
                      5711     
1700    021629        5712     	LJMP	RUN1						; Continue to run 
                      5713     
1703    02173E        5714     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5715     
                      5716     
                      5717     NORMAL_RUN_CHECKS: 
                      5718     	; Check if it is initial run phase
1706    306C1B        5719     JNB FLAGS1 . 4 , INITIAL_RUN_PHASE_DONE 
                      5720     
                      5721     	; Decrement startup rotaton count
1709    E537          5722     	MOV	A, STARTUP_ROT_CNT
170B    14            5723     	DEC	A
                      5724     	; Check number of nondamped rotations
170C    7007          5725     	JNZ 	NORMAL_RUN_CHECK_STARTUP_ROT	; Branch if counter is not zero
                      5726     
170E    C26C          5727     CLR FLAGS1 . 4 
1710    C26B          5728     CLR FLAGS1 . 3 
1712    02161E        5729     	LJMP DAMPED_TRANSITION			; Do damped transition if counter is zero
                      5730     
                      5731     NORMAL_RUN_CHECK_STARTUP_ROT: 
1715    F537          5732     	MOV	STARTUP_ROT_CNT, A			; Not zero - store counter
                      5733     
1717    C3            5734     	CLR	C
1718    E559          5735     	MOV	A, NEW_RCP				; Load new pulse value
171A    9401          5736     SUBB A , # 1 
171C    4003          5737     	JC	($+5)
                      5738     
171E    021629        5739     	LJMP	RUN1						; Continue to run 
                      5740     
1721    02173E        5741     	JMP	RUN_TO_WAIT_FOR_POWER_ON
                      5742     
                      5743     
                      5744     INITIAL_RUN_PHASE_DONE: 
                      5745     	; Exit run loop after a given time
1724    C3            5746     	CLR	C
1725    E55C          5747     	MOV	A, RCP_STOP_CNT			; Load stop RC pulse counter value
1727    94FA          5748     SUBB A , # 250 
1729    5013          5749     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes, go back to wait for poweron
                      5750     
172B    740F          5751     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
172D    552F          5752     	ANL	A, FLAGS3					; Check pwm frequency flags
172F    7004          5753     	JNZ	RUN6_CHECK_SPEED			; If a flag is set (PWM) - branch
                      5754     
1731    E529          5755     	MOV	A, RCP_TIMEOUT_CNT			; Load RC pulse timeout counter value
1733    6009          5756     	JZ	RUN_TO_WAIT_FOR_POWER_ON		; If it is zero - go back to wait for poweron
                      5757     
                      5758     RUN6_CHECK_SPEED: 
1735    C3            5759     	CLR	C
1736    E53D          5760     	MOV	A, COMM_PERIOD4X_H			; Is Comm_Period4x more than 32ms (~1220 eRPM)?
1738    94F0          5761     	SUBB	A, #0F0H
173A    5002          5762     	JNC	RUN_TO_WAIT_FOR_POWER_ON		; Yes - go back to motor start
173C    C129          5763     	JMP	RUN1						; Go back to run 1
                      5764     
                      5765     
                      5766     RUN_TO_WAIT_FOR_POWER_ON: 	
173E    120FE1        5767     	CALL SWITCH_POWER_OFF
1741    7894          5768     MOV R0 , # PGM_PWM_FREQ 
1743    E6            5769     MOV A , @ R0 
1744    FE            5770     MOV R6 , A 
1745    7602          5771     MOV @ R0 , # 2 
1747    11B8          5772     	CALL	DECODE_PARAMETERS		; (Decode_parameters uses Temp1 and Temp8)
1749    7894          5773     MOV R0 , # PGM_PWM_FREQ 
174B    EE            5774     MOV A , R6 
174C    F6            5775     MOV @ R0 , A 
174D    E4            5776     	CLR	A
174E    F522          5777     	MOV	REQUESTED_PWM, A		; Set requested pwm to zero
1750    F523          5778     	MOV	GOVERNOR_REQ_PWM, A		; Set governor requested pwm to zero
1752    F524          5779     	MOV	CURRENT_PWM, A			; Set current pwm to zero
1754    F525          5780     	MOV	CURRENT_PWM_COMP, A		; Set compensated current pwm to zero
1756    F526          5781     	MOV	CURRENT_PWM_LIMITED, A	; Set limited current pwm to zero
1758    F55F          5782     	MOV	PWM_SPOOLUP_BEG, A		; Set spoolup beginning pwm to zero
175A    F560          5783     	MOV	PWM_MOTOR_IDLE, A		; Set motor idle to zero
175C    C268          5784     CLR FLAGS1 . 0 
175E    1206C3        5785     	CALL	WAIT1MS				; Wait for pwm to be stopped
1761    120FE1        5786     	CALL SWITCH_POWER_OFF
                      5787     IF MODE == 0	; Main
                               	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
                               	ANL	A, FLAGS3				; Check pwm frequency flags
                               	JNZ	RUN_TO_NEXT_STATE_MAIN	; If a flag is set (PWM) - branch
                               
                               	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
                               	JNZ	RUN_TO_NEXT_STATE_MAIN	; If it is not zero - branch
                               
                               	JMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                               
                               RUN_TO_NEXT_STATE_MAIN:
                               	CALL	WAIT1S				; 3 second delay before new startup
                               	CALL	WAIT1S
                               	CALL	WAIT1S
                               	MOV	TEMP1, #PGM_MAIN_REARM_START
                               	MOV	A, @TEMP1	
                               	CLR	C
                               	SUBB	A, #1				; Is re-armed start enabled?
                               	JC 	JMP_WAIT_FOR_POWER_ON	; No - do like tail and start immediately
                               
                               	JMP	VALIDATE_RCP_START		; Yes - go back to validate RC pulse
                               
                               JMP_WAIT_FOR_POWER_ON:
                               	JMP	WAIT_FOR_POWER_ON		; Go back to wait for power on
                               ENDIF
                      5812     IF MODE >= 1	; Tail or multi
1764    740F          5813     	MOV	A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ))
1766    552F          5814     	ANL	A, FLAGS3				; Check pwm frequency flags
1768    7006          5815     	JNZ	JMP_WAIT_FOR_POWER_ON	; If a flag is set (PWM) - branch
                      5816     
176A    E529          5817     	MOV	A, RCP_TIMEOUT_CNT		; Load RC pulse timeout counter value
176C    7002          5818     	JNZ	JMP_WAIT_FOR_POWER_ON	; If it is not zero - go back to wait for poweron
                      5819     
176E    4153          5820     	JMP	MEASURE_PWM_FREQ_INIT	; If it is zero (pulses missing) - go back to measure pwm frequency
                      5821     
                      5822     JMP_WAIT_FOR_POWER_ON: 
1770    61A5          5823     	JMP	WAIT_FOR_POWER_ON		; Go back to wait for power on
                      5824     ENDIF
                      5825     
                      5826     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      5827     
                      5828     $INCLUDE (BLHELITXPGM.INC)		; Include source code for programming the ESC with the TX
                      7121     
                      7122     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                      7123     
                      7124     
                      7125     END
MACRO ASSEMBLER BLHELI                                      09/20/12 17:22:46 PAGE     0


SYMBOL TABLE LISTING
------ ----- -------


N A M E             T Y P E  V A L U E   ATTRIBUTES

PARAVAL_END_D. . .  C ADDR   1D83H   A 
NORMAL_RUN_CHECK_~  C ADDR   1715H   A 
COMP_WAIT_ON_COMP~  C ADDR   0DB8H   A 
CALC_NEXT_COMM_SL~  C ADDR   0CB6H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0959H   A 
GOVERNOR_CORR_NEG~  C ADDR   091AH   A 
_EEP_MAIN_REARM_S~  C ADDR   1A10H   A 
EEP_PGM_LOW_VOLTA~  C ADDR   1A06H   A 
PPM_THROTTLE_GAIN.  D ADDR   006BH   A 
LIPO_ADC_LIMIT_H .  D ADDR   0068H   A 
CURR_RCP_PWM_FREQ.  D ADDR   005BH   A 
RCP_EDGE_H . . . .  D ADDR   0055H   A 
FLAGS3 . . . . . .  D ADDR   002FH   A 
RCP_PREV_EDGE_L. .  D ADDR   0027H   A 
ADC_IP . . . . . .  N NUMB   0000h            
AD0INT . . . . . .  B ADDR   00E8H.5 A 
ADC0LTH. . . . . .  D ADDR   00C6H   A 
ADC0H. . . . . . .  D ADDR   00BEH   A 
SBUF0. . . . . . .  D ADDR   0099H   A 
DPL. . . . . . . .  D ADDR   0082H   A 
P0 . . . . . . . .  D ADDR   0080H   A 
FUNCTION_BEEP. . .  C ADDR   1CF0H   A 
INIT_START . . . .  C ADDR   1402H   A 
PROGRAM_BY_TX_ENT~  C ADDR   12DBH   A 
FIND_THROTTLE_GAI~  C ADDR   1189H   A 
COMM45_NFET. . . .  C ADDR   0F21H   A 
COMM45_NONDAMP . .  C ADDR   0F1EH   A 
COMM4COMM5 . . . .  C ADDR   0EF6H   A 
EVAL_COMP_STARTUP~  C ADDR   0DF7H   A 
STARTUP_PWM_CHECK~  C ADDR   0BC0H   A 
CHECK_VOLTAGE_SPO~  C ADDR   0B69H   A 
MEASURE_LIPO_625 .  C ADDR   0A56H   A 
T2H_INT_RCP_STOP .  C ADDR   04C6H   A 
T0_INT_PWM_ON_LOW~  C ADDR   00A8H   A 
EEP_PGM_PPM_MIN_T~  C ADDR   1A19H   A 
PWM_MOTOR_IDLE . .  D ADDR   0060H   A 
PREV_RCP_PWM_FREQ.  D ADDR   005AH   A 
WT_COMM_L. . . . .  D ADDR   004EH   A 
COMM_PERIOD4X_H. .  D ADDR   003DH   A 
SETTLE_PHASE . . .  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   00C8h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
ESPI0. . . . . . .  B ADDR   00A8H.6 A 
RSTSRC . . . . . .  D ADDR   00EFH   A 
ADC0CF . . . . . .  D ADDR   00BCH   A 
P1 . . . . . . . .  D ADDR   0090H   A 
PARAVAL_BEEP . . .  C ADDR   1CFEH   A 
STORE_MULTI_FUNC_~  C ADDR   1C5EH   A 
GOVERNOR_CHECK_PWM  C ADDR   089BH   A 
GOVERNOR_ACTIVATE.  C ADDR   07DFH   A 
MULT_S16_BY_U16_P~  C ADDR   0763H   A 
T0_INT_PWM_OFF_CO~  C ADDR   0141H   A 
EEP_ENABLE_TX_PRO~  C ADDR   1A0FH   A 
DAMPING_PERIOD . .  D ADDR   0063H   A 
RCP_PWM_FREQ_1KHZ.  N NUMB   0000h            
TF2CEN . . . . . .  B ADDR   00C8H.4 A 
B. . . . . . . . .  D ADDR   00F0H   A 
OSCLCN . . . . . .  D ADDR   00E3H   A 
P2 . . . . . . . .  D ADDR   00A0H   A 
TURNIGY_AE_25A_MA~  N NUMB   002Eh            
TURNIGY_AE_20A_TA~  N NUMB   002Ch            
TURNIGY_PLUSH_10A~  N NUMB   001Ch            
STORE_MULTI_FUNC_~  C ADDR   1C68H   A 
WRITE_EEPROM_SIGN~  C ADDR   17A2H   A 
WAIT_FOR_POWER_ON.  C ADDR   13A5H   A 
THROTTLE_LOW_CAL_~  C ADDR   1338H   A 
ERASE_AND_STORE_A~  C ADDR   18A2H   A 
PROGRAM_BY_TX_CHE~  C ADDR   137CH   A 
ARMING_INITIAL_AR~  C ADDR   12C1H   A 
SET_DEFAULT_PARAM~  C ADDR   105BH   A 
COMM56_NONDAMP . .  C ADDR   0F6DH   A 
COMM23_CP. . . . .  C ADDR   0EA0H   A 
CALC_NEXT_COMM_TI~  C ADDR   0C62H   A 
COMM5COMM6 . . . .  C ADDR   0F3DH   A 
CALC_GOVERNOR_INT~  C ADDR   0932H   A 
CALC_GOVERNOR_TAR~  C ADDR   0822H   A 
PCA_INT_STORE_DATA  C ADDR   05E5H   A 
T2_INT_RCP_GAIN_P~  C ADDR   0443H   A 
T2_INT_RCP_UPDATE~  C ADDR   0404H   A 
RESET. . . . . . .  C ADDR   11A6H   A 
EEP_PGM_PPM_MAX_T~  C ADDR   1A1AH   A 
PGM_GOV_P_GAIN_DE~  I ADDR   0082H   A 
PWM_LIMIT_SPOOLUP.  D ADDR   005EH   A 
RCP_PREPREV_EDGE_H  D ADDR   0053H   A 
WT_ADVANCE_H . . .  D ADDR   004BH   A 
RCP_PWM_FREQ_2KHZ.  N NUMB   0001h            
PGM_PWM_HIGH_FREQ.  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
SMB0CN . . . . . .  D ADDR   00C0H   A 
SCON0. . . . . . .  D ADDR   0098H   A 
SP . . . . . . . .  D ADDR   0081H   A 
SKYWALKER_20A_MAIN  N NUMB   0034h            
TURNIGY_AE_30A_TA~  N NUMB   0032h            
TURNIGY_AE_20A_MU~  N NUMB   002Dh            
XP_7A_MAIN . . . .  N NUMB   0004h            
FUNCTION_NEXT. . .  C ADDR   1D8CH   A 
STORE_MULTI_FUNC_~  C ADDR   1C72H   A 
STEPPER_ROT_BEG. .  C ADDR   14DBH   A 
THROTTLE_HIGH_CAL.  C ADDR   1308H   A 
DECODE_THROTTLE_R~  C ADDR   116BH   A 
STORE_TIMES_DEC_S~  C ADDR   0D57H   A 
STEPPER_STEP_MED_~  C ADDR   0C22H   A 
INITIALIZE_ALL_TI~  C ADDR   0BD6H   A 
STARTUP_PWM_SET_P~  C ADDR   0BC8H   A 
PGM_PWM_FREQ . . .  I ADDR   0094H   A 
PGM_THROTTLE_RATE.  I ADDR   0091H   A 
PGM_STARTUP_RPM. .  I ADDR   008DH   A 
LIPO_ADC_LIMIT_L .  D ADDR   0067H   A 
RCP_EDGE_L . . . .  D ADDR   0054H   A 
CURRENT_PWM_COMP .  D ADDR   0025H   A 
PWM_SETTLE . . . .  N NUMB   0032h            
GOV_SPOOLRATE. . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MULTI~  N NUMB   0002h            
AC . . . . . . . .  B ADDR   00D0H.6 A 
EIE1 . . . . . . .  D ADDR   00E6H   A 
ADC0LTL. . . . . .  D ADDR   00C5H   A 
ADC0L. . . . . . .  D ADDR   00BDH   A 
AMX0N. . . . . . .  D ADDR   00BAH   A 
TURNIGY_AE_30A_MU~  N NUMB   0033h            
TURNIGY_PLUSH_30A~  N NUMB   0028h            
TURNIGY_PLUSH_12A~  N NUMB   001Fh            
XP_3A_TAIL . . . .  N NUMB   0002h            
PARAVAL_NEXT . . .  C ADDR   1D55H   A 
STORE_MULTI_FUNC_~  C ADDR   1C7CH   A 
WRITE_EEPROM_BYTE.  C ADDR   1776H   A 
MEASURE_PWM_FREQ_~  C ADDR   1253H   A 
COMM61_CP. . . . .  C ADDR   0FCFH   A 
CALC_GOVERNOR_INT~  C ADDR   092BH   A 
PCA_INT_LIMITED. .  C ADDR   0681H   A 
PCA_INT_PWM_DIVIDE  C ADDR   066FH   A 
T2_INT_PWM_UPDATE.  C ADDR   0453H   A 
T0_INT_PWM_OFF_DA~  C ADDR   00DDH   A 
EEP_DUMMY. . . . .  C ADDR   1A1FH   A 
EEP_LAYOUT_REVISI~  C ADDR   1A02H   A 
PGM_GOV_SETUP_TAR~  I ADDR   008CH   A 
COMM_PERIOD4X_L. .  D ADDR   003CH   A 
PGM_RCP_PWM_POL. .  N NUMB   0005h            
RCP_PWM_FREQ_4KHZ.  N NUMB   0002h            
REQUESTED_PWM. . .  D ADDR   0022H   A 
OV . . . . . . . .  B ADDR   00D0H.2 A 
MCE0 . . . . . . .  B ADDR   0098H.5 A 
MODE . . . . . . .  N NUMB   0002h            
SKYWALKER_40A_MAIN  N NUMB   0037h            
SUPERMICRO_3P5A_M~  N NUMB   0016h            
XP_3A_MULTI. . . .  N NUMB   0003h            
FUNC_PARAVAL_WAIT.  C ADDR   1D1CH   A 
WRITE_TAG. . . . .  C ADDR   1899H   A 
READ_EEPROM_STORE~  C ADDR   1877H   A 
RUN1 . . . . . . .  C ADDR   1629H   A 
CLEAR_RAM. . . . .  C ADDR   11E2H   A 
DECODE_GOVERNOR_G~  C ADDR   1151H   A 
DEC_STEP_HIGH. . .  C ADDR   101FH   A 
WAIT_FOR_COMM. . .  C ADDR   0E21H   A 
CALC_NEW_WAIT_DIR~  C ADDR   0CE3H   A 
CALC_GOVERNOR_PRO~  C ADDR   0863H   A 
WAIT100MS. . . . .  C ADDR   06D3H   A 
WAIT1MS. . . . . .  C ADDR   06C3H   A 
EEP_PGM_BEEP_STRE~  C ADDR   1A1BH   A 
EEP_PGM_STARTUP_A~  C ADDR   1A13H   A 
TX_PGM_BEEP_NO . .  D ADDR   006FH   A 
RCP_SKIP_RATE. . .  N NUMB   0006h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
MODF . . . . . . .  B ADDR   00F8H.5 A 
EA . . . . . . . .  B ADDR   00A8H.7 A 
AMX0P. . . . . . .  D ADDR   00BBH   A 
IDA0H. . . . . . .  D ADDR   0097H   A 
PSCTL. . . . . . .  D ADDR   008FH   A 
FUNCTION_PARAVAL_~  C ADDR   1CEAH   A 
STORE_NEW_VALUE_I~  C ADDR   1C00H   A 
RUN2 . . . . . . .  C ADDR   1647H   A 
AQUISITION_ROT_BEG  C ADDR   155CH   A 
ARMING_PPM_CHECK .  C ADDR   12CBH   A 
COMM45_CP. . . . .  C ADDR   0F34H   A 
WAIT_BEFORE_ZC_SC~  C ADDR   0D60H   A 
MEASURE_LIPO_UPDA~  C ADDR   0A77H   A 
GOVERNOR_CORR_INT~  C ADDR   0978H   A 
GOVERNOR_STORE_PR~  C ADDR   085FH   A 
WAIT200MS. . . . .  C ADDR   06D7H   A 
T2_INT_CURRENT_PW~  C ADDR   0468H   A 
T2_INT_RCP_GAIN_C~  C ADDR   043AH   A 
T2_INT_PULSES_ABS~  C ADDR   03ACH   A 
EEP_PGM_STARTUP_P~  C ADDR   1A09H   A 
PGM_LOW_VOLTAGE_L~  I ADDR   0086H   A 
RCP_PREPREV_EDGE_L  D ADDR   0052H   A 
WT_ADVANCE_L . . .  D ADDR   004AH   A 
GOV_ACTIVE . . . .  D ADDR   0049H   A 
TEMP1. . . . . . .    REG    R0             
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0050h            
IT01CF . . . . . .  D ADDR   00E4H   A 
ACC. . . . . . . .  D ADDR   00E0H   A 
TURNIGY_AE_25A_TA~  N NUMB   002Fh            
TURNIGY_PLUSH_10A~  N NUMB   001Dh            
RUN3 . . . . . . .  C ADDR   1665H   A 
DIRECT_METHOD_STA~  C ADDR   1451H   A 
DECODE_DAMPING_DO~  C ADDR   10FBH   A 
PWM_WAIT . . . . .  C ADDR   0DD8H   A 
CHECK_VOLTAGE_EXIT  C ADDR   0B7DH   A 
CHECK_VOLTAGE_INP~  C ADDR   0AEBH   A 
GOVERNOR_LIMIT_IN~  C ADDR   0960H   A 
GOVERNOR_CHECK_IN~  C ADDR   0883H   A 
WAIT3MS. . . . . .  C ADDR   06C7H   A 
THROTTLE_RATE_TAB~  C ADDR   008DH   A 
EEP_FW_MAIN_REVIS~  C ADDR   1A00H   A 
PGM_PPM_MIN_THROT~  I ADDR   0098H   A 
GOV_INTEGRAL_H . .  D ADDR   0043H   A 
POWER_ON_WAIT_CNT~  D ADDR   0032H   A 
TEMP2. . . . . . .    REG    R1             
AQUISITION_ROTATI~  N NUMB   0002h            
RCP_STOP_LIMIT . .  N NUMB   00FAh            
RCP_MIN. . . . . .  N NUMB   0000h            
AD0EN. . . . . . .  B ADDR   00E8H.7 A 
STA. . . . . . . .  B ADDR   00C0H.5 A 
ES0. . . . . . . .  B ADDR   00A8H.4 A 
S0MODE . . . . . .  B ADDR   0098H.7 A 
VDM0CN . . . . . .  D ADDR   00FFH   A 
P0MDIN . . . . . .  D ADDR   00F1H   A 
CPT0MD . . . . . .  D ADDR   009DH   A 
CPT0CN . . . . . .  D ADDR   009BH   A 
SKYWALKER_20A_TAIL  N NUMB   0035h            
TURNIGY_AE_25A_MU~  N NUMB   0030h            
TURNIGY_PLUSH_25A~  N NUMB   0025h            
TURNIGY_PLUSH_10A~  N NUMB   001Eh            
XP_7A_TAIL . . . .  N NUMB   0005h            
BEEP_NO_ENTRY. . .  C ADDR   1D15H   A 
JMP_WAIT_FOR_POWE~  C ADDR   1770H   A 
DIRECT_START_CHEC~  C ADDR   16F9H   A 
RUN4 . . . . . . .  C ADDR   1683H   A 
STORE_TIMES_UP_OR~  C ADDR   0D37H   A 
STORE_TIMES_DECRE~  C ADDR   0D4AH   A 
STEPPER_STEP_SET .  C ADDR   0C3EH   A 
CHECK_VOLTAGE_COM~  C ADDR   0B19H   A 
GOVERNOR_CORR_INT~  C ADDR   098CH   A 
MULT_S16_BY_U16_E~  C ADDR   079AH   A 
MULT_S16_BY_U8_DI~  C ADDR   0749H   A 
PCA_INT_PPM_NEG_C~  C ADDR   0642H   A 
T0_INT_PWM_OFF_CO~  C ADDR   012CH   A 
EEP_PGM_DIRECTION~  C ADDR   1A0BH   A 
_EEP_PGM_MOTOR_ID~  C ADDR   1A08H   A 
INITIAL_ARM. . . .  D ADDR   0030H   A 
RCP_PWM_FREQ_8KHZ.  N NUMB   0003h            
TEMP3. . . . . . .    REG    R2             
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_PWM_HIGH_OFF~  N NUMB   0014h            
CF . . . . . . . .  B ADDR   00D8H.7 A 
ET0. . . . . . . .  B ADDR   00A8H.1 A 
P1MDIN . . . . . .  D ADDR   00F2H   A 
ADC0CN . . . . . .  D ADDR   00E8H   A 
P0MDOUT. . . . . .  D ADDR   00A4H   A 
SKYWALKER_20A_MUL~  N NUMB   0036h            
TURNIGY_PLUSH_30A~  N NUMB   0029h            
TURNIGY_PLUSH_12A~  N NUMB   0020h            
XP_7A_MULTI. . . .  N NUMB   0006h            
READ_TAGS. . . . .  C ADDR   187EH   A 
RUN5 . . . . . . .  C ADDR   16A1H   A 
COMP_READ. . . . .  C ADDR   0DDEH   A 
COMP_WAIT_SET_RES~  C ADDR   0DA1H   A 
DIVIDE_WAIT_TIMES.  C ADDR   0CE9H   A 
CHECK_VOLTAGE_COM~  C ADDR   0AC8H   A 
GOVERNOR_CORR_NEG~  C ADDR   097DH   A 
GOVERNOR_LIMIT_PR~  C ADDR   0854H   A 
GOVERNOR_TARGET_C~  C ADDR   07E2H   A 
CALC_GOVERNOR_TAR~  C ADDR   07A3H   A 
PCA_INT_PWM_DIVID~  C ADDR   0676H   A 
T2_INT_CURRENT_PW~  C ADDR   0489H   A 
EEP_PGM_DAMPING_F~  C ADDR   1A16H   A 
PGM_PPM_MAX_THROT~  I ADDR   0099H   A 
BEEP_STRENGTH. . .  D ADDR   006CH   A 
RCP_PREV_PERIOD_H.  D ADDR   0057H   A 
DIRECT_STARTUP_OK~  D ADDR   0038H   A 
RCP_MEAS_PWM_FREQ.  N NUMB   0001h            
TEMP4. . . . . . .    REG    R3             
RCP_STOP . . . . .  N NUMB   0001h            
RCP_MAX. . . . . .  N NUMB   00FFh            
ET1. . . . . . . .  B ADDR   00A8H.3 A 
TF0. . . . . . . .  B ADDR   0088H.5 A 
P1MDOUT. . . . . .  D ADDR   00A5H   A 
IDA0L. . . . . . .  D ADDR   0096H   A 
SKYWALKER_40A_TAIL  N NUMB   0038h            
TURNIGY_PLUSH_30A~  N NUMB   002Ah            
TURNIGY_PLUSH_18A~  N NUMB   0022h            
TURNIGY_PLUSH_12A~  N NUMB   0021h            
SUPERMICRO_3P5A_T~  N NUMB   0017h            
RUN6 . . . . . . .  C ADDR   16BFH   A 
ARMING_START . . .  C ADDR   12B3H   A 
MEASURE_PWM_FREQ_~  C ADDR   1257H   A 
DECREMENT_STEP_EX~  C ADDR   104AH   A 
GOVERNOR_DEACTIVA~  C ADDR   07CCH   A 
MULT_S16_BY_U16_D~  C ADDR   077DH   A 
PWM_BNFET_APFET_O~  C ADDR   02ABH   A 
PWM_ANFET_BPFET_O~  C ADDR   01E0H   A 
PWM_NOFET_ON . . .  C ADDR   017AH   A 
EEP_PGM_MOTOR_GAIN  C ADDR   1A07H   A 
_EEP_PGM_GOV_MODE.  C ADDR   1A05H   A 
PGM_THROTTLE_RATE~  I ADDR   0092H   A 
PGM_MAIN_REARM_ST~  I ADDR   008BH   A 
STARTUP_ROT_CNT. .  D ADDR   0037H   A 
CURR_PWMOFF_COMP_~  N NUMB   0007h            
RCP_UPDATED. . . .  N NUMB   0000h            
T3_PENDING . . . .  N NUMB   0000h            
TEMP5. . . . . . .    REG    R4             
RCP_TIMEOUT. . . .  N NUMB   0018h            
COMP_PWM_HIGH_ON_~  N NUMB   0018h            
TF2LEN . . . . . .  B ADDR   00C8H.5 A 
ET2. . . . . . . .  B ADDR   00A8H.5 A 
RI0. . . . . . . .  B ADDR   0098H.0 A 
TF1. . . . . . . .  B ADDR   0088H.7 A 
TMR2RLH. . . . . .  D ADDR   00CBH   A 
SMB0DAT. . . . . .  D ADDR   00C2H   A 
P2MDOUT. . . . . .  D ADDR   00A6H   A 
SKYWALKER_40A_MUL~  N NUMB   0039h            
SUPERMICRO_3P5A_M~  N NUMB   0018h            
DP_3A_MAIN . . . .  N NUMB   0013h            
ARM_TARGET_UPDATED  C ADDR   1386H   A 
EVALUATE_COMPARAT~  C ADDR   0DEAH   A 
TEMP_CHECK_EXIT. .  C ADDR   0AC4H   A 
GOVERNOR_APPLY_PR~  C ADDR   0901H   A 
PWM_CNFET_APFET_O~  C ADDR   02F4H   A 
PWM_ANFET_CPFET_O~  C ADDR   0229H   A 
PGM_ENABLE_TX_PRO~  I ADDR   008AH   A 
GOV_INTEGRAL_L . .  D ADDR   0042H   A 
DIRECT_STARTUP_FA~  D ADDR   0039H   A 
POWER_ON_WAIT_CNT~  D ADDR   0031H   A 
GOVERNOR_REQ_PWM .  D ADDR   0023H   A 
TEMP6. . . . . . .    REG    R5             
NONDAMPED_RUN_ROT~  N NUMB   000Ah            
DEFAULT_PGM_PPM_M~  N NUMB   0025h            
DEFAULT_PGM_MAIN_~  N NUMB   0002h            
DEFAULT_PGM_MAIN_~  N NUMB   000Dh            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
MASTER . . . . . .  B ADDR   00C0H.7 A 
PSPI0. . . . . . .  B ADDR   00B8H.6 A 
PCA0H. . . . . . .  D ADDR   00FAH   A 
SPI0CFG. . . . . .  D ADDR   00A1H   A 
TMR3RLH. . . . . .  D ADDR   0093H   A 
TH0. . . . . . . .  D ADDR   008CH   A 
NORMAL_RUN_CHECKS.  C ADDR   1706H   A 
DEC_STEP_MED_LOW .  C ADDR   103AH   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D88H   A 
WAIT_ADVANCE_TIMI~  C ADDR   0CBDH   A 
CALC_GOVERNOR_PRO~  C ADDR   0823H   A 
T2_INT_PPM_TIMEOU~  C ADDR   03EDH   A 
PWM_CNFET_BPFET_O~  C ADDR   034DH   A 
PWM_BNFET_CPFET_O~  C ADDR   026AH   A 
_EEP_PGM_GOV_I_GA~  C ADDR   1A04H   A 
EEP_FW_SUB_REVISI~  C ADDR   1A01H   A 
PGM_BEEP_STRENGTH.  I ADDR   009AH   A 
PGM_STARTUP_ACCEL.  I ADDR   008EH   A 
TEMP7. . . . . . .    REG    R6             
DEFAULT_PGM_MAIN_~  N NUMB   00B4h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
COMP_COM . . . . .  N NUMB   0003h            
ADC_LIMIT_H. . . .  N NUMB   0000h            
EX0. . . . . . . .  B ADDR   00A8H.0 A 
TI0. . . . . . . .  B ADDR   0098H.1 A 
IT0. . . . . . . .  B ADDR   0088H.0 A 
SPI0CN . . . . . .  D ADDR   00F8H   A 
TMR2H. . . . . . .  D ADDR   00CDH   A 
TH1. . . . . . . .  D ADDR   008DH   A 
TURNIGY_PLUSH_25A~  N NUMB   0026h            
PROGRAM_BY_TX_ENT~  C ADDR   136FH   A 
READ_ALL_EEPROM_P~  C ADDR   17B1H   A 
CHECK_TEMP_VOLTAG~  C ADDR   0A80H   A 
T0_INT . . . . . .  C ADDR   009AH   A 
PGM_STARTUP_PWR. .  I ADDR   0089H   A 
RCP_STOP_CNT . . .  D ADDR   005CH   A 
NEW_RCP. . . . . .  D ADDR   0059H   A 
RCP_PREV_PERIOD_L.  D ADDR   0056H   A 
PGM_DIR_REV. . . .  N NUMB   0004h            
PGM_PWMOFF_DAMPED~  N NUMB   0003h            
INITIAL_RUN_PHASE.  N NUMB   0004h            
TEMP8. . . . . . .    REG    R7             
RCP_VALIDATE . . .  N NUMB   0002h            
DEFAULT_PGM_PPM_M~  N NUMB   00D0h            
DEBUGPIN . . . . .  N NUMB   0000h            
ANFET. . . . . . .  N NUMB   0007h            
EX1. . . . . . . .  B ADDR   00A8H.2 A 
IT1. . . . . . . .  B ADDR   0088H.2 A 
OSCXCN . . . . . .  D ADDR   00B1H   A 
IE . . . . . . . .  D ADDR   00A8H   A 
TMR3H. . . . . . .  D ADDR   0095H   A 
CKCON. . . . . . .  D ADDR   008EH   A 
TURNIGY_PLUSH_25A~  N NUMB   0027h            
EVAL_COMP_EXIT . .  C ADDR   0E0CH   A 
STEPPER_STEP_LOW .  C ADDR   0C30H   A 
MEASURE_LIPO_3125.  C ADDR   0A63H   A 
MEASURE_LIPO_ADJU~  C ADDR   0A09H   A 
PCA_INT_SET_TIMEO~  C ADDR   0690H   A 
PWM_AFET_ON. . . .  C ADDR   017CH   A 
T0_INT_PWM_ON_EXE~  C ADDR   00A6H   A 
EEP_PGM_STARTUP_M~  C ADDR   1A18H   A 
EEP_PGM_COMM_TIMI~  C ADDR   1A15H   A 
EEP_PGM_VOLT_COMP.  C ADDR   1A14H   A 
WT_STEPPER_STEP_H.  D ADDR   0051H   A 
PREV_COMM_H. . . .  D ADDR   003BH   A 
RCP_TIMEOUT_CNT. .  D ADDR   0029H   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0000h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
BNFET. . . . . . .  N NUMB   0005h            
TEMP_LIMIT_STEP. .  N NUMB   0006h            
TXBMT. . . . . . .  B ADDR   00F8H.1 A 
RXOVRN . . . . . .  B ADDR   00F8H.4 A 
ACK. . . . . . . .  B ADDR   00C0H.1 A 
PCA0CPH0 . . . . .  D ADDR   00FCH   A 
EIP1 . . . . . . .  D ADDR   00F6H   A 
TMR2RLL. . . . . .  D ADDR   00CAH   A 
IDA0CN . . . . . .  D ADDR   00B9H   A 
TURNIGY_PLUSH_18A~  N NUMB   0023h            
XP_12A_MAIN. . . .  N NUMB   000Ah            
STEPPER_ROT_EXIT .  C ADDR   1553H   A 
STEPPER_METHOD_ST~  C ADDR   1488H   A 
COMM12_DAMP. . . .  C ADDR   0E31H   A 
SETUP_COMM_WAIT. .  C ADDR   0E0DH   A 
CALC_NEXT_COMM_TI~  C ADDR   0C5BH   A 
CHECK_VOLTAGE_LIM.  C ADDR   0B5FH   A 
CALC_GOVERNOR_INT~  C ADDR   08BDH   A 
T2_INT_SET_CURREN~  C ADDR   0486H   A 
PWM_BFET_ON. . . .  C ADDR   018EH   A 
T2_INT . . . . . .  C ADDR   0394H   A 
PGM_DIRECTION_REV.  I ADDR   0096H   A 
LIPO_ADC_REFERENC~  D ADDR   0066H   A 
PWM_ON . . . . . .  N NUMB   0002h            
BIT_ACCESS . . . .  D ADDR   0020H   A 
DEFAULT_PGM_ENABL~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
CNFET. . . . . . .  N NUMB   0003h            
APFET. . . . . . .  N NUMB   0006h            
P. . . . . . . . .  B ADDR   00D0H.0 A 
PCA0L. . . . . . .  D ADDR   00F9H   A 
PCA0CPH1 . . . . .  D ADDR   00EAH   A 
TMR3RLL. . . . . .  D ADDR   0092H   A 
TL0. . . . . . . .  D ADDR   008AH   A 
PCON . . . . . . .  D ADDR   0087H   A 
TURNIGY_PLUSH_18A~  N NUMB   0024h            
DP_3A_TAIL . . . .  N NUMB   0014h            
XP_7A_FAST_MAIN. .  N NUMB   0007h            
ARM_END_BEEP . . .  C ADDR   1392H   A 
THROTTLE_HIGH_CAL~  C ADDR   1306H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D79H   A 
LOAD_MIN_TIME. . .  C ADDR   0D05H   A 
CALC_NEW_WAIT_TIM~  C ADDR   0CD6H   A 
SET_STARTUP_PWM. .  C ADDR   0B88H   A 
GOVERNOR_STORE_IN~  C ADDR   08B7H   A 
PWM_CFET_ON. . . .  C ADDR   01A0H   A 
GOV_GAIN_TABLE . .  C ADDR   0080H   A 
T3_INT . . . . . .  C ADDR   04E4H   A 
PGM_DAMPING_FORCE.  I ADDR   0093H   A 
PGM_MOTOR_IDLE . .  I ADDR   0088H   A 
TX_PGM_PARAVAL_NO.  D ADDR   006EH   A 
ADC_CONVERSION_CNT  D ADDR   006AH   A 
GOV_ARM_TARGET . .  D ADDR   0048H   A 
COMP_WAIT_READS. .  D ADDR   003FH   A 
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
DEFAULT_PGM_TAIL_~  N NUMB   000Dh            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
BPFET. . . . . . .  N NUMB   0004h            
ADC_LIMIT_L. . . .  N NUMB   0055h            
EEP_ESC_LAYOUT . .  C ADDR   1A40H   A 
TXMODE . . . . . .  B ADDR   00C0H.6 A 
PCA0CPH2 . . . . .  D ADDR   00ECH   A 
TMR2L. . . . . . .  D ADDR   00CCH   A 
TL1. . . . . . . .  D ADDR   008BH   A 
DP_3A_MULTI. . . .  N NUMB   0015h            
FUNC_PARAVAL . . .  C ADDR   1D18H   A 
WAIT1S_LOOP. . . .  C ADDR   1C86H   A 
STORE_MULTI_FUNC_1  C ADDR   1C04H   A 
DECREMENT_STEP . .  C ADDR   0FFDH   A 
COMM23_DAMP. . . .  C ADDR   0E6AH   A 
ADJUST_TIMING. . .  C ADDR   0D09H   A 
STEPPER_STEP_MED_~  C ADDR   0C06H   A 
MEASURE_LIPO_START  C ADDR   0991H   A 
CALC_GOVERNOR_PRO~  C ADDR   092AH   A 
GOVERNOR_INT_MIN_~  C ADDR   08B2H   A 
GOVERNOR_LIMIT_PR~  C ADDR   085BH   A 
BEEP_F1. . . . . .  C ADDR   06E6H   A 
EEP_PGM_BEACON_DE~  C ADDR   1A1DH   A 
EEP_PGM_BEACON_ST~  C ADDR   1A1CH   A 
TAG_TEMPORARY_STO~  I ADDR   00D0H   A 
PGM_MOTOR_GAIN . .  I ADDR   0087H   A 
PWM_OFF_CNT. . . .  D ADDR   0062H   A 
PWM_SPOOLUP_BEG. .  D ADDR   005FH   A 
PWM_LIMIT. . . . .  D ADDR   005DH   A 
WT_ZC_SCAN_H . . .  D ADDR   004DH   A 
STEPPER_STEP_BEG_H  D ADDR   0034H   A 
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   000Dh            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
CPFET. . . . . . .  N NUMB   0002h            
SPIF . . . . . . .  B ADDR   00F8H.7 A 
T2SPLIT. . . . . .  B ADDR   00C8H.3 A 
ACKRQ. . . . . . .  B ADDR   00C0H.3 A 
TMR3L. . . . . . .  D ADDR   0094H   A 
STORE_MULTI_FUNC_2  C ADDR   1C0EH   A 
INITIAL_RUN_PHASE~  C ADDR   1724H   A 
AQUISITION_ROT_EX~  C ADDR   15D0H   A 
STEPPER_STEP_MED .  C ADDR   0C14H   A 
CHECK_VOLTAGE_COM~  C ADDR   0B3AH   A 
GOVERNOR_STORE_PR~  C ADDR   0928H   A 
GOVERNOR_CHECK_PR~  C ADDR   08ECH   A 
BEEP_ONOFF . . . .  C ADDR   0705H   A 
BEEP_F2. . . . . .  C ADDR   06ECH   A 
PCA_INT_CHECK_DIFF  C ADDR   05D7H   A 
T2_INT_SKIP_START.  C ADDR   03F1H   A 
T0_INT_PWM_OFF_FU~  C ADDR   0173H   A 
_EEP_PGM_GOV_RANGE  C ADDR   1A17H   A 
EEPROM_LAYOUT_REV~  N NUMB   000Dh            
PGM_GOV_MODE . . .  I ADDR   0084H   A 
WT_STEPPER_STEP_L.  D ADDR   0050H   A 
PREV_COMM_L. . . .  D ADDR   003AH   A 
PGM_PWMOFF_DAMPED~  N NUMB   0004h            
STEPPER_PHASE. . .  N NUMB   0002h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
P0_INIT. . . . . .  N NUMB   00FFh            
PS0. . . . . . . .  B ADDR   00B8H.4 A 
PCA0CPL0 . . . . .  D ADDR   00FBH   A 
XP_25A_MAIN. . . .  N NUMB   0010h            
PARAVAL_NO_ENTRY .  C ADDR   1D12H   A 
STORE_MULTI_FUNC_3  C ADDR   1C18H   A 
SUCCESS_BEEP_INVE~  C ADDR   1CBBH   A 
SUCCESS_BEEP . . .  C ADDR   1C8CH   A 
FIND_THROTTLE_GAIN  C ADDR   117AH   A 
DECREMENT_STEPPER~  C ADDR   0FF1H   A 
COMM61_DAMP. . . .  C ADDR   0F89H   A 
COMM34_DAMP. . . .  C ADDR   0EC4H   A 
GOVERNOR_INT_MAX_~  C ADDR   08ABH   A 
GOVERNOR_LIMIT_IN~  C ADDR   088CH   A 
BEEP_F3. . . . . .  C ADDR   06F2H   A 
PCA_INT_FAIL_MINI~  C ADDR   0525H   A 
T0_INT_PWM_ON_EXI~  C ADDR   038DH   A 
T0_INT_PWM_OFF_EX~  C ADDR   0163H   A 
_EEP_PGM_GOV_P_GA~  C ADDR   1A03H   A 
LIPO_ADC_REFERENC~  D ADDR   0065H   A 
PWM_ON_CNT . . . .  D ADDR   0061H   A 
FULL_THROTTLE_RAN~  N NUMB   0006h            
CURR_PWMOFF_DAMPED  N NUMB   0006h            
COMM_TIME_RED. . .  N NUMB   0005h            
P1_INIT. . . . . .  N NUMB   00A9h            
TF2H . . . . . . .  B ADDR   00C8H.7 A 
PT0. . . . . . . .  B ADDR   00B8H.1 A 
PCA0CPL1 . . . . .  D ADDR   00E9H   A 
PCA0CPM0 . . . . .  D ADDR   00DAH   A 
FLSCL. . . . . . .  D ADDR   00B6H   A 
TMOD . . . . . . .  D ADDR   0089H   A 
TCON . . . . . . .  D ADDR   0088H   A 
XP_12A_TAIL. . . .  N NUMB   000Bh            
STORE_MULTI_FUNC_4  C ADDR   1C22H   A 
DAMPED_TRANSITION.  C ADDR   161EH   A 
BEEP_DELAY_SET . .  C ADDR   13CDH   A 
PROGRAM_BY_TX_ENT~  C ADDR   12ECH   A 
DECODE_PWM_FREQ_L~  C ADDR   114BH   A 
DECODE_DAMPING_3 .  C ADDR   10D1H   A 
STARTUP_PWM_GAIN_~  C ADDR   0BB9H   A 
BEEP_F4. . . . . .  C ADDR   06F8H   A 
PCA_INT_PPM_MAX_C~  C ADDR   0651H   A 
PCA_INT_RESTORE_E~  C ADDR   05C3H   A 
T2H_INT_RCP_EXIT .  C ADDR   04DBH   A 
PGM_GOV_I_GAIN . .  I ADDR   0081H   A 
RCP_EDGE_NO. . . .  N NUMB   0001h            
DEFAULT_PGM_MULTI~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0078h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DAMPED_MODE_ENABLE  N NUMB   0000h            
NSSMD0 . . . . . .  B ADDR   00F8H.2 A 
WCOL . . . . . . .  B ADDR   00F8H.6 A 
AD0CM0 . . . . . .  B ADDR   00E8H.0 A 
CR . . . . . . . .  B ADDR   00D8H.6 A 
RS0. . . . . . . .  B ADDR   00D0H.3 A 
PT1. . . . . . . .  B ADDR   00B8H.3 A 
REN0 . . . . . . .  B ADDR   0098H.4 A 
PCA0CPL2 . . . . .  D ADDR   00EBH   A 
PCA0CPM1 . . . . .  D ADDR   00DBH   A 
PCA0MD . . . . . .  D ADDR   00D9H   A 
PCA0CN . . . . . .  D ADDR   00D8H   A 
SPI0DAT. . . . . .  D ADDR   00A3H   A 
XP_18A_MAIN. . . .  N NUMB   000Dh            
XP_12A_MULTI . . .  N NUMB   000Ch            
XP_7A_FAST_TAIL. .  N NUMB   0008h            
PROGRAM_BY_TX_EXIT  C ADDR   1D9BH   A 
STORE_MULTI_FUNC_5  C ADDR   1C2CH   A 
READ_EEPROM_BYTE .  C ADDR   1772H   A 
THROTTLE_LOW_CAL .  C ADDR   133AH   A 
DECODE_DAMPING_4 .  C ADDR   10E0H   A 
COMM45_DAMP. . . .  C ADDR   0EFEH   A 
GOVERNOR_APPLY_IN~  C ADDR   0964H   A 
GOVERNOR_LIMIT_PR~  C ADDR   08F7H   A 
CALC_GOVERNOR_STO~  C ADDR   081EH   A 
BEEP_OFF . . . . .  C ADDR   073DH   A 
WAIT10MS . . . . .  C ADDR   06CBH   A 
T2H_INT_RCP_NO_LI~  C ADDR   04D9H   A 
T0_INT_PWM_ON_EXIT  C ADDR   0380H   A 
EEP_INITIALIZED_H.  C ADDR   1A0EH   A 
EEP_PGM_INPUT_POL.  C ADDR   1A0CH   A 
EEPROM_FW_MAIN_RE~  N NUMB   0007h            
PGM_VOLT_COMP. . .  I ADDR   0095H   A 
PGM_COMM_TIMING. .  I ADDR   0090H   A 
PGM_STARTUP_METHOD  I ADDR   008FH   A 
TX_PGM_FUNC_NO . .  D ADDR   006DH   A 
WT_ZC_SCAN_L . . .  D ADDR   004CH   A 
STEPPER_STEP_BEG_L  D ADDR   0033H   A 
AQUISITION_PHASE .  N NUMB   0003h            
MOTOR_SPINNING . .  N NUMB   0000h            
CURRENT_PWM. . . .  D ADDR   0024H   A 
PWM_STEPPER. . . .  N NUMB   0078h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
P0_SKIP. . . . . .  N NUMB   00DFh            
NSSMD1 . . . . . .  B ADDR   00F8H.3 A 
AD0CM1 . . . . . .  B ADDR   00E8H.1 A 
AD0TM. . . . . . .  B ADDR   00E8H.6 A 
RS1. . . . . . . .  B ADDR   00D0H.4 A 
F0 . . . . . . . .  B ADDR   00D0H.5 A 
STO. . . . . . . .  B ADDR   00C0H.4 A 
PT2. . . . . . . .  B ADDR   00B8H.5 A 
TR0. . . . . . . .  B ADDR   0088H.4 A 
PCA0CPM2 . . . . .  D ADDR   00DCH   A 
TMR2CN . . . . . .  D ADDR   00C8H   A 
HIMODEL_COOL_22A_~  N NUMB   003Ah            
XP_7A_FAST_MULTI .  N NUMB   0009h            
STORE_MULTI_FUNC_6  C ADDR   1C36H   A 
READ_TAG . . . . .  C ADDR   1887H   A 
RESET_CAL_DONE . .  C ADDR   11BFH   A 
DECODE_DAMPING_5 .  C ADDR   10EFH   A 
DECODE_PARAMETERS.  C ADDR   10B8H   A 
STEPPER_TIMER_WAIT  C ADDR   1054H   A 
STORE_TIMES_INCRE~  C ADDR   0D3DH   A 
CHECK_VOLTAGE_GOOD  C ADDR   0B58H   A 
MEASURE_LIPO_CELLS  C ADDR   0991H   A 
CALC_GOVERNOR_INT~  C ADDR   0864H   A 
PCA_INT_PPM_CALCU~  C ADDR   062CH   A 
PCA_INT_EXIT . . .  C ADDR   06ACH   A 
T2_INT_RCP_UPDATE~  C ADDR   0422H   A 
T0_INT_PWM_OFF_DO~  C ADDR   00FAH   A 
RCP_PERIOD_DIFF_A~  D ADDR   0058H   A 
P1_SKIP. . . . . .  N NUMB   0001h            
AD0CM2 . . . . . .  B ADDR   00E8H.2 A 
AD0WINT. . . . . .  B ADDR   00E8H.3 A 
F1 . . . . . . . .  B ADDR   00D0H.1 A 
ARBLOST. . . . . .  B ADDR   00C0H.2 A 
TR1. . . . . . . .  B ADDR   0088H.6 A 
P0SKIP . . . . . .  D ADDR   00D4H   A 
TMR3CN . . . . . .  D ADDR   0091H   A 
TURNIGY_PLUSH_6A_~  N NUMB   0019h            
STORE_MULTI_FUNC_7  C ADDR   1C40H   A 
RUN6_CHECK_SPEED .  C ADDR   1735H   A 
DEC_STEP_LOW . . .  C ADDR   1042H   A 
COMM56_DAMP. . . .  C ADDR   0F4FH   A 
SWITCH_POWER_OFF .  C ADDR   0FE1H   A 
WAIT30MS . . . . .  C ADDR   06CFH   A 
PCA_INT_CHECK_1KHZ  C ADDR   05B6H   A 
T2H_INT. . . . . .  C ADDR   04AAH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0134H   A 
EEP_ESC_MCU. . . .  C ADDR   1A50H   A 
GOV_INTEGRAL_X . .  D ADDR   0044H   A 
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
NFETON_DELAY . . .  N NUMB   0019h            
AD0BUSY. . . . . .  B ADDR   00E8H.4 A 
T2XCLK . . . . . .  B ADDR   00C8H.0 A 
TR2. . . . . . . .  B ADDR   00C8H.2 A 
TF2L . . . . . . .  B ADDR   00C8H.6 A 
PX0. . . . . . . .  B ADDR   00B8H.0 A 
P1SKIP . . . . . .  D ADDR   00D5H   A 
XP_25A_TAIL. . . .  N NUMB   0011h            
FUNC_PARAVAL_CONT~  C ADDR   1D48H   A 
WAIT1S . . . . . .  C ADDR   1C84H   A 
STORE_MULTI_FUNC_8  C ADDR   1C4AH   A 
WRITE_TAGS . . . .  C ADDR   1892H   A 
RUN_TO_WAIT_FOR_P~  C ADDR   173EH   A 
EVAL_COMP_CHECK_T~  C ADDR   0E02H   A 
ADJUST_TIMING_TWO~  C ADDR   0D2CH   A 
CALC_GOVERNOR_PRO~  C ADDR   08C5H   A 
WAITXMS_M. . . . .  C ADDR   06DDH   A 
PCA_INT_CHECK_2KHZ  C ADDR   05A7H   A 
T0_INT_PWM_OFF_ST~  C ADDR   00D4H   A 
PGM_BEACON_DELAY .  I ADDR   009CH   A 
PGM_BEACON_STRENG~  I ADDR   009BH   A 
GOV_TARGET_H . . .  D ADDR   0041H   A 
PWM_AQUISITION . .  N NUMB   0050h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0007h            
PX1. . . . . . . .  B ADDR   00B8H.2 A 
IP . . . . . . . .  D ADDR   00B8H   A 
XP_25A_MULTI . . .  N NUMB   0012h            
STORE_MULTI_FUNC_9  C ADDR   1C54H   A 
WAIT_FOR_POWER_ON~  C ADDR   13E7H   A 
DECODE_PWM_FREQ_E~  C ADDR   1150H   A 
CHECK_VOLTAGE_LIM~  C ADDR   0B3DH   A 
START_ADC_CONVERS~  C ADDR   0A7CH   A 
PCA_INT_PPM_LIMIT~  C ADDR   0669H   A 
T2H_INT_RCP_GOV_P~  C ADDR   04CDH   A 
T2_INT_PWM_MIN_RUN  C ADDR   044AH   A 
PWM_BNFET_APFET_O~  C ADDR   028DH   A 
PWM_ANFET_BPFET_O~  C ADDR   01BAH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0154H   A 
EEP_NAME . . . . .  C ADDR   1A60H   A 
EEP_INITIALIZED_L.  C ADDR   1A0DH   A 
BIT_ACCESS_INT . .  D ADDR   0021H   A 
DEFAULT_PGM_TAIL_~  N NUMB   00FAh            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
MUX_A. . . . . . .  N NUMB   0002h            
PFETON_DELAY . . .  N NUMB   0001h            
PSW. . . . . . . .  D ADDR   00D0H   A 
XP_18A_TAIL. . . .  N NUMB   000Eh            
STORE_IN_RAM_EXIT.  C ADDR   1C83H   A 
VALIDATE_RCP_START  C ADDR   128DH   A 
DEC_STEP_MED_HIGH.  C ADDR   1028H   A 
COMM12_NONDAMP . .  C ADDR   0E4FH   A 
COMM1COMM2 . . . .  C ADDR   0E27H   A 
STARTUP_PWM_CORR .  C ADDR   0BAFH   A 
CALC_GOVERNOR_PRO~  C ADDR   08BEH   A 
CALC_GOVERNOR_TAR~  C ADDR   0803H   A 
WAITXMS_O. . . . .  C ADDR   06DBH   A 
PCA_INT_PPM_TIMEO~  C ADDR   069CH   A 
PCA_INT_CHECK_4KHZ  C ADDR   0598H   A 
PWM_CNFET_APFET_O~  C ADDR   02CEH   A 
PWM_ANFET_CPFET_O~  C ADDR   020BH   A 
T0_INT_PWM_OFF_CO~  C ADDR   0159H   A 
T0_INT_PWM_ON_STO~  C ADDR   00ADH   A 
T0_INT_PWM_OFF . .  C ADDR   00B0H   A 
EEPROM_FW_SUB_REV~  N NUMB   0000h            
PGM_GOV_RANGE. . .  I ADDR   0085H   A 
GOV_PROPORTIONAL_H  D ADDR   0046H   A 
STEPPER_STEP_END_H  D ADDR   0036H   A 
DEFAULT_PGM_MULTI~  N NUMB   0028h            
DEFAULT_PGM_MULTI~  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0003h            
MUX_B. . . . . . .  N NUMB   0000h            
RCP_IN . . . . . .  N NUMB   0005h            
TEMP_LIMIT_H . . .  N NUMB   0001h            
COMP_PWM_LOW_OFF_~  N NUMB   0007h            
ADC0GTH. . . . . .  D ADDR   00C4H   A 
SMB0CF . . . . . .  D ADDR   00C1H   A 
FLKEY. . . . . . .  D ADDR   00B7H   A 
HIMODEL_COOL_22A_~  N NUMB   003Bh            
XP_18A_MULTI . . .  N NUMB   000Fh            
READ_EEPROM_EXIT .  C ADDR   187DH   A 
WAIT_FOR_POWER_ON~  C ADDR   13AAH   A 
DEC_STEP_MED . . .  C ADDR   1031H   A 
READ_TIMER . . . .  C ADDR   0C66H   A 
CALC_GOVERNOR_INT~  C ADDR   0990H   A 
GOVERNOR_LIMIT_IN~  C ADDR   0895H   A 
BEEP . . . . . . .  C ADDR   06FEH   A 
PCA_INT_FALL . . .  C ADDR   05F1H   A 
T2_INT_PWM_EXIT. .  C ADDR   049EH   A 
T2_INT_SKIP_END. .  C ADDR   03F9H   A 
PWM_CNFET_BPFET_O~  C ADDR   031FH   A 
PWM_BNFET_CPFET_O~  C ADDR   024CH   A 
T0_INT_PWM_OFF_DA~  C ADDR   0111H   A 
PGM_GOV_I_GAIN_DE~  I ADDR   0083H   A 
PGM_GOV_P_GAIN . .  I ADDR   0080H   A 
DAMPING_ON . . . .  D ADDR   0064H   A 
COMM_PHASE . . . .  D ADDR   003EH   A 
PGM_PWMOFF_DAMPED.  N NUMB   0002h            
RCP_PREV_EDGE_H. .  D ADDR   0028H   A 
DEFAULT_PGM_MULTI~  N NUMB   0003h            
P0_PUSHPULL. . . .  N NUMB   0000h            
MUX_C. . . . . . .  N NUMB   0006h            
CCF0 . . . . . . .  B ADDR   00D8H.0 A 
CY . . . . . . . .  B ADDR   00D0H.7 A 
SI . . . . . . . .  B ADDR   00C0H.0 A 
RB80 . . . . . . .  B ADDR   0098H.2 A 
XBR0 . . . . . . .  D ADDR   00E1H   A 
EMI0CN . . . . . .  D ADDR   00AAH   A 
SPI0CKR. . . . . .  D ADDR   00A2H   A 
CPT0MX . . . . . .  D ADDR   009FH   A 
DPH. . . . . . . .  D ADDR   0083H   A 
HIMODEL_COOL_22A_~  N NUMB   003Ch            
TURNIGY_PLUSH_6A_~  N NUMB   001Ah            
PARAVAL_END_A. . .  C ADDR   1D64H   A 
ERASE_FLASH. . . .  C ADDR   178BH   A 
PROGRAM_BY_TX. . .  C ADDR   1D09H   A 
COMM23_NFET. . . .  C ADDR   0E8DH   A 
COMM23_NONDAMP . .  C ADDR   0E8AH   A 
COMM2COMM3 . . . .  C ADDR   0E62H   A 
STEPPER_STEP_HIGH.  C ADDR   0BF8H   A 
GOVERNOR_STORE_IN~  C ADDR   098EH   A 
GOVERNOR_CHECK_IN~  C ADDR   094DH   A 
GOVERNOR_CORR_PRO~  C ADDR   0915H   A 
EEP_PGM_THROTTLE_~  C ADDR   1A1EH   A 
EEP_PGM_STARTUP_R~  C ADDR   1A12H   A 
_EEP_PGM_GOV_SETU~  C ADDR   1A11H   A 
EEP_PGM_PWM_FREQ .  C ADDR   1A0AH   A 
PGM_INPUT_POL. . .  I ADDR   0097H   A 
WT_COMM_H. . . . .  D ADDR   004FH   A 
GOV_TARGET_L . . .  D ADDR   0040H   A 
DIRECT_STARTUP_PH~  N NUMB   0005h            
FLAGS0 . . . . . .  D ADDR   002CH   A 
RCP_EDGE_CNT . . .  D ADDR   002BH   A 
CURRENT_PWM_LIMIT~  D ADDR   0026H   A 
COMM_TIME_MIN. . .  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0001h            
P1_PUSHPULL. . . .  N NUMB   00FCh            
P0_DIGITAL . . . .  N NUMB   FFFFFFB2h            
COMP_PWM_LOW_ON_D~  N NUMB   0008h            
CCF1 . . . . . . .  B ADDR   00D8H.1 A 
XBR1 . . . . . . .  D ADDR   00E2H   A 
OSCICL . . . . . .  D ADDR   00B3H   A 
TURNIGY_AE_20A_MA~  N NUMB   002Bh            
TURNIGY_PLUSH_6A_~  N NUMB   001Bh            
PARAVAL_END_B. . .  C ADDR   1D6FH   A 
FUNC_PARAVAL_STORE  C ADDR   1D37H   A 
WRITE_EEPROM_BYTE~  C ADDR   1777H   A 
TEST_GAIN. . . . .  C ADDR   1197H   A 
MEASURE_LIPO_EXIT.  C ADDR   0A7BH   A 
GOVERNOR_LIMIT_PR~  C ADDR   08FDH   A 
GOVERNOR_CHECK_PR~  C ADDR   0848H   A 
PCA_INT_SECOND_ME~  C ADDR   0551H   A 
T2H_INT_RCP_STOP_~  C ADDR   04BAH   A 
PCA_INT. . . . . .  C ADDR   04EEH   A 
VOLTAGE_COMP_FACT~  D ADDR   0069H   A 
FLAGS1 . . . . . .  D ADDR   002DH   A 
TEMP_CHECK_RATE. .  N NUMB   0008h            
DEFAULT_PGM_MULTI~  N NUMB   0001h            
DEFAULT_PGM_TAIL_~  N NUMB   0005h            
DEFAULT_PGM_TAIL_~  N NUMB   0004h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
DEFAULT_PGM_MAIN_~  N NUMB   0003h            
DEFAULT_PGM_MAIN_~  N NUMB   0001h            
P2_PUSHPULL. . . .  N NUMB   0001h            
P1_DIGITAL . . . .  N NUMB   00FCh            
CCF2 . . . . . . .  B ADDR   00D8H.2 A 
TB80 . . . . . . .  B ADDR   0098H.3 A 
IE0. . . . . . . .  B ADDR   0088H.1 A 
REF0CN . . . . . .  D ADDR   00D1H   A 
CLKSEL . . . . . .  D ADDR   00A9H   A 
TURNIGY_AE_30A_MA~  N NUMB   0031h            
PARAVAL_END_C. . .  C ADDR   1D7AH   A 
MEASURE_PWM_FREQ_~  C ADDR   1255H   A 
COMM61_NFET. . . .  C ADDR   0FB4H   A 
COMM61_NONDAMP . .  C ADDR   0FB1H   A 
COMM6COMM1 . . . .  C ADDR   0F81H   A 
COMM34_NONDAMP . .  C ADDR   0EDAH   A 
COMM3COMM4 . . . .  C ADDR   0EB2H   A 
WAIT_FOR_COMP_OUT~  C ADDR   0D82H   A 
STARTUP_PWM_EXIT .  C ADDR   0BD5H   A 
CHECK_VOLTAGE_INP~  C ADDR   0B00H   A 
GOVERNOR_CORR_PRO~  C ADDR   0926H   A 
GOVERNOR_SPEED_CH~  C ADDR   07ABH   A 
GOV_PROP_PWM . . .  D ADDR   0047H   A 
GOV_PROPORTIONAL_L  D ADDR   0045H   A 
STEPPER_STEP_END_L  D ADDR   0035H   A 
FLAGS2 . . . . . .  D ADDR   002EH   A 
RCP_SKIP_CNT . . .  D ADDR   002AH   A 
DEFAULT_PGM_MULTI~  N NUMB   0002h            
TEMP_LIMIT_L . . .  N NUMB   00F6h            
SPIEN. . . . . . .  B ADDR   00F8H.0 A 
IE1. . . . . . . .  B ADDR   0088H.3 A 
ADC0GTL. . . . . .  D ADDR   00C3H   A 
OSCICN . . . . . .  D ADDR   00B2H   A 
XP_3A_MAIN . . . .  N NUMB   0001h            



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6894    ----
   XDATA SIZE       =   ----    ----
   DATA SIZE        =     80    ----
   IDATA SIZE       =     77    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


REGISTER BANK(S) USED : 0 

ASSEMBLY COMPLETE.   0 WARNING(S)   0 ERROR(S)
